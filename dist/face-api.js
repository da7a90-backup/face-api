/*
  Face-API
  homepage: <https://github.com/vladmandic/face-api>
  author: <https://github.com/vladmandic>'
*/

"use strict";var faceapi=(()=>{var Rh=Object.defineProperty;var eR=Object.getOwnPropertyDescriptor;var tR=Object.getOwnPropertyNames;var nR=Object.prototype.hasOwnProperty;var rR=(e,t,n)=>t in e?Rh(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n;var Ph=(e,t)=>{for(var n in t)Rh(e,n,{get:t[n],enumerable:!0})},sR=(e,t,n,r)=>{if(t&&typeof t=="object"||typeof t=="function")for(let s of tR(t))!nR.call(e,s)&&s!==n&&Rh(e,s,{get:()=>t[s],enumerable:!(r=eR(t,s))||r.enumerable});return e};var aR=e=>sR(Rh({},"__esModule",{value:!0}),e);var uS=(e,t,n)=>(rR(e,typeof t!="symbol"?t+"":t,n),n);var mge={};Ph(mge,{AgeGenderNet:()=>Xp,BoundingBox:()=>iu,Box:()=>ut,ComposableTask:()=>Ir,ComputeAllFaceDescriptorsTask:()=>Xs,ComputeFaceDescriptorsTaskBase:()=>Qp,ComputeSingleFaceDescriptorTask:()=>Ys,DetectAllFaceLandmarksTask:()=>th,DetectAllFacesTask:()=>Gl,DetectFaceLandmarksTaskBase:()=>eh,DetectFacesTaskBase:()=>rh,DetectSingleFaceLandmarksTask:()=>nh,DetectSingleFaceTask:()=>sh,Dimensions:()=>In,FACE_EXPRESSION_LABELS:()=>z0,FaceDetection:()=>vt,FaceDetectionNet:()=>j0,FaceExpressionNet:()=>Kp,FaceExpressions:()=>js,FaceLandmark68Net:()=>gu,FaceLandmark68TinyNet:()=>Yp,FaceLandmarkNet:()=>U0,FaceLandmarks:()=>ir,FaceLandmarks5:()=>S0,FaceLandmarks68:()=>cu,FaceMatch:()=>Al,FaceMatcher:()=>ah,FaceRecognitionNet:()=>bu,Gender:()=>kg,LabeledBox:()=>Dl,LabeledFaceDescriptors:()=>ws,NetInput:()=>ks,NeuralNetwork:()=>ln,ObjectDetection:()=>Us,Point:()=>Pe,PredictedBox:()=>C0,Rect:()=>uu,SsdMobilenetv1:()=>za,SsdMobilenetv1Options:()=>wr,TinyFaceDetector:()=>Iu,TinyFaceDetectorOptions:()=>Jp,TinyYolov2:()=>xu,TinyYolov2Options:()=>ts,allFaces:()=>pge,allFacesSsdMobilenetv1:()=>vF,allFacesTinyYolov2:()=>dge,awaitMediaLoaded:()=>F0,bufferToImage:()=>R0,computeFaceDescriptor:()=>Zme,createCanvas:()=>hu,createCanvasFromMedia:()=>Gp,createFaceDetectionNet:()=>Gme,createFaceRecognitionNet:()=>Fme,createSsdMobilenetv1:()=>sF,createTinyFaceDetector:()=>hge,createTinyYolov2:()=>qme,detectAllFaces:()=>$g,detectFaceLandmarks:()=>bF,detectFaceLandmarksTiny:()=>Yme,detectLandmarks:()=>cge,detectSingleFace:()=>lge,draw:()=>W0,env:()=>nt,euclideanDistance:()=>X0,extendWithAge:()=>Ng,extendWithFaceDescriptor:()=>Tg,extendWithFaceDetection:()=>lu,extendWithFaceExpressions:()=>vg,extendWithFaceLandmarks:()=>Bl,extendWithGender:()=>_g,extractFaceTensors:()=>Rl,extractFaces:()=>Fl,fetchImage:()=>vme,fetchJson:()=>M0,fetchNetWeights:()=>xme,fetchOrThrow:()=>Hs,fetchVideo:()=>wme,getContext2dOrThrow:()=>Hn,getMediaDimensions:()=>pu,imageTensorToCanvas:()=>P0,imageToSquare:()=>O0,inverseSigmoid:()=>pme,iou:()=>x0,isMediaElement:()=>dg,isMediaLoaded:()=>Up,isWithAge:()=>Rme,isWithFaceDetection:()=>Is,isWithFaceExpressions:()=>B0,isWithFaceLandmarks:()=>mu,isWithGender:()=>Pme,loadAgeGenderModel:()=>oge,loadFaceDetectionModel:()=>ige,loadFaceExpressionModel:()=>age,loadFaceLandmarkModel:()=>nge,loadFaceLandmarkTinyModel:()=>rge,loadFaceRecognitionModel:()=>sge,loadSsdMobilenetv1Model:()=>yF,loadTinyFaceDetectorModel:()=>ege,loadTinyYolov2Model:()=>tge,loadWeightMap:()=>L0,locateFaces:()=>uge,matchDimensions:()=>Ime,minBbox:()=>w0,nets:()=>rt,nonMaxSuppression:()=>I0,normalize:()=>Qr,padToSquare:()=>k0,predictAgeAndGender:()=>Qme,recognizeFaceExpressions:()=>Jme,resizeResults:()=>xF,resolveInput:()=>du,shuffleArray:()=>dme,sigmoid:()=>Wp,ssdMobilenetv1:()=>gF,tf:()=>Me,tinyFaceDetector:()=>Kme,tinyYolov2:()=>Xme,toNetInput:()=>xt,utils:()=>v0,validateConfig:()=>q0,version:()=>fge});var Me={};Ph(Me,{Abs:()=>cc,Acos:()=>Eo,Acosh:()=>Ao,AdadeltaOptimizer:()=>Hw,AdagradOptimizer:()=>jw,AdamOptimizer:()=>qw,AdamaxOptimizer:()=>Kw,Add:()=>Sa,AddN:()=>Do,All:()=>lc,Any:()=>dc,ArgMax:()=>pc,ArgMin:()=>hc,Asin:()=>$o,Asinh:()=>Fo,Atan:()=>Ro,Atan2:()=>Oo,Atanh:()=>Po,AvgPool:()=>Mo,AvgPool3D:()=>fc,AvgPool3DGrad:()=>Bd,AvgPoolGrad:()=>zd,BackendWasm:()=>F$,BatchMatMul:()=>Lo,BatchToSpaceND:()=>mc,Bincount:()=>gc,BitwiseAnd:()=>bc,BroadcastArgs:()=>Wd,BroadcastTo:()=>uC,Callback:()=>M_,CallbackList:()=>zN,Cast:()=>zo,Ceil:()=>Bo,ClipByValue:()=>Ca,Complex:()=>Bf,ComplexAbs:()=>Vd,Concat:()=>yc,Conv2D:()=>Wo,Conv2DBackpropFilter:()=>Wf,Conv2DBackpropInput:()=>Vo,Conv3D:()=>Uo,Conv3DBackpropFilterV2:()=>vc,Conv3DBackpropInputV2:()=>xc,Cos:()=>Go,Cosh:()=>Ho,CropAndResize:()=>Ic,Cumprod:()=>wc,Cumsum:()=>jo,CustomCallback:()=>WN,DataStorage:()=>Mf,DenseBincount:()=>Ud,DepthToSpace:()=>kc,DepthwiseConv2dNative:()=>qo,DepthwiseConv2dNativeBackpropFilter:()=>Vf,DepthwiseConv2dNativeBackpropInput:()=>Uf,Diag:()=>Gd,Dilation2D:()=>Ko,Dilation2DBackpropFilter:()=>Gu,Dilation2DBackpropInput:()=>Uu,Draw:()=>Gf,ENV:()=>Ax,EarlyStopping:()=>L_,Einsum:()=>Hf,Elu:()=>Yo,EluGrad:()=>Sc,Environment:()=>oC,Equal:()=>Cc,Erf:()=>Zo,Exp:()=>Jo,ExpandDims:()=>Tc,Expm1:()=>Qo,FFT:()=>jf,Fill:()=>Hd,FlipLeftRight:()=>Nc,Floor:()=>ei,FloorDiv:()=>ti,FromPixels:()=>lf,FusedBatchNorm:()=>ni,FusedConv2D:()=>lo,FusedDepthwiseConv2D:()=>po,GPGPUContext:()=>sf,GatherNd:()=>Ec,GatherV2:()=>_c,GraphModel:()=>Fk,Greater:()=>Ac,GreaterEqual:()=>ri,History:()=>BN,IFFT:()=>qf,Identity:()=>si,Imag:()=>Kf,InputSpec:()=>Wt,IsFinite:()=>ai,IsInf:()=>oi,IsNan:()=>ii,KernelBackend:()=>Md,LRN:()=>di,LRNGrad:()=>Mc,LayerVariable:()=>$N,LayersModel:()=>Fs,LeakyRelu:()=>ui,Less:()=>Dc,LessEqual:()=>$c,LinSpace:()=>Fc,Log:()=>ci,Log1p:()=>li,LogSoftmax:()=>lC,LogicalAnd:()=>Rc,LogicalNot:()=>Pc,LogicalOr:()=>Oc,LogicalXor:()=>cC,LowerBound:()=>ZR,MathBackendCPU:()=>Qm,MathBackendWebGL:()=>ng,MatrixBandPart:()=>JR,Max:()=>pi,MaxPool:()=>fi,MaxPool3D:()=>Lc,MaxPool3DGrad:()=>qd,MaxPoolGrad:()=>jd,MaxPoolWithArgmax:()=>Kd,Maximum:()=>hi,Mean:()=>mi,Min:()=>gi,Minimum:()=>bi,MirrorPad:()=>yi,Mod:()=>vi,MomentumOptimizer:()=>Xw,Multinomial:()=>zc,Multiply:()=>xi,Neg:()=>Bc,NonMaxSuppressionV3:()=>Vc,NonMaxSuppressionV4:()=>Uc,NonMaxSuppressionV5:()=>Gc,NotEqual:()=>Wc,OP_SCOPE_SUFFIX:()=>Rx,OneHot:()=>wi,OnesLike:()=>Hc,Optimizer:()=>zs,OptimizerConstructors:()=>mN,Pack:()=>jc,PadV2:()=>Ii,Pool:()=>QR,Pow:()=>ki,Prelu:()=>Si,Prod:()=>Ci,RMSPropOptimizer:()=>Yw,RNN:()=>ys,RaggedGather:()=>Xf,RaggedRange:()=>Yf,RaggedTensorToTensor:()=>Zf,Range:()=>Xd,Rank:()=>Ev,Real:()=>Jf,RealDiv:()=>Xo,Reciprocal:()=>Ti,Reduction:()=>Tn,Relu:()=>Ni,Relu6:()=>Ai,Reshape:()=>qc,ResizeBilinear:()=>Ei,ResizeBilinearGrad:()=>Xc,ResizeNearestNeighbor:()=>_i,ResizeNearestNeighborGrad:()=>Kc,Reverse:()=>Di,RotateWithOffset:()=>ll,Round:()=>$i,Rsqrt:()=>Fi,SGDOptimizer:()=>Fm,ScatterNd:()=>Yc,SearchSorted:()=>Jc,Select:()=>Qc,Selu:()=>Ri,Sequential:()=>nc,Sigmoid:()=>Li,Sign:()=>Mi,Sin:()=>Pi,Sinh:()=>Oi,Slice:()=>el,Softmax:()=>Vi,Softplus:()=>zi,SpaceToBatchND:()=>tl,SparseFillEmptyRows:()=>Yd,SparseReshape:()=>rl,SparseSegmentMean:()=>Zd,SparseSegmentSum:()=>Jd,SparseToDense:()=>sl,SplitV:()=>nl,Sqrt:()=>Bi,Square:()=>Qd,SquaredDifference:()=>Ui,StaticRegexReplace:()=>ep,Step:()=>Na,StridedSlice:()=>al,StringNGrams:()=>tp,StringSplit:()=>np,StringToHashBucketFast:()=>rp,Sub:()=>Gi,Sum:()=>Wi,SymbolicTensor:()=>Ur,Tan:()=>Hi,Tanh:()=>ji,Tensor:()=>Te,TensorBuffer:()=>Vt,TensorScatterUpdate:()=>Zc,Tile:()=>Ta,TopK:()=>ol,Transform:()=>il,Transpose:()=>$s,Unique:()=>sp,Unpack:()=>ul,UnsortedSegmentSum:()=>ap,UpperBound:()=>eP,Variable:()=>fa,ZerosLike:()=>cl,_FusedMatMul:()=>co,abs:()=>Bt,acos:()=>zx,acosh:()=>Bx,add:()=>X,addN:()=>PC,all:()=>rm,any:()=>Sd,argMax:()=>mo,argMin:()=>Wx,asin:()=>Vx,asinh:()=>Ux,atan:()=>Gx,atan2:()=>Hx,atanh:()=>jx,avgPool:()=>br,avgPool3d:()=>Kx,backend:()=>RC,backend_util:()=>T,basicLSTMCell:()=>zC,batchNorm:()=>Ea,batchNorm2d:()=>Xx,batchNorm3d:()=>Yx,batchNorm4d:()=>Zx,batchToSpaceND:()=>pp,bincount:()=>Jx,bitwiseAnd:()=>BC,booleanMaskAsync:()=>ET,broadcastArgs:()=>WC,broadcastTo:()=>oo,broadcast_util:()=>dl,browser:()=>Yi,buffer:()=>ze,callbacks:()=>V5,cast:()=>ae,ceil:()=>Qx,clipByValue:()=>an,clone:()=>us,complex:()=>Rs,concat:()=>tt,concat1d:()=>ew,concat2d:()=>tw,concat3d:()=>nw,concat4d:()=>rw,constraints:()=>PN,conv1d:()=>sm,conv2d:()=>Pt,conv2dTranspose:()=>am,conv3d:()=>aw,conv3dTranspose:()=>ow,copyRegisteredKernels:()=>sP,cos:()=>hp,cosh:()=>om,cosineWindow:()=>_m,cumprod:()=>Nd,cumsum:()=>im,customGrad:()=>ps,data:()=>i2,denseBincount:()=>mf,deprecationWarn:()=>Lx,depthToSpace:()=>iw,depthwiseConv2d:()=>Aa,deregisterOp:()=>H5,device_util:()=>cp,diag:()=>UC,dilation2d:()=>uw,disableDeprecationWarnings:()=>gO,dispose:()=>_e,disposeVariables:()=>bO,div:()=>fe,divNoNan:()=>cw,dot:()=>lw,dropout:()=>Bw,einsum:()=>Ja,elu:()=>pl,enableDebugMode:()=>mO,enableProdMode:()=>fO,enclosingPowerOfTwo:()=>Ww,engine:()=>Dr,ensureShape:()=>HC,env:()=>G,equal:()=>nr,erf:()=>dw,euclideanNorm:()=>fw,exp:()=>vn,expandDims:()=>jt,expm1:()=>mw,eye:()=>um,fft:()=>Ip,fill:()=>xn,findBackend:()=>SO,findBackendFactory:()=>CO,floor:()=>fl,floorDiv:()=>nm,forceHalfFloat:()=>NA,fused:()=>Ju,gather:()=>ml,gatherND:()=>FT,gather_util:()=>Qw,getBackend:()=>IO,getGradient:()=>Nv,getKernel:()=>xd,getKernelsForBackend:()=>df,getThreadsCount:()=>nme,gpgpu_util:()=>aA,grad:()=>wM,grads:()=>IM,greater:()=>Dn,greaterEqual:()=>Ms,ifft:()=>Zu,imag:()=>fp,image:()=>tr,inTopKAsync:()=>RT,initializers:()=>ON,input:()=>t_,io:()=>Kt,irfft:()=>Im,isFinite:()=>gw,isInf:()=>bw,isNaN:()=>yw,keep:()=>qt,kernel_impls:()=>bs,layers:()=>MN,leakyRelu:()=>mp,less:()=>qu,lessEqual:()=>Da,linalg:()=>Gw,linspace:()=>YC,loadGraphModel:()=>Zj,loadGraphModelSync:()=>Jj,loadLayersModel:()=>LH,localResponseNormalization:()=>vw,log:()=>rr,log1p:()=>gp,logSigmoid:()=>xw,logSoftmax:()=>lm,logSumExp:()=>dm,logicalAnd:()=>Rr,logicalNot:()=>bp,logicalOr:()=>pm,logicalXor:()=>ww,losses:()=>jT,lowerBound:()=>JC,matMul:()=>Fe,math:()=>nN,max:()=>fr,maxPool:()=>Ot,maxPool3d:()=>Iw,maxPoolWithArgmax:()=>QC,maximum:()=>gs,mean:()=>Et,memory:()=>ff,meshgrid:()=>eT,metrics:()=>R_,min:()=>ju,minimum:()=>ga,mirrorPad:()=>kw,mod:()=>Sw,model:()=>WH,models:()=>P_,moments:()=>yp,movingAverage:()=>AT,mul:()=>B,multiRNNCell:()=>tT,multinomial:()=>nT,neg:()=>bt,nextFrame:()=>eI,norm:()=>hl,notEqual:()=>vo,oneHot:()=>Ku,ones:()=>er,onesLike:()=>sr,op:()=>z,outerProduct:()=>rT,pad:()=>yr,pad1d:()=>sT,pad2d:()=>aT,pad3d:()=>oT,pad4d:()=>iT,pool:()=>Cw,pow:()=>Ps,prelu:()=>xp,print:()=>Mx,prod:()=>Tw,profile:()=>yO,raggedGather:()=>uT,raggedRange:()=>cT,raggedTensorToTensor:()=>lT,rand:()=>dT,randomGamma:()=>mT,randomNormal:()=>fm,randomStandardNormal:()=>gT,randomUniform:()=>$a,randomUniformInt:()=>bT,range:()=>xo,ready:()=>wO,real:()=>Xu,reciprocal:()=>Dw,registerBackend:()=>tm,registerCallbackConstructor:()=>UH,registerGradient:()=>dC,registerKernel:()=>op,registerOp:()=>G5,regularizers:()=>O_,relu:()=>Ke,relu6:()=>mm,removeBackend:()=>kO,reshape:()=>W,reverse:()=>gr,reverse1d:()=>yT,reverse2d:()=>vT,reverse3d:()=>xT,reverse4d:()=>wT,rfft:()=>kp,round:()=>gm,rsqrt:()=>bm,scalar:()=>xe,scatterND:()=>DT,scatter_util:()=>Sm,searchSorted:()=>hm,selu:()=>ym,separableConv2d:()=>Fa,sequential:()=>VH,serialization:()=>re,setBackend:()=>xO,setPlatform:()=>TO,setThreadsCount:()=>tme,setWasmPath:()=>Qfe,setWasmPaths:()=>eme,setWebGLContext:()=>EE,setdiff1dAsync:()=>IT,shared:()=>Mk,sigmoid:()=>hr,sign:()=>$w,signal:()=>HT,sin:()=>vm,sinh:()=>xm,slice:()=>Ue,slice1d:()=>wp,slice2d:()=>wm,slice3d:()=>Ki,slice4d:()=>Yu,slice_util:()=>Yt,softmax:()=>Yr,softplus:()=>qi,spaceToBatchND:()=>vp,sparse:()=>qT,sparseToDense:()=>$T,spectral:()=>GT,split:()=>zn,sqrt:()=>fn,square:()=>ct,squaredDifference:()=>km,squeeze:()=>Ra,stack:()=>Rt,step:()=>Xi,stridedSlice:()=>Fw,string:()=>KT,sub:()=>de,sum:()=>ge,sumOutType:()=>em,tan:()=>Rw,tanh:()=>bo,tensor:()=>yn,tensor1d:()=>He,tensor2d:()=>Fr,tensor3d:()=>Sp,tensor4d:()=>Or,tensor5d:()=>kT,tensor6d:()=>ST,tensorScatterUpdate:()=>TT,tensor_util:()=>Gr,test_util:()=>pT,tidy:()=>O,tile:()=>Ln,time:()=>vO,topk:()=>Ow,train:()=>Ya,transpose:()=>Re,truncatedNormal:()=>Tm,unique:()=>Mw,unregisterGradient:()=>rP,unregisterKernel:()=>nP,unsortedSegmentSum:()=>Nm,unstack:()=>dt,upcastType:()=>mr,upperBound:()=>NT,util:()=>w,valueAndGrad:()=>kM,valueAndGrads:()=>SM,variable:()=>Lw,variableGrads:()=>ZC,version:()=>cme,version_converter:()=>eq,version_core:()=>qW,version_cpu:()=>J8,version_layers:()=>II,version_wasm:()=>rme,version_webgl:()=>WQ,webgl:()=>VQ,webgl_util:()=>_E,where:()=>sn,whereAsync:()=>zw,zeros:()=>Ct,zerosLike:()=>je});var oR=Object.create,Tx=Object.defineProperty,iR=Object.getOwnPropertyDescriptor,q1=Object.getOwnPropertyNames,uR=Object.getPrototypeOf,cR=Object.prototype.hasOwnProperty,Gt=(e,t)=>function(){return t||(0,e[q1(e)[0]])((t={exports:{}}).exports,t),t.exports},Ee=(e,t)=>{for(var n in t)Tx(e,n,{get:t[n],enumerable:!0})},lR=(e,t,n,r)=>{if(t&&typeof t=="object"||typeof t=="function")for(let s of q1(t))!cR.call(e,s)&&s!==n&&Tx(e,s,{get:()=>t[s],enumerable:!(r=iR(t,s))||r.enumerable});return e},ka=(e,t,n)=>(n=e!=null?oR(uR(e)):{},lR(t||!e||!e.__esModule?Tx(n,"default",{value:e,enumerable:!0}):n,e)),dR=Gt({"node_modules/long/src/long.js"(e,t){t.exports=r;var n=null;try{n=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function r(F,C,L){this.low=F|0,this.high=C|0,this.unsigned=!!L}r.prototype.__isLong__,Object.defineProperty(r.prototype,"__isLong__",{value:!0});function s(F){return(F&&F.__isLong__)===!0}r.isLong=s;var a={},o={};function i(F,C){var L,U,H;return C?(F>>>=0,(H=0<=F&&F<256)&&(U=o[F],U)?U:(L=c(F,(F|0)<0?-1:0,!0),H&&(o[F]=L),L)):(F|=0,(H=-128<=F&&F<128)&&(U=a[F],U)?U:(L=c(F,F<0?-1:0,!1),H&&(a[F]=L),L))}r.fromInt=i;function u(F,C){if(isNaN(F))return C?x:y;if(C){if(F<0)return x;if(F>=m)return $}else{if(F<=-b)return R;if(F+1>=b)return E}return F<0?u(-F,C).neg():c(F%g|0,F/g|0,C)}r.fromNumber=u;function c(F,C,L){return new r(F,C,L)}r.fromBits=c;var l=Math.pow;function p(F,C,L){if(F.length===0)throw Error("empty string");if(F==="NaN"||F==="Infinity"||F==="+Infinity"||F==="-Infinity")return y;if(typeof C=="number"?(L=C,C=!1):C=!!C,L=L||10,L<2||36<L)throw RangeError("radix");var U;if((U=F.indexOf("-"))>0)throw Error("interior hyphen");if(U===0)return p(F.substring(1),C,L).neg();for(var H=u(l(L,8)),K=y,q=0;q<F.length;q+=8){var Z=Math.min(8,F.length-q),J=parseInt(F.substring(q,q+Z),L);if(Z<8){var ee=u(l(L,Z));K=K.mul(ee).add(u(J))}else K=K.mul(H),K=K.add(u(J))}return K.unsigned=C,K}r.fromString=p;function d(F,C){return typeof F=="number"?u(F,C):typeof F=="string"?p(F,C):c(F.low,F.high,typeof C=="boolean"?C:F.unsigned)}r.fromValue=d;var h=65536,f=1<<24,g=h*h,m=g*g,b=m/2,v=i(f),y=i(0);r.ZERO=y;var x=i(0,!0);r.UZERO=x;var k=i(1);r.ONE=k;var S=i(1,!0);r.UONE=S;var N=i(-1);r.NEG_ONE=N;var E=c(-1,2147483647,!1);r.MAX_VALUE=E;var $=c(-1,-1,!0);r.MAX_UNSIGNED_VALUE=$;var R=c(0,-2147483648,!1);r.MIN_VALUE=R;var D=r.prototype;D.toInt=function(){return this.unsigned?this.low>>>0:this.low},D.toNumber=function(){return this.unsigned?(this.high>>>0)*g+(this.low>>>0):this.high*g+(this.low>>>0)},D.toString=function(C){if(C=C||10,C<2||36<C)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(R)){var L=u(C),U=this.div(L),H=U.mul(L).sub(this);return U.toString(C)+H.toInt().toString(C)}else return"-"+this.neg().toString(C);for(var K=u(l(C,6),this.unsigned),q=this,Z="";;){var J=q.div(K),ee=q.sub(J.mul(K)).toInt()>>>0,se=ee.toString(C);if(q=J,q.isZero())return se+Z;for(;se.length<6;)se="0"+se;Z=""+se+Z}},D.getHighBits=function(){return this.high},D.getHighBitsUnsigned=function(){return this.high>>>0},D.getLowBits=function(){return this.low},D.getLowBitsUnsigned=function(){return this.low>>>0},D.getNumBitsAbs=function(){if(this.isNegative())return this.eq(R)?64:this.neg().getNumBitsAbs();for(var C=this.high!=0?this.high:this.low,L=31;L>0&&!(C&1<<L);L--);return this.high!=0?L+33:L+1},D.isZero=function(){return this.high===0&&this.low===0},D.eqz=D.isZero,D.isNegative=function(){return!this.unsigned&&this.high<0},D.isPositive=function(){return this.unsigned||this.high>=0},D.isOdd=function(){return(this.low&1)===1},D.isEven=function(){return(this.low&1)===0},D.equals=function(C){return s(C)||(C=d(C)),this.unsigned!==C.unsigned&&this.high>>>31===1&&C.high>>>31===1?!1:this.high===C.high&&this.low===C.low},D.eq=D.equals,D.notEquals=function(C){return!this.eq(C)},D.neq=D.notEquals,D.ne=D.notEquals,D.lessThan=function(C){return this.comp(C)<0},D.lt=D.lessThan,D.lessThanOrEqual=function(C){return this.comp(C)<=0},D.lte=D.lessThanOrEqual,D.le=D.lessThanOrEqual,D.greaterThan=function(C){return this.comp(C)>0},D.gt=D.greaterThan,D.greaterThanOrEqual=function(C){return this.comp(C)>=0},D.gte=D.greaterThanOrEqual,D.ge=D.greaterThanOrEqual,D.compare=function(C){if(s(C)||(C=d(C)),this.eq(C))return 0;var L=this.isNegative(),U=C.isNegative();return L&&!U?-1:!L&&U?1:this.unsigned?C.high>>>0>this.high>>>0||C.high===this.high&&C.low>>>0>this.low>>>0?-1:1:this.sub(C).isNegative()?-1:1},D.comp=D.compare,D.negate=function(){return!this.unsigned&&this.eq(R)?R:this.not().add(k)},D.neg=D.negate,D.add=function(C){s(C)||(C=d(C));var L=this.high>>>16,U=this.high&65535,H=this.low>>>16,K=this.low&65535,q=C.high>>>16,Z=C.high&65535,J=C.low>>>16,ee=C.low&65535,se=0,te=0,oe=0,ne=0;return ne+=K+ee,oe+=ne>>>16,ne&=65535,oe+=H+J,te+=oe>>>16,oe&=65535,te+=U+Z,se+=te>>>16,te&=65535,se+=L+q,se&=65535,c(oe<<16|ne,se<<16|te,this.unsigned)},D.subtract=function(C){return s(C)||(C=d(C)),this.add(C.neg())},D.sub=D.subtract,D.multiply=function(C){if(this.isZero())return y;if(s(C)||(C=d(C)),n){var L=n.mul(this.low,this.high,C.low,C.high);return c(L,n.get_high(),this.unsigned)}if(C.isZero())return y;if(this.eq(R))return C.isOdd()?R:y;if(C.eq(R))return this.isOdd()?R:y;if(this.isNegative())return C.isNegative()?this.neg().mul(C.neg()):this.neg().mul(C).neg();if(C.isNegative())return this.mul(C.neg()).neg();if(this.lt(v)&&C.lt(v))return u(this.toNumber()*C.toNumber(),this.unsigned);var U=this.high>>>16,H=this.high&65535,K=this.low>>>16,q=this.low&65535,Z=C.high>>>16,J=C.high&65535,ee=C.low>>>16,se=C.low&65535,te=0,oe=0,ne=0,le=0;return le+=q*se,ne+=le>>>16,le&=65535,ne+=K*se,oe+=ne>>>16,ne&=65535,ne+=q*ee,oe+=ne>>>16,ne&=65535,oe+=H*se,te+=oe>>>16,oe&=65535,oe+=K*ee,te+=oe>>>16,oe&=65535,oe+=q*J,te+=oe>>>16,oe&=65535,te+=U*se+H*ee+K*J+q*Z,te&=65535,c(ne<<16|le,te<<16|oe,this.unsigned)},D.mul=D.multiply,D.divide=function(C){if(s(C)||(C=d(C)),C.isZero())throw Error("division by zero");if(n){if(!this.unsigned&&this.high===-2147483648&&C.low===-1&&C.high===-1)return this;var L=(this.unsigned?n.div_u:n.div_s)(this.low,this.high,C.low,C.high);return c(L,n.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?x:y;var U,H,K;if(this.unsigned){if(C.unsigned||(C=C.toUnsigned()),C.gt(this))return x;if(C.gt(this.shru(1)))return S;K=x}else{if(this.eq(R)){if(C.eq(k)||C.eq(N))return R;if(C.eq(R))return k;var q=this.shr(1);return U=q.div(C).shl(1),U.eq(y)?C.isNegative()?k:N:(H=this.sub(C.mul(U)),K=U.add(H.div(C)),K)}else if(C.eq(R))return this.unsigned?x:y;if(this.isNegative())return C.isNegative()?this.neg().div(C.neg()):this.neg().div(C).neg();if(C.isNegative())return this.div(C.neg()).neg();K=y}for(H=this;H.gte(C);){U=Math.max(1,Math.floor(H.toNumber()/C.toNumber()));for(var Z=Math.ceil(Math.log(U)/Math.LN2),J=Z<=48?1:l(2,Z-48),ee=u(U),se=ee.mul(C);se.isNegative()||se.gt(H);)U-=J,ee=u(U,this.unsigned),se=ee.mul(C);ee.isZero()&&(ee=k),K=K.add(ee),H=H.sub(se)}return K},D.div=D.divide,D.modulo=function(C){if(s(C)||(C=d(C)),n){var L=(this.unsigned?n.rem_u:n.rem_s)(this.low,this.high,C.low,C.high);return c(L,n.get_high(),this.unsigned)}return this.sub(this.div(C).mul(C))},D.mod=D.modulo,D.rem=D.modulo,D.not=function(){return c(~this.low,~this.high,this.unsigned)},D.and=function(C){return s(C)||(C=d(C)),c(this.low&C.low,this.high&C.high,this.unsigned)},D.or=function(C){return s(C)||(C=d(C)),c(this.low|C.low,this.high|C.high,this.unsigned)},D.xor=function(C){return s(C)||(C=d(C)),c(this.low^C.low,this.high^C.high,this.unsigned)},D.shiftLeft=function(C){return s(C)&&(C=C.toInt()),(C&=63)===0?this:C<32?c(this.low<<C,this.high<<C|this.low>>>32-C,this.unsigned):c(0,this.low<<C-32,this.unsigned)},D.shl=D.shiftLeft,D.shiftRight=function(C){return s(C)&&(C=C.toInt()),(C&=63)===0?this:C<32?c(this.low>>>C|this.high<<32-C,this.high>>C,this.unsigned):c(this.high>>C-32,this.high>=0?0:-1,this.unsigned)},D.shr=D.shiftRight,D.shiftRightUnsigned=function(C){if(s(C)&&(C=C.toInt()),C&=63,C===0)return this;var L=this.high;if(C<32){var U=this.low;return c(U>>>C|L<<32-C,L>>>C,this.unsigned)}else return C===32?c(L,0,this.unsigned):c(L>>>C-32,0,this.unsigned)},D.shru=D.shiftRightUnsigned,D.shr_u=D.shiftRightUnsigned,D.toSigned=function(){return this.unsigned?c(this.low,this.high,!1):this},D.toUnsigned=function(){return this.unsigned?this:c(this.low,this.high,!0)},D.toBytes=function(C){return C?this.toBytesLE():this.toBytesBE()},D.toBytesLE=function(){var C=this.high,L=this.low;return[L&255,L>>>8&255,L>>>16&255,L>>>24,C&255,C>>>8&255,C>>>16&255,C>>>24]},D.toBytesBE=function(){var C=this.high,L=this.low;return[C>>>24,C>>>16&255,C>>>8&255,C&255,L>>>24,L>>>16&255,L>>>8&255,L&255]},r.fromBytes=function(C,L,U){return U?r.fromBytesLE(C,L):r.fromBytesBE(C,L)},r.fromBytesLE=function(C,L){return new r(C[0]|C[1]<<8|C[2]<<16|C[3]<<24,C[4]|C[5]<<8|C[6]<<16|C[7]<<24,L)},r.fromBytesBE=function(C,L){return new r(C[4]<<24|C[5]<<16|C[6]<<8|C[7],C[0]<<24|C[1]<<16|C[2]<<8|C[3],L)}}}),pR=Gt({"(disabled):node_modules/node-fetch/browser.js"(){}}),hR=Gt({"(disabled):util"(){}}),fR=Gt({"node_modules/seedrandom/lib/alea.js"(e,t){(function(n,r,s){function a(c){var l=this,p=u();l.next=function(){var d=2091639*l.s0+l.c*23283064365386963e-26;return l.s0=l.s1,l.s1=l.s2,l.s2=d-(l.c=d|0)},l.c=1,l.s0=p(" "),l.s1=p(" "),l.s2=p(" "),l.s0-=p(c),l.s0<0&&(l.s0+=1),l.s1-=p(c),l.s1<0&&(l.s1+=1),l.s2-=p(c),l.s2<0&&(l.s2+=1),p=null}function o(c,l){return l.c=c.c,l.s0=c.s0,l.s1=c.s1,l.s2=c.s2,l}function i(c,l){var p=new a(c),d=l&&l.state,h=p.next;return h.int32=function(){return p.next()*4294967296|0},h.double=function(){return h()+(h()*2097152|0)*11102230246251565e-32},h.quick=h,d&&(typeof d=="object"&&o(d,p),h.state=function(){return o(p,{})}),h}function u(){var c=4022871197,l=function(p){p=String(p);for(var d=0;d<p.length;d++){c+=p.charCodeAt(d);var h=.02519603282416938*c;c=h>>>0,h-=c,h*=c,c=h>>>0,h-=c,c+=h*4294967296}return(c>>>0)*23283064365386963e-26};return l}r&&r.exports?r.exports=i:s&&s.amd?s(function(){return i}):this.alea=i})(e,typeof t=="object"&&t,typeof define=="function"&&define)}}),mR=Gt({"node_modules/seedrandom/lib/xor128.js"(e,t){(function(n,r,s){function a(u){var c=this,l="";c.x=0,c.y=0,c.z=0,c.w=0,c.next=function(){var d=c.x^c.x<<11;return c.x=c.y,c.y=c.z,c.z=c.w,c.w^=c.w>>>19^d^d>>>8},u===(u|0)?c.x=u:l+=u;for(var p=0;p<l.length+64;p++)c.x^=l.charCodeAt(p)|0,c.next()}function o(u,c){return c.x=u.x,c.y=u.y,c.z=u.z,c.w=u.w,c}function i(u,c){var l=new a(u),p=c&&c.state,d=function(){return(l.next()>>>0)/4294967296};return d.double=function(){do var h=l.next()>>>11,f=(l.next()>>>0)/4294967296,g=(h+f)/(1<<21);while(g===0);return g},d.int32=l.next,d.quick=d,p&&(typeof p=="object"&&o(p,l),d.state=function(){return o(l,{})}),d}r&&r.exports?r.exports=i:s&&s.amd?s(function(){return i}):this.xor128=i})(e,typeof t=="object"&&t,typeof define=="function"&&define)}}),gR=Gt({"node_modules/seedrandom/lib/xorwow.js"(e,t){(function(n,r,s){function a(u){var c=this,l="";c.next=function(){var d=c.x^c.x>>>2;return c.x=c.y,c.y=c.z,c.z=c.w,c.w=c.v,(c.d=c.d+362437|0)+(c.v=c.v^c.v<<4^(d^d<<1))|0},c.x=0,c.y=0,c.z=0,c.w=0,c.v=0,u===(u|0)?c.x=u:l+=u;for(var p=0;p<l.length+64;p++)c.x^=l.charCodeAt(p)|0,p==l.length&&(c.d=c.x<<10^c.x>>>4),c.next()}function o(u,c){return c.x=u.x,c.y=u.y,c.z=u.z,c.w=u.w,c.v=u.v,c.d=u.d,c}function i(u,c){var l=new a(u),p=c&&c.state,d=function(){return(l.next()>>>0)/4294967296};return d.double=function(){do var h=l.next()>>>11,f=(l.next()>>>0)/4294967296,g=(h+f)/(1<<21);while(g===0);return g},d.int32=l.next,d.quick=d,p&&(typeof p=="object"&&o(p,l),d.state=function(){return o(l,{})}),d}r&&r.exports?r.exports=i:s&&s.amd?s(function(){return i}):this.xorwow=i})(e,typeof t=="object"&&t,typeof define=="function"&&define)}}),bR=Gt({"node_modules/seedrandom/lib/xorshift7.js"(e,t){(function(n,r,s){function a(u){var c=this;c.next=function(){var p=c.x,d=c.i,h,f,g;return h=p[d],h^=h>>>7,f=h^h<<24,h=p[d+1&7],f^=h^h>>>10,h=p[d+3&7],f^=h^h>>>3,h=p[d+4&7],f^=h^h<<7,h=p[d+7&7],h=h^h<<13,f^=h^h<<9,p[d]=f,c.i=d+1&7,f};function l(p,d){var h,f,g=[];if(d===(d|0))f=g[0]=d;else for(d=""+d,h=0;h<d.length;++h)g[h&7]=g[h&7]<<15^d.charCodeAt(h)+g[h+1&7]<<13;for(;g.length<8;)g.push(0);for(h=0;h<8&&g[h]===0;++h);for(h==8?f=g[7]=-1:f=g[h],p.x=g,p.i=0,h=256;h>0;--h)p.next()}l(c,u)}function o(u,c){return c.x=u.x.slice(),c.i=u.i,c}function i(u,c){u==null&&(u=+new Date);var l=new a(u),p=c&&c.state,d=function(){return(l.next()>>>0)/4294967296};return d.double=function(){do var h=l.next()>>>11,f=(l.next()>>>0)/4294967296,g=(h+f)/(1<<21);while(g===0);return g},d.int32=l.next,d.quick=d,p&&(p.x&&o(p,l),d.state=function(){return o(l,{})}),d}r&&r.exports?r.exports=i:s&&s.amd?s(function(){return i}):this.xorshift7=i})(e,typeof t=="object"&&t,typeof define=="function"&&define)}}),yR=Gt({"node_modules/seedrandom/lib/xor4096.js"(e,t){(function(n,r,s){function a(u){var c=this;c.next=function(){var p=c.w,d=c.X,h=c.i,f,g;return c.w=p=p+1640531527|0,g=d[h+34&127],f=d[h=h+1&127],g^=g<<13,f^=f<<17,g^=g>>>15,f^=f>>>12,g=d[h]=g^f,c.i=h,g+(p^p>>>16)|0};function l(p,d){var h,f,g,m,b,v=[],y=128;for(d===(d|0)?(f=d,d=null):(d=d+"\0",f=0,y=Math.max(y,d.length)),g=0,m=-32;m<y;++m)d&&(f^=d.charCodeAt((m+32)%d.length)),m===0&&(b=f),f^=f<<10,f^=f>>>15,f^=f<<4,f^=f>>>13,m>=0&&(b=b+1640531527|0,h=v[m&127]^=f+b,g=h==0?g+1:0);for(g>=128&&(v[(d&&d.length||0)&127]=-1),g=127,m=4*128;m>0;--m)f=v[g+34&127],h=v[g=g+1&127],f^=f<<13,h^=h<<17,f^=f>>>15,h^=h>>>12,v[g]=f^h;p.w=b,p.X=v,p.i=g}l(c,u)}function o(u,c){return c.i=u.i,c.w=u.w,c.X=u.X.slice(),c}function i(u,c){u==null&&(u=+new Date);var l=new a(u),p=c&&c.state,d=function(){return(l.next()>>>0)/4294967296};return d.double=function(){do var h=l.next()>>>11,f=(l.next()>>>0)/4294967296,g=(h+f)/(1<<21);while(g===0);return g},d.int32=l.next,d.quick=d,p&&(p.X&&o(p,l),d.state=function(){return o(l,{})}),d}r&&r.exports?r.exports=i:s&&s.amd?s(function(){return i}):this.xor4096=i})(e,typeof t=="object"&&t,typeof define=="function"&&define)}}),vR=Gt({"node_modules/seedrandom/lib/tychei.js"(e,t){(function(n,r,s){function a(u){var c=this,l="";c.next=function(){var d=c.b,h=c.c,f=c.d,g=c.a;return d=d<<25^d>>>7^h,h=h-f|0,f=f<<24^f>>>8^g,g=g-d|0,c.b=d=d<<20^d>>>12^h,c.c=h=h-f|0,c.d=f<<16^h>>>16^g,c.a=g-d|0},c.a=0,c.b=0,c.c=-1640531527,c.d=1367130551,u===Math.floor(u)?(c.a=u/4294967296|0,c.b=u|0):l+=u;for(var p=0;p<l.length+20;p++)c.b^=l.charCodeAt(p)|0,c.next()}function o(u,c){return c.a=u.a,c.b=u.b,c.c=u.c,c.d=u.d,c}function i(u,c){var l=new a(u),p=c&&c.state,d=function(){return(l.next()>>>0)/4294967296};return d.double=function(){do var h=l.next()>>>11,f=(l.next()>>>0)/4294967296,g=(h+f)/(1<<21);while(g===0);return g},d.int32=l.next,d.quick=d,p&&(typeof p=="object"&&o(p,l),d.state=function(){return o(l,{})}),d}r&&r.exports?r.exports=i:s&&s.amd?s(function(){return i}):this.tychei=i})(e,typeof t=="object"&&t,typeof define=="function"&&define)}}),xR=Gt({"(disabled):crypto"(){}}),wR=Gt({"node_modules/seedrandom/seedrandom.js"(e,t){(function(n,r,s){var a=256,o=6,i=52,u="random",c=s.pow(a,o),l=s.pow(2,i),p=l*2,d=a-1,h;function f(k,S,N){var E=[];S=S==!0?{entropy:!0}:S||{};var $=v(b(S.entropy?[k,x(r)]:k??y(),3),E),R=new g(E),D=function(){for(var F=R.g(o),C=c,L=0;F<l;)F=(F+L)*a,C*=a,L=R.g(1);for(;F>=p;)F/=2,C/=2,L>>>=1;return(F+L)/C};return D.int32=function(){return R.g(4)|0},D.quick=function(){return R.g(4)/4294967296},D.double=D,v(x(R.S),r),(S.pass||N||function(F,C,L,U){return U&&(U.S&&m(U,R),F.state=function(){return m(R,{})}),L?(s[u]=F,C):F})(D,$,"global"in S?S.global:this==s,S.state)}function g(k){var S,N=k.length,E=this,$=0,R=E.i=E.j=0,D=E.S=[];for(N||(k=[N++]);$<a;)D[$]=$++;for($=0;$<a;$++)D[$]=D[R=d&R+k[$%N]+(S=D[$])],D[R]=S;(E.g=function(F){for(var C,L=0,U=E.i,H=E.j,K=E.S;F--;)C=K[U=d&U+1],L=L*a+K[d&(K[U]=K[H=d&H+C])+(K[H]=C)];return E.i=U,E.j=H,L})(a)}function m(k,S){return S.i=k.i,S.j=k.j,S.S=k.S.slice(),S}function b(k,S){var N=[],E=typeof k,$;if(S&&E=="object")for($ in k)try{N.push(b(k[$],S-1))}catch{}return N.length?N:E=="string"?k:k+"\0"}function v(k,S){for(var N=k+"",E,$=0;$<N.length;)S[d&$]=d&(E^=S[d&$]*19)+N.charCodeAt($++);return x(S)}function y(){try{var k;return h&&(k=h.randomBytes)?k=k(a):(k=new Uint8Array(a),(n.crypto||n.msCrypto).getRandomValues(k)),x(k)}catch{var S=n.navigator,N=S&&S.plugins;return[+new Date,n,N,n.screen,x(r)]}}function x(k){return String.fromCharCode.apply(0,k)}if(v(s.random(),r),typeof t=="object"&&t.exports){t.exports=f;try{h=xR()}catch{}}else typeof define=="function"&&define.amd?define(function(){return f}):s["seed"+u]=f})(typeof self<"u"?self:e,[],Math)}}),Of=Gt({"node_modules/seedrandom/index.js"(e,t){var n=fR(),r=mR(),s=gR(),a=bR(),o=yR(),i=vR(),u=wR();u.alea=n,u.xor128=r,u.xorwow=s,u.xorshift7=a,u.xor4096=o,u.tychei=i,t.exports=u}}),K1=Gt({"(disabled):node_modules/string_decoder/lib/string_decoder.js"(){}}),Nx=Gt({"(disabled):fs"(){}}),X1=Gt({"(disabled):path"(){}}),IR=Gt({"(disabled):worker_threads"(){}}),kR=Gt({"(disabled):perf_hooks"(){}}),SR=Gt({"(disabled):os"(){}}),CR=Gt({"node_modules/@tensorflow/tfjs-backend-wasm/wasm-out/tfjs-backend-wasm-threaded-simd.js"(e,t){var n=(()=>{var r=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(r=r||__filename),function(s){s=s||{};function a(){return ce.buffer!=Be&&wt(ce.buffer),ot}function o(){return ce.buffer!=Be&&wt(ce.buffer),qn}function i(){return ce.buffer!=Be&&wt(ce.buffer),$t}function u(){return ce.buffer!=Be&&wt(ce.buffer),dn}function c(){return ce.buffer!=Be&&wt(ce.buffer),Sr}function l(){return ce.buffer!=Be&&wt(ce.buffer),kn}function p(){return ce.buffer!=Be&&wt(ce.buffer),Kn}var d=typeof s<"u"?s:{},h,f;d.ready=new Promise(function(P,j){h=P,f=j});var g;typeof process<"u"&&process.listeners&&(g={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var m=Object.assign({},d),b=[],v="./this.program",y=(P,j)=>{throw j},x=typeof window=="object",k=typeof importScripts=="function",S=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",N=d.ENVIRONMENT_IS_PTHREAD||!1,E="";function $(P){return d.locateFile?d.locateFile(P,E):E+P}var R,D,F,C;function L(P){if(P instanceof Ha)return;J("exiting due to exception: "+P)}if(S){var U=Nx(),H=X1();k?E=H.dirname(E)+"/":E=__dirname+"/",R=(j,ue)=>(j=_u(j)?new URL(j):H.normalize(j),U.readFileSync(j,ue?void 0:"utf8")),F=j=>{var ue=R(j,!0);return ue.buffer||(ue=new Uint8Array(ue)),ue},D=(j,ue,Se)=>{j=_u(j)?new URL(j):H.normalize(j),U.readFile(j,function(Oe,$e){Oe?Se(Oe):ue($e.buffer)})},process.argv.length>1&&(v=process.argv[1].replace(/\\/g,"/")),b=process.argv.slice(2),process.on("uncaughtException",function(j){if(!(j instanceof Ha))throw j}),process.on("unhandledRejection",function(j){throw j}),y=(j,ue)=>{if(Tr())throw process.exitCode=j,ue;L(ue),process.exit(j)},d.inspect=function(){return"[Emscripten Module object]"};let P;try{P=IR()}catch(j){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),j}global.Worker=P.Worker}else(x||k)&&(k?E=self.location.href:typeof document<"u"&&document.currentScript&&(E=document.currentScript.src),typeof r<"u"&&r&&(E=r),E.indexOf("blob:")!==0?E=E.substr(0,E.replace(/[?#].*/,"").lastIndexOf("/")+1):E="",S||(R=P=>{var j=new XMLHttpRequest;return j.open("GET",P,!1),j.send(null),j.responseText},k&&(F=P=>{var j=new XMLHttpRequest;return j.open("GET",P,!1),j.responseType="arraybuffer",j.send(null),new Uint8Array(j.response)}),D=(P,j,ue)=>{var Se=new XMLHttpRequest;Se.open("GET",P,!0),Se.responseType="arraybuffer",Se.onload=()=>{if(Se.status==200||Se.status==0&&Se.response){j(Se.response);return}ue()},Se.onerror=ue,Se.send(null)}),C=P=>document.title=P);S&&typeof performance>"u"&&(global.performance=kR().performance);var K=console.log.bind(console),q=console.warn.bind(console);S&&(K=P=>U.writeSync(1,P+`
`),q=P=>U.writeSync(2,P+`
`));var Z=d.print||K,J=d.printErr||q;Object.assign(d,m),m=null,d.arguments&&(b=d.arguments),d.thisProgram&&(v=d.thisProgram),d.quit&&(y=d.quit);var ee=4,se=Atomics.load,te=Atomics.store,oe=Atomics.compareExchange,ne;d.wasmBinary&&(ne=d.wasmBinary);var le=d.noExitRuntime||!0;typeof WebAssembly!="object"&&Ga("no native wasm support detected");var ce,we,ye=!1,Ce;function Ae(P,j){P||Ga(j)}var qe=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0;function at(P,j,ue){j>>>=0;for(var Se=j+ue,Oe=j;P[Oe]&&!(Oe>=Se);)++Oe;if(Oe-j>16&&P.buffer&&qe)return qe.decode(P.buffer instanceof SharedArrayBuffer?P.slice(j,Oe):P.subarray(j,Oe));for(var $e="";j<Oe;){var me=P[j++];if(!(me&128)){$e+=String.fromCharCode(me);continue}var Ie=P[j++]&63;if((me&224)==192){$e+=String.fromCharCode((me&31)<<6|Ie);continue}var _t=P[j++]&63;if((me&240)==224?me=(me&15)<<12|Ie<<6|_t:me=(me&7)<<18|Ie<<12|_t<<6|P[j++]&63,me<65536)$e+=String.fromCharCode(me);else{var lr=me-65536;$e+=String.fromCharCode(55296|lr>>10,56320|lr&1023)}}return $e}function ht(P,j){return P>>>=0,P?at(o(),P,j):""}function st(P,j,ue,Se){if(ue>>>=0,!(Se>0))return 0;for(var Oe=ue,$e=ue+Se-1,me=0;me<P.length;++me){var Ie=P.charCodeAt(me);if(Ie>=55296&&Ie<=57343){var _t=P.charCodeAt(++me);Ie=65536+((Ie&1023)<<10)|_t&1023}if(Ie<=127){if(ue>=$e)break;j[ue++>>>0]=Ie}else if(Ie<=2047){if(ue+1>=$e)break;j[ue++>>>0]=192|Ie>>6,j[ue++>>>0]=128|Ie&63}else if(Ie<=65535){if(ue+2>=$e)break;j[ue++>>>0]=224|Ie>>12,j[ue++>>>0]=128|Ie>>6&63,j[ue++>>>0]=128|Ie&63}else{if(ue+3>=$e)break;j[ue++>>>0]=240|Ie>>18,j[ue++>>>0]=128|Ie>>12&63,j[ue++>>>0]=128|Ie>>6&63,j[ue++>>>0]=128|Ie&63}}return j[ue>>>0]=0,ue-Oe}function Je(P,j,ue){return st(P,o(),j,ue)}var Be,ot,qn,$t,kr,dn,Sr,kn,Kn;N&&(Be=d.buffer);function wt(P){Be=P,d.HEAP8=ot=new Int8Array(P),d.HEAP16=$t=new Int16Array(P),d.HEAP32=dn=new Int32Array(P),d.HEAPU8=qn=new Uint8Array(P),d.HEAPU16=kr=new Uint16Array(P),d.HEAPU32=Sr=new Uint32Array(P),d.HEAPF32=kn=new Float32Array(P),d.HEAPF64=Kn=new Float64Array(P)}var Pn=d.INITIAL_MEMORY||16777216;if(N)ce=d.wasmMemory,Be=d.buffer;else if(d.wasmMemory)ce=d.wasmMemory;else if(ce=new WebAssembly.Memory({initial:Pn/65536,maximum:65536,shared:!0}),!(ce.buffer instanceof SharedArrayBuffer))throw J("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),S&&J("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");ce&&(Be=ce.buffer),Pn=Be.byteLength,wt(Be);var gn,ns=[],Zs=[],Cr=[],Hl=!1;function Tr(){return le}function Js(){if(d.preRun)for(typeof d.preRun=="function"&&(d.preRun=[d.preRun]);d.preRun.length;)Fg(d.preRun.shift());ql(ns)}function en(){Hl=!0,!N&&ql(Zs)}function oh(){if(!N){if(d.postRun)for(typeof d.postRun=="function"&&(d.postRun=[d.postRun]);d.postRun.length;)Y0(d.postRun.shift());ql(Cr)}}function Fg(P){ns.unshift(P)}function Rg(P){Zs.unshift(P)}function Y0(P){Cr.unshift(P)}var Qs=0,Nu=null,Ss=null;function Pg(P){Qs++,d.monitorRunDependencies&&d.monitorRunDependencies(Qs)}function ih(P){if(Qs--,d.monitorRunDependencies&&d.monitorRunDependencies(Qs),Qs==0&&(Nu!==null&&(clearInterval(Nu),Nu=null),Ss)){var j=Ss;Ss=null,j()}}function Ga(P){d.onAbort&&d.onAbort(P),P="Aborted("+P+")",J(P),ye=!0,Ce=1,P+=". Build with -sASSERTIONS for more info.";var j=new WebAssembly.RuntimeError(P);throw f(j),j}var Og="data:application/octet-stream;base64,";function uh(P){return P.startsWith(Og)}function _u(P){return P.startsWith("file://")}var bn;bn="tfjs-backend-wasm-threaded-simd.wasm",uh(bn)||(bn=$(bn));function ch(P){try{if(P==bn&&ne)return new Uint8Array(ne);if(F)return F(P);throw"both async and sync fetching of the wasm failed"}catch(j){Ga(j)}}function Mg(){if(!ne&&(x||k)){if(typeof fetch=="function"&&!_u(bn))return fetch(bn,{credentials:"same-origin"}).then(function(P){if(!P.ok)throw"failed to load wasm binary file at '"+bn+"'";return P.arrayBuffer()}).catch(function(){return ch(bn)});if(D)return new Promise(function(P,j){D(bn,function(ue){P(new Uint8Array(ue))},j)})}return Promise.resolve().then(function(){return ch(bn)})}function Lg(){var P={env:Ih,wasi_snapshot_preview1:Ih};function j(me,Ie){var _t=me.exports;if(d.asm=_t,qg(d.asm._emscripten_tls_init),gn=d.asm.__indirect_function_table,Rg(d.asm.__wasm_call_ctors),we=Ie,!N){var lr=De.unusedWorkers.length;De.unusedWorkers.forEach(function(Ts){De.loadWasmModuleToWorker(Ts,function(){--lr||ih("wasm-instantiate")})})}}N||Pg("wasm-instantiate");function ue(me){j(me.instance,me.module)}function Se(me){return Mg().then(function(Ie){return WebAssembly.instantiate(Ie,P)}).then(function(Ie){return Ie}).then(me,function(Ie){J("failed to asynchronously prepare wasm: "+Ie),Ga(Ie)})}function Oe(){return!ne&&typeof WebAssembly.instantiateStreaming=="function"&&!uh(bn)&&!_u(bn)&&!S&&typeof fetch=="function"?fetch(bn,{credentials:"same-origin"}).then(function(me){var Ie=WebAssembly.instantiateStreaming(me,P);return Ie.then(ue,function(_t){return J("wasm streaming compile failed: "+_t),J("falling back to ArrayBuffer instantiation"),Se(ue)})}):Se(ue)}if(d.instantiateWasm)try{var $e=d.instantiateWasm(P,j);return $e}catch(me){J("Module.instantiateWasm callback failed with error: "+me),f(me)}return Oe().catch(f),{}}var Z0,J0,lh={};function Ha(P){this.name="ExitStatus",this.message="Program terminated with exit("+P+")",this.status=P}function zg(P){var j=De.pthreads[P];delete De.pthreads[P],j.terminate(),cv(P),De.runningWorkers.splice(De.runningWorkers.indexOf(j),1),j.pthread_ptr=0}function Bg(P){var j=De.pthreads[P];j.postMessage({cmd:"cancel"})}function jl(P){var j=De.pthreads[P];Ae(j),De.returnWorkerToPool(j)}function Wg(P){var j=De.getNewWorker();if(!j)return 6;De.runningWorkers.push(j),De.pthreads[P.pthread_ptr]=j,j.pthread_ptr=P.pthread_ptr;var ue={cmd:"run",start_routine:P.startRoutine,arg:P.arg,pthread_ptr:P.pthread_ptr};return j.runPthread=()=>{S&&j.ref(),j.postMessage(ue,P.transferList),delete j.runPthread},j.loaded&&j.runPthread(),0}var dh={varargs:void 0,get:function(){dh.varargs+=4;var P=u()[dh.varargs-4>>>2];return P},getStr:function(P){var j=ht(P);return j}};function ph(P){if(N)return ea(1,1,P);Ce=P,Tr()||(De.terminateAllThreads(),d.onExit&&d.onExit(P),ye=!0),y(P,new Ha(P))}function Vg(P,j){if(Ce=P,!j&&N)throw fh(P),"unwind";ph(P)}var hh=Vg;function Ug(P){if(P instanceof Ha||P=="unwind")return Ce;y(1,P)}var De={unusedWorkers:[],runningWorkers:[],tlsInitFunctions:[],pthreads:{},init:function(){N?De.initWorker():De.initMainThread()},initMainThread:function(){for(var P=8;P--;)De.allocateUnusedWorker()},initWorker:function(){le=!1},setExitStatus:function(P){Ce=P},terminateAllThreads:function(){for(var P of Object.values(De.pthreads))De.returnWorkerToPool(P);for(var P of De.unusedWorkers)P.terminate();De.unusedWorkers=[]},returnWorkerToPool:function(P){var j=P.pthread_ptr;delete De.pthreads[j],De.unusedWorkers.push(P),De.runningWorkers.splice(De.runningWorkers.indexOf(P),1),P.pthread_ptr=0,S&&P.unref(),cv(j)},receiveObjectTransfer:function(P){},threadInitTLS:function(){De.tlsInitFunctions.forEach(P=>P())},loadWasmModuleToWorker:function(P,j){P.onmessage=$e=>{var me=$e.data,Ie=me.cmd;if(P.pthread_ptr&&(De.currentProxiedOperationCallerThread=P.pthread_ptr),me.targetThread&&me.targetThread!=_h()){var _t=De.pthreads[me.targetThread];_t?_t.postMessage(me,me.transferList):J('Internal error! Worker sent a message "'+Ie+'" to target pthread '+me.targetThread+", but that thread no longer exists!"),De.currentProxiedOperationCallerThread=void 0;return}Ie==="processProxyingQueue"?Kl(me.queue):Ie==="spawnThread"?Wg(me):Ie==="cleanupThread"?jl(me.thread):Ie==="killThread"?zg(me.thread):Ie==="cancelThread"?Bg(me.thread):Ie==="loaded"?(P.loaded=!0,S&&P.unref(),j&&j(P),P.runPthread&&P.runPthread()):Ie==="print"?Z("Thread "+me.threadId+": "+me.text):Ie==="printErr"?J("Thread "+me.threadId+": "+me.text):Ie==="alert"?alert("Thread "+me.threadId+": "+me.text):me.target==="setimmediate"?P.postMessage(me):Ie==="callHandler"?d[me.handler](...me.args):Ie&&J("worker sent an unknown command "+Ie),De.currentProxiedOperationCallerThread=void 0},P.onerror=$e=>{var me="worker sent an error!";throw J(me+" "+$e.filename+":"+$e.lineno+": "+$e.message),$e},S&&(P.on("message",function($e){P.onmessage({data:$e})}),P.on("error",function($e){P.onerror($e)}),P.on("detachedExit",function(){}));var ue=[],Se=["onExit","onAbort","print","printErr"];for(var Oe of Se)d.hasOwnProperty(Oe)&&ue.push(Oe);P.postMessage({cmd:"load",handlers:ue,urlOrBlob:d.mainScriptUrlOrBlob||r,wasmMemory:ce,wasmModule:we})},allocateUnusedWorker:function(){var P,j=$("tfjs-backend-wasm-threaded-simd.worker.js");P=new Worker(j),De.unusedWorkers.push(P)},getNewWorker:function(){return De.unusedWorkers.length==0&&(De.allocateUnusedWorker(),De.loadWasmModuleToWorker(De.unusedWorkers[0])),De.unusedWorkers.pop()}};d.PThread=De;function ql(P){for(;P.length>0;)P.shift()(d)}function Gg(){var P=_h(),j=u()[P+52>>>2],ue=u()[P+56>>>2],Se=j-ue;sS(j,Se),Eh(j)}d.establishStackSpace=Gg;function fh(P){if(N)return ea(2,0,P);try{hh(P)}catch(j){Ug(j)}}var Eu=[];function Hg(P){var j=Eu[P];return j||(P>=Eu.length&&(Eu.length=P+1),Eu[P]=j=gn.get(P)),j}function jg(P,j){var ue=Hg(P)(j);Tr()?De.setExitStatus(ue):rS(ue)}d.invokeEntryPoint=jg;function qg(P){De.tlsInitFunctions.push(P)}function Kg(P){eS(P,!k,1,!x),De.threadInitTLS()}function Xg(P){N?postMessage({cmd:"cleanupThread",thread:P}):jl(P)}function mh(P,j,ue,Se){return N?ea(3,1,P,j,ue,Se):gh(P,j,ue,Se)}function gh(P,j,ue,Se){if(typeof SharedArrayBuffer>"u")return J("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var Oe=[],$e=0;if(N&&(Oe.length===0||$e))return mh(P,j,ue,Se);if($e)return $e;var me={startRoutine:ue,pthread_ptr:P,arg:Se,transferList:Oe};return N?(me.cmd="spawnThread",postMessage(me,Oe),0):Wg(me)}function Yg(){return 65536}var Zg=!0;function Jg(){return Zg}function Kl(P){Atomics.store(u(),P>>2,1),_h()&&nS(P),Atomics.compareExchange(u(),P>>2,1,0)}d.executeNotifiedProxyingQueue=Kl;function Qg(P,j,ue,Se){if(P==j)setTimeout(()=>Kl(Se));else if(N)postMessage({targetThread:P,cmd:"processProxyingQueue",queue:Se});else{var Oe=De.pthreads[P];if(!Oe)return;Oe.postMessage({cmd:"processProxyingQueue",queue:Se})}return 1}function eb(P,j,ue){return-1}function tb(){Ga("")}function ja(P){ja.shown||(ja.shown={}),ja.shown[P]||(ja.shown[P]=1,S&&(P="warning: "+P),J(P))}function nb(){S||k||ja("Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread")}function rb(){return Date.now()}function bh(){return 4294901760}function sb(){return bh()}var Xl;S?Xl=()=>{var P=process.hrtime();return P[0]*1e3+P[1]/1e6}:Xl=()=>performance.timeOrigin+performance.now();function ab(P,j,ue){o().copyWithin(P>>>0,j>>>0,j+ue>>>0)}function ob(){return S?SR().cpus().length:navigator.hardwareConcurrency}function ib(P){var j=lv(),ue=P();return Eh(j),ue}function ea(P,j){var ue=arguments.length-2,Se=arguments;return ib(()=>{for(var Oe=ue,$e=Ah(Oe*8),me=$e>>3,Ie=0;Ie<ue;Ie++){var _t=Se[2+Ie];p()[me+Ie>>>0]=_t}return tS(P,Oe,$e,j)})}var Yl=[];function ub(P,j,ue){Yl.length=j;for(var Se=ue>>3,Oe=0;Oe<j;Oe++)Yl[Oe]=p()[Se+Oe>>>0];var $e=P<0,me=$e?lh[-P-1]:bb[P];return me.apply(null,Yl)}function cb(P){try{return ce.grow(P-Be.byteLength+65535>>>16),wt(ce.buffer),1}catch{}}function lb(P){var j=o().length;if(P=P>>>0,P<=j)return!1;var ue=bh();if(P>ue)return!1;let Se=(_t,lr)=>_t+(lr-_t%lr)%lr;for(var Oe=1;Oe<=4;Oe*=2){var $e=j*(1+.2/Oe);$e=Math.min($e,P+100663296);var me=Math.min(ue,Se(Math.max(P,$e),65536)),Ie=cb(me);if(Ie)return!0}return!1}function db(){throw"unwind"}function yh(P){return N?ea(4,1,P):52}function vh(P,j,ue,Se,Oe){return N?ea(5,1,P,j,ue,Se,Oe):70}var pb=[null,[],[]];function hb(P,j){var ue=pb[P];j===0||j===10?((P===1?Z:J)(at(ue,0)),ue.length=0):ue.push(j)}function xh(P,j,ue,Se){if(N)return ea(6,1,P,j,ue,Se);for(var Oe=0,$e=0;$e<ue;$e++){var me=c()[j>>>2],Ie=c()[j+4>>>2];j+=8;for(var _t=0;_t<Ie;_t++)hb(P,o()[me+_t>>>0]);Oe+=Ie}return c()[Se>>>2]=Oe,0}function wh(P){var j=d["_"+P];return j}function fb(P,j){a().set(P,j>>>0)}function mb(P,j,ue,Se,Oe){var $e={string:Xn=>{var Fu=0;if(Xn!=null&&Xn!==0){var iS=(Xn.length<<2)+1;Fu=Ah(iS),Je(Xn,Fu,iS)}return Fu},array:Xn=>{var Fu=Ah(Xn.length);return fb(Xn,Fu),Fu}};function me(Xn){return j==="string"?ht(Xn):j==="boolean"?!!Xn:Xn}var Ie=wh(P),_t=[],lr=0;if(Se)for(var Ts=0;Ts<Se.length;Ts++){var oS=$e[ue[Ts]];oS?(lr===0&&(lr=lv()),_t[Ts]=oS(Se[Ts])):_t[Ts]=Se[Ts]}var dv=Ie.apply(null,_t);function QF(Xn){return lr!==0&&Eh(lr),me(Xn)}return dv=QF(dv),dv}function gb(P,j,ue,Se){ue=ue||[];var Oe=ue.every(me=>me==="number"||me==="boolean"),$e=j!=="string";return $e&&Oe&&!Se?wh(P):function(){return mb(P,j,ue,arguments,Se)}}De.init();var bb=[null,ph,fh,mh,yh,vh,xh],Ih={__emscripten_init_main_thread_js:Kg,__emscripten_thread_cleanup:Xg,__pthread_create_js:gh,_emscripten_default_pthread_stack_size:Yg,_emscripten_get_now_is_monotonic:Jg,_emscripten_notify_task_queue:Qg,_emscripten_set_offscreencanvas_size:eb,abort:tb,emscripten_check_blocking_allowed:nb,emscripten_date_now:rb,emscripten_get_heap_max:sb,emscripten_get_now:Xl,emscripten_memcpy_big:ab,emscripten_num_logical_cores:ob,emscripten_receive_on_main_thread_js:ub,emscripten_resize_heap:lb,emscripten_unwind_to_js_event_loop:db,exit:hh,fd_close:yh,fd_seek:vh,fd_write:xh,memory:ce||d.wasmMemory},Q0=Lg(),yb=d.___wasm_call_ctors=function(){return(yb=d.___wasm_call_ctors=d.asm.__wasm_call_ctors).apply(null,arguments)},vb=d._init=function(){return(vb=d._init=d.asm.init).apply(null,arguments)},xb=d._init_with_threads_count=function(){return(xb=d._init_with_threads_count=d.asm.init_with_threads_count).apply(null,arguments)},wb=d._get_threads_count=function(){return(wb=d._get_threads_count=d.asm.get_threads_count).apply(null,arguments)},Ib=d._register_tensor=function(){return(Ib=d._register_tensor=d.asm.register_tensor).apply(null,arguments)},kb=d._dispose_data=function(){return(kb=d._dispose_data=d.asm.dispose_data).apply(null,arguments)},Sb=d._dispose=function(){return(Sb=d._dispose=d.asm.dispose).apply(null,arguments)},Cb=d._Abs=function(){return(Cb=d._Abs=d.asm.Abs).apply(null,arguments)},Tb=d._Acos=function(){return(Tb=d._Acos=d.asm.Acos).apply(null,arguments)},Nb=d._Acosh=function(){return(Nb=d._Acosh=d.asm.Acosh).apply(null,arguments)},_b=d._Add=function(){return(_b=d._Add=d.asm.Add).apply(null,arguments)},Eb=d._AddN=function(){return(Eb=d._AddN=d.asm.AddN).apply(null,arguments)},Ab=d._All=function(){return(Ab=d._All=d.asm.All).apply(null,arguments)},Db=d._Any=function(){return(Db=d._Any=d.asm.Any).apply(null,arguments)},$b=d._ArgMax=function(){return($b=d._ArgMax=d.asm.ArgMax).apply(null,arguments)},Fb=d._ArgMin=function(){return(Fb=d._ArgMin=d.asm.ArgMin).apply(null,arguments)},Rb=d._Asin=function(){return(Rb=d._Asin=d.asm.Asin).apply(null,arguments)},Pb=d._Asinh=function(){return(Pb=d._Asinh=d.asm.Asinh).apply(null,arguments)},Ob=d._Atan=function(){return(Ob=d._Atan=d.asm.Atan).apply(null,arguments)},Mb=d._Atan2=function(){return(Mb=d._Atan2=d.asm.Atan2).apply(null,arguments)},Lb=d._Atanh=function(){return(Lb=d._Atanh=d.asm.Atanh).apply(null,arguments)},zb=d._AvgPool=function(){return(zb=d._AvgPool=d.asm.AvgPool).apply(null,arguments)},Bb=d._AvgPool3D=function(){return(Bb=d._AvgPool3D=d.asm.AvgPool3D).apply(null,arguments)},Wb=d._AvgPool3DGrad=function(){return(Wb=d._AvgPool3DGrad=d.asm.AvgPool3DGrad).apply(null,arguments)},Vb=d._AvgPoolGrad=function(){return(Vb=d._AvgPoolGrad=d.asm.AvgPoolGrad).apply(null,arguments)},Ub=d._BatchMatMul=function(){return(Ub=d._BatchMatMul=d.asm.BatchMatMul).apply(null,arguments)},Gb=d._Bincount=function(){return(Gb=d._Bincount=d.asm.Bincount).apply(null,arguments)},Hb=d._BitwiseAnd=function(){return(Hb=d._BitwiseAnd=d.asm.BitwiseAnd).apply(null,arguments)},jb=d._Ceil=function(){return(jb=d._Ceil=d.asm.Ceil).apply(null,arguments)},qb=d._ClipByValue=function(){return(qb=d._ClipByValue=d.asm.ClipByValue).apply(null,arguments)},Kb=d._Conv2D=function(){return(Kb=d._Conv2D=d.asm.Conv2D).apply(null,arguments)},Xb=d._Conv2DBackpropInput=function(){return(Xb=d._Conv2DBackpropInput=d.asm.Conv2DBackpropInput).apply(null,arguments)},Yb=d._Conv3D=function(){return(Yb=d._Conv3D=d.asm.Conv3D).apply(null,arguments)},Zb=d._Conv3DBackpropFilterV2=function(){return(Zb=d._Conv3DBackpropFilterV2=d.asm.Conv3DBackpropFilterV2).apply(null,arguments)},Jb=d._Conv3DBackpropInputV2=function(){return(Jb=d._Conv3DBackpropInputV2=d.asm.Conv3DBackpropInputV2).apply(null,arguments)},Qb=d._Cos=function(){return(Qb=d._Cos=d.asm.Cos).apply(null,arguments)},ey=d._Cosh=function(){return(ey=d._Cosh=d.asm.Cosh).apply(null,arguments)},ty=d._CropAndResize=function(){return(ty=d._CropAndResize=d.asm.CropAndResize).apply(null,arguments)},ny=d._Cumprod=function(){return(ny=d._Cumprod=d.asm.Cumprod).apply(null,arguments)},ry=d._Cumsum=function(){return(ry=d._Cumsum=d.asm.Cumsum).apply(null,arguments)},sy=d._DenseBincount=function(){return(sy=d._DenseBincount=d.asm.DenseBincount).apply(null,arguments)},ay=d._DepthToSpace=function(){return(ay=d._DepthToSpace=d.asm.DepthToSpace).apply(null,arguments)},oy=d._DepthwiseConv2dNative=function(){return(oy=d._DepthwiseConv2dNative=d.asm.DepthwiseConv2dNative).apply(null,arguments)},iy=d._Diag=function(){return(iy=d._Diag=d.asm.Diag).apply(null,arguments)},uy=d._Dilation2D=function(){return(uy=d._Dilation2D=d.asm.Dilation2D).apply(null,arguments)},cy=d._Dilation2DBackpropFilter=function(){return(cy=d._Dilation2DBackpropFilter=d.asm.Dilation2DBackpropFilter).apply(null,arguments)},ly=d._Dilation2DBackpropInput=function(){return(ly=d._Dilation2DBackpropInput=d.asm.Dilation2DBackpropInput).apply(null,arguments)},dy=d._Elu=function(){return(dy=d._Elu=d.asm.Elu).apply(null,arguments)},py=d._EluGrad=function(){return(py=d._EluGrad=d.asm.EluGrad).apply(null,arguments)},hy=d._Equal=function(){return(hy=d._Equal=d.asm.Equal).apply(null,arguments)},fy=d._Erf=function(){return(fy=d._Erf=d.asm.Erf).apply(null,arguments)},my=d._Exp=function(){return(my=d._Exp=d.asm.Exp).apply(null,arguments)},gy=d._Expm1=function(){return(gy=d._Expm1=d.asm.Expm1).apply(null,arguments)},by=d._FlipLeftRight=function(){return(by=d._FlipLeftRight=d.asm.FlipLeftRight).apply(null,arguments)},yy=d._Floor=function(){return(yy=d._Floor=d.asm.Floor).apply(null,arguments)},vy=d._FloorDiv=function(){return(vy=d._FloorDiv=d.asm.FloorDiv).apply(null,arguments)},xy=d._FusedBatchNorm=function(){return(xy=d._FusedBatchNorm=d.asm.FusedBatchNorm).apply(null,arguments)},wy=d._FusedConv2D=function(){return(wy=d._FusedConv2D=d.asm.FusedConv2D).apply(null,arguments)},Iy=d._FusedDepthwiseConv2D=function(){return(Iy=d._FusedDepthwiseConv2D=d.asm.FusedDepthwiseConv2D).apply(null,arguments)},ky=d._Gather=function(){return(ky=d._Gather=d.asm.Gather).apply(null,arguments)},Sy=d._GatherNd=function(){return(Sy=d._GatherNd=d.asm.GatherNd).apply(null,arguments)},Cy=d._Greater=function(){return(Cy=d._Greater=d.asm.Greater).apply(null,arguments)},Ty=d._GreaterEqual=function(){return(Ty=d._GreaterEqual=d.asm.GreaterEqual).apply(null,arguments)},Ny=d._IsFinite=function(){return(Ny=d._IsFinite=d.asm.IsFinite).apply(null,arguments)},_y=d._IsInf=function(){return(_y=d._IsInf=d.asm.IsInf).apply(null,arguments)},Ey=d._IsNan=function(){return(Ey=d._IsNan=d.asm.IsNan).apply(null,arguments)},Ay=d._LRN=function(){return(Ay=d._LRN=d.asm.LRN).apply(null,arguments)},Dy=d._LRNGrad=function(){return(Dy=d._LRNGrad=d.asm.LRNGrad).apply(null,arguments)},$y=d._LeakyRelu=function(){return($y=d._LeakyRelu=d.asm.LeakyRelu).apply(null,arguments)},Fy=d._Less=function(){return(Fy=d._Less=d.asm.Less).apply(null,arguments)},Ry=d._LessEqual=function(){return(Ry=d._LessEqual=d.asm.LessEqual).apply(null,arguments)},Py=d._LinSpace=function(){return(Py=d._LinSpace=d.asm.LinSpace).apply(null,arguments)},Oy=d._Log=function(){return(Oy=d._Log=d.asm.Log).apply(null,arguments)},My=d._Log1p=function(){return(My=d._Log1p=d.asm.Log1p).apply(null,arguments)},Ly=d._LogicalAnd=function(){return(Ly=d._LogicalAnd=d.asm.LogicalAnd).apply(null,arguments)},zy=d._LogicalNot=function(){return(zy=d._LogicalNot=d.asm.LogicalNot).apply(null,arguments)},By=d._LogicalOr=function(){return(By=d._LogicalOr=d.asm.LogicalOr).apply(null,arguments)},Wy=d._LogicalXor=function(){return(Wy=d._LogicalXor=d.asm.LogicalXor).apply(null,arguments)},Vy=d._Max=function(){return(Vy=d._Max=d.asm.Max).apply(null,arguments)},Uy=d._MaxPool=function(){return(Uy=d._MaxPool=d.asm.MaxPool).apply(null,arguments)},Gy=d._MaxPool3D=function(){return(Gy=d._MaxPool3D=d.asm.MaxPool3D).apply(null,arguments)},Hy=d._MaxPool3DGrad=function(){return(Hy=d._MaxPool3DGrad=d.asm.MaxPool3DGrad).apply(null,arguments)},jy=d._MaxPoolGrad=function(){return(jy=d._MaxPoolGrad=d.asm.MaxPoolGrad).apply(null,arguments)},qy=d._MaxPoolWithArgmax=function(){return(qy=d._MaxPoolWithArgmax=d.asm.MaxPoolWithArgmax).apply(null,arguments)},Ky=d._Maximum=function(){return(Ky=d._Maximum=d.asm.Maximum).apply(null,arguments)},Xy=d._Mean=function(){return(Xy=d._Mean=d.asm.Mean).apply(null,arguments)},Yy=d._Min=function(){return(Yy=d._Min=d.asm.Min).apply(null,arguments)},Zy=d._Minimum=function(){return(Zy=d._Minimum=d.asm.Minimum).apply(null,arguments)},Jy=d._MirrorPad=function(){return(Jy=d._MirrorPad=d.asm.MirrorPad).apply(null,arguments)},Qy=d._Mod=function(){return(Qy=d._Mod=d.asm.Mod).apply(null,arguments)},ev=d._Multinomial=function(){return(ev=d._Multinomial=d.asm.Multinomial).apply(null,arguments)},tv=d._Multiply=function(){return(tv=d._Multiply=d.asm.Multiply).apply(null,arguments)},nv=d._Neg=function(){return(nv=d._Neg=d.asm.Neg).apply(null,arguments)},rv=d._NonMaxSuppressionV3=function(){return(rv=d._NonMaxSuppressionV3=d.asm.NonMaxSuppressionV3).apply(null,arguments)},sv=d._NonMaxSuppressionV4=function(){return(sv=d._NonMaxSuppressionV4=d.asm.NonMaxSuppressionV4).apply(null,arguments)},kh=d._NonMaxSuppressionV5=function(){return(kh=d._NonMaxSuppressionV5=d.asm.NonMaxSuppressionV5).apply(null,arguments)},Sh=d._NotEqual=function(){return(Sh=d._NotEqual=d.asm.NotEqual).apply(null,arguments)},Zl=d._OneHot=function(){return(Zl=d._OneHot=d.asm.OneHot).apply(null,arguments)},av=d._PadV2=function(){return(av=d._PadV2=d.asm.PadV2).apply(null,arguments)},ov=d._Pow=function(){return(ov=d._Pow=d.asm.Pow).apply(null,arguments)},Au=d._Prelu=function(){return(Au=d._Prelu=d.asm.Prelu).apply(null,arguments)},Ch=d._Prod=function(){return(Ch=d._Prod=d.asm.Prod).apply(null,arguments)},Du=d._RealDiv=function(){return(Du=d._RealDiv=d.asm.RealDiv).apply(null,arguments)},$u=d._Reciprocal=function(){return($u=d._Reciprocal=d.asm.Reciprocal).apply(null,arguments)},iv=d._Relu=function(){return(iv=d._Relu=d.asm.Relu).apply(null,arguments)},Y=d._Relu6=function(){return(Y=d._Relu6=d.asm.Relu6).apply(null,arguments)},ie=d._ResizeBilinear=function(){return(ie=d._ResizeBilinear=d.asm.ResizeBilinear).apply(null,arguments)},ke=d._ResizeBilinearGrad=function(){return(ke=d._ResizeBilinearGrad=d.asm.ResizeBilinearGrad).apply(null,arguments)},Ye=d._ResizeNearestNeighbor=function(){return(Ye=d._ResizeNearestNeighbor=d.asm.ResizeNearestNeighbor).apply(null,arguments)},kt=d._ResizeNearestNeighborGrad=function(){return(kt=d._ResizeNearestNeighborGrad=d.asm.ResizeNearestNeighborGrad).apply(null,arguments)},St=d._Reverse=function(){return(St=d._Reverse=d.asm.Reverse).apply(null,arguments)},Ge=d._RotateWithOffset=function(){return(Ge=d._RotateWithOffset=d.asm.RotateWithOffset).apply(null,arguments)},Ve=d._Round=function(){return(Ve=d._Round=d.asm.Round).apply(null,arguments)},zt=d._Rsqrt=function(){return(zt=d._Rsqrt=d.asm.Rsqrt).apply(null,arguments)},cr=d._ScatterNd=function(){return(cr=d._ScatterNd=d.asm.ScatterNd).apply(null,arguments)},Cs=d._SearchSorted=function(){return(Cs=d._SearchSorted=d.asm.SearchSorted).apply(null,arguments)},Th=d._SelectV2=function(){return(Th=d._SelectV2=d.asm.SelectV2).apply(null,arguments)},Jl=d._Selu=function(){return(Jl=d._Selu=d.asm.Selu).apply(null,arguments)},uv=d._Sigmoid=function(){return(uv=d._Sigmoid=d.asm.Sigmoid).apply(null,arguments)},Sn=d._Sign=function(){return(Sn=d._Sign=d.asm.Sign).apply(null,arguments)},ta=d._Sin=function(){return(ta=d._Sin=d.asm.Sin).apply(null,arguments)},Nh=d._Sinh=function(){return(Nh=d._Sinh=d.asm.Sinh).apply(null,arguments)},wF=d._Softmax=function(){return(wF=d._Softmax=d.asm.Softmax).apply(null,arguments)},IF=d._Softplus=function(){return(IF=d._Softplus=d.asm.Softplus).apply(null,arguments)},kF=d._SparseFillEmptyRows=function(){return(kF=d._SparseFillEmptyRows=d.asm.SparseFillEmptyRows).apply(null,arguments)},SF=d._SparseReshape=function(){return(SF=d._SparseReshape=d.asm.SparseReshape).apply(null,arguments)},CF=d._SparseSegmentReduction=function(){return(CF=d._SparseSegmentReduction=d.asm.SparseSegmentReduction).apply(null,arguments)},TF=d._SparseToDense=function(){return(TF=d._SparseToDense=d.asm.SparseToDense).apply(null,arguments)},NF=d._Sqrt=function(){return(NF=d._Sqrt=d.asm.Sqrt).apply(null,arguments)},_F=d._Square=function(){return(_F=d._Square=d.asm.Square).apply(null,arguments)},EF=d._SquaredDifference=function(){return(EF=d._SquaredDifference=d.asm.SquaredDifference).apply(null,arguments)},AF=d._Step=function(){return(AF=d._Step=d.asm.Step).apply(null,arguments)},DF=d._StridedSlice=function(){return(DF=d._StridedSlice=d.asm.StridedSlice).apply(null,arguments)},$F=d._Sub=function(){return($F=d._Sub=d.asm.Sub).apply(null,arguments)},FF=d._Sum=function(){return(FF=d._Sum=d.asm.Sum).apply(null,arguments)},RF=d._Tan=function(){return(RF=d._Tan=d.asm.Tan).apply(null,arguments)},PF=d._Tanh=function(){return(PF=d._Tanh=d.asm.Tanh).apply(null,arguments)},OF=d._TensorScatterUpdate=function(){return(OF=d._TensorScatterUpdate=d.asm.TensorScatterUpdate).apply(null,arguments)},MF=d._Tile=function(){return(MF=d._Tile=d.asm.Tile).apply(null,arguments)},LF=d._TopK=function(){return(LF=d._TopK=d.asm.TopK).apply(null,arguments)},zF=d._Transform=function(){return(zF=d._Transform=d.asm.Transform).apply(null,arguments)},BF=d._Transpose=function(){return(BF=d._Transpose=d.asm.Transpose).apply(null,arguments)},WF=d.__FusedMatMul=function(){return(WF=d.__FusedMatMul=d.asm._FusedMatMul).apply(null,arguments)},VF=d._malloc=function(){return(VF=d._malloc=d.asm.malloc).apply(null,arguments)},UF=d._free=function(){return(UF=d._free=d.asm.free).apply(null,arguments)},GF=d.__emscripten_tls_init=function(){return(GF=d.__emscripten_tls_init=d.asm._emscripten_tls_init).apply(null,arguments)},_h=d._pthread_self=function(){return(_h=d._pthread_self=d.asm.pthread_self).apply(null,arguments)},HF=d.___errno_location=function(){return(HF=d.___errno_location=d.asm.__errno_location).apply(null,arguments)},eS=d.__emscripten_thread_init=function(){return(eS=d.__emscripten_thread_init=d.asm._emscripten_thread_init).apply(null,arguments)},jF=d.__emscripten_thread_crashed=function(){return(jF=d.__emscripten_thread_crashed=d.asm._emscripten_thread_crashed).apply(null,arguments)},qF=d._emscripten_main_thread_process_queued_calls=function(){return(qF=d._emscripten_main_thread_process_queued_calls=d.asm.emscripten_main_thread_process_queued_calls).apply(null,arguments)},KF=d._emscripten_main_browser_thread_id=function(){return(KF=d._emscripten_main_browser_thread_id=d.asm.emscripten_main_browser_thread_id).apply(null,arguments)},tS=d._emscripten_run_in_main_runtime_thread_js=function(){return(tS=d._emscripten_run_in_main_runtime_thread_js=d.asm.emscripten_run_in_main_runtime_thread_js).apply(null,arguments)},XF=d._emscripten_dispatch_to_thread_=function(){return(XF=d._emscripten_dispatch_to_thread_=d.asm.emscripten_dispatch_to_thread_).apply(null,arguments)},nS=d.__emscripten_proxy_execute_task_queue=function(){return(nS=d.__emscripten_proxy_execute_task_queue=d.asm._emscripten_proxy_execute_task_queue).apply(null,arguments)},cv=d.__emscripten_thread_free_data=function(){return(cv=d.__emscripten_thread_free_data=d.asm._emscripten_thread_free_data).apply(null,arguments)},rS=d.__emscripten_thread_exit=function(){return(rS=d.__emscripten_thread_exit=d.asm._emscripten_thread_exit).apply(null,arguments)},sS=d._emscripten_stack_set_limits=function(){return(sS=d._emscripten_stack_set_limits=d.asm.emscripten_stack_set_limits).apply(null,arguments)},lv=d.stackSave=function(){return(lv=d.stackSave=d.asm.stackSave).apply(null,arguments)},Eh=d.stackRestore=function(){return(Eh=d.stackRestore=d.asm.stackRestore).apply(null,arguments)},Ah=d.stackAlloc=function(){return(Ah=d.stackAlloc=d.asm.stackAlloc).apply(null,arguments)},YF=d.dynCall_iijjiiii=function(){return(YF=d.dynCall_iijjiiii=d.asm.dynCall_iijjiiii).apply(null,arguments)},ZF=d.dynCall_jiji=function(){return(ZF=d.dynCall_jiji=d.asm.dynCall_jiji).apply(null,arguments)};d.keepRuntimeAlive=Tr,d.wasmMemory=ce,d.cwrap=gb,d.ExitStatus=Ha,d.PThread=De;var Dh;Ss=function P(){Dh||aS(),Dh||(Ss=P)};function aS(P){if(P=P||b,Qs>0)return;if(N){h(d),en(),startWorker(d);return}if(Js(),Qs>0)return;function j(){Dh||(Dh=!0,d.calledRun=!0,!ye&&(en(),h(d),d.onRuntimeInitialized&&d.onRuntimeInitialized(),oh()))}d.setStatus?(d.setStatus("Running..."),setTimeout(function(){setTimeout(function(){d.setStatus("")},1),j()},1)):j()}if(d.preInit)for(typeof d.preInit=="function"&&(d.preInit=[d.preInit]);d.preInit.length>0;)d.preInit.pop()();aS();var $h;g&&($h={uncaughtException:process.listeners("uncaughtException").filter(function(P){return!g.uncaughtException.indexOf(P)>-1}),unhandledRejection:process.listeners("unhandledRejection").filter(function(P){return!g.unhandledRejection.indexOf(P)>-1})});var Fh;if(typeof WasmBackendModule<"u")Fh=WasmBackendModule;else if(typeof s<"u")Fh=s;else throw new Error("Could not find wasm module in post.js");if($h){var JF=Fh._dispose;Fh._dispose=function(){JF(),$h.uncaughtException.forEach(function(P){process.removeListener("uncaughtException",P)}),$h.unhandledRejection.forEach(function(P){process.removeListener("unhandledRejection",P)})}}return s.ready}})();typeof e=="object"&&typeof t=="object"?t.exports=n:typeof define=="function"&&define.amd?define([],function(){return n}):typeof e=="object"&&(e.WasmBackendModuleThreadedSimd=n)}}),TR=Gt({"node_modules/@tensorflow/tfjs-backend-wasm/wasm-out/tfjs-backend-wasm-threaded-simd.worker.js"(e,t){t.exports.wasmWorkerContents=`"use strict";var Module={};var ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads");var parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",data=>onmessage({data:data}));var fs=require("fs");Object.assign(global,{self:global,require:require,Module:Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:function(f){(0,eval)(fs.readFileSync(f,"utf8")+"//# sourceURL="+f)},postMessage:function(msg){parentPort.postMessage(msg)},performance:global.performance||{now:function(){return Date.now()}}})}var initializedJS=false;var pendingNotifiedProxyingQueues=[];function threadPrintErr(){var text=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,text+"
");return}console.error(text)}function threadAlert(){var text=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:text,threadId:Module["_pthread_self"]()})}var err=threadPrintErr;self.alert=threadAlert;Module["instantiateWasm"]=(info,receiveInstance)=>{var instance=new WebAssembly.Instance(Module["wasmModule"],info);receiveInstance(instance);Module["wasmModule"]=null;return instance.exports};self.onunhandledrejection=e=>{throw e.reason??e};self.startWorker=instance=>{Module=instance;postMessage({"cmd":"loaded"})};self.onmessage=e=>{try{if(e.data.cmd==="load"){Module["wasmModule"]=e.data.wasmModule;for(const handler of e.data.handlers){Module[handler]=function(){postMessage({cmd:"callHandler",handler:handler,args:[...arguments]})}}Module["wasmMemory"]=e.data.wasmMemory;Module["buffer"]=Module["wasmMemory"].buffer;Module["ENVIRONMENT_IS_PTHREAD"]=true;if(typeof e.data.urlOrBlob=="string"){importScripts(e.data.urlOrBlob)}else{var objectUrl=URL.createObjectURL(e.data.urlOrBlob);importScripts(objectUrl);URL.revokeObjectURL(objectUrl)}WasmBackendModuleThreadedSimd(Module)}else if(e.data.cmd==="run"){Module["__emscripten_thread_init"](e.data.pthread_ptr,0,0,1);Module["establishStackSpace"]();Module["PThread"].receiveObjectTransfer(e.data);Module["PThread"].threadInitTLS();if(!initializedJS){pendingNotifiedProxyingQueues.forEach(queue=>{Module["executeNotifiedProxyingQueue"](queue)});pendingNotifiedProxyingQueues=[];initializedJS=true}try{Module["invokeEntryPoint"](e.data.start_routine,e.data.arg)}catch(ex){if(ex!="unwind"){if(ex instanceof Module["ExitStatus"]){if(Module["keepRuntimeAlive"]()){}else{Module["__emscripten_thread_exit"](ex.status)}}else{throw ex}}}}else if(e.data.cmd==="cancel"){if(Module["_pthread_self"]()){Module["__emscripten_thread_exit"](-1)}}else if(e.data.target==="setimmediate"){}else if(e.data.cmd==="processProxyingQueue"){if(initializedJS){Module["executeNotifiedProxyingQueue"](e.data.queue)}else{pendingNotifiedProxyingQueues.push(e.data.queue)}}else if(e.data.cmd){err("worker.js received unknown command "+e.data.cmd);err(e.data)}}catch(ex){if(Module["__emscripten_thread_crashed"]){Module["__emscripten_thread_crashed"]()}throw ex}};`}}),NR=Gt({"node_modules/@tensorflow/tfjs-backend-wasm/wasm-out/tfjs-backend-wasm.js"(e,t){var n=(()=>{var r=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(r=r||__filename),function(s){s=s||{};var a=typeof s<"u"?s:{},o,i;a.ready=new Promise(function(Y,ie){o=Y,i=ie});var u;typeof process<"u"&&process.listeners&&(u={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var c=Object.assign({},a),l=[],p="./this.program",d=(Y,ie)=>{throw ie},h=typeof window=="object",f=typeof importScripts=="function",g=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",m="";function b(Y){return a.locateFile?a.locateFile(Y,m):m+Y}var v,y,x,k;function S(Y){if(Y instanceof Nu)return;R("exiting due to exception: "+Y)}if(g){var N=Nx(),E=X1();f?m=E.dirname(m)+"/":m=__dirname+"/",v=(Y,ie)=>(Y=Js(Y)?new URL(Y):E.normalize(Y),N.readFileSync(Y,ie?void 0:"utf8")),x=Y=>{var ie=v(Y,!0);return ie.buffer||(ie=new Uint8Array(ie)),ie},y=(Y,ie,ke)=>{Y=Js(Y)?new URL(Y):E.normalize(Y),N.readFile(Y,function(Ye,kt){Ye?ke(Ye):ie(kt.buffer)})},process.argv.length>1&&(p=process.argv[1].replace(/\\/g,"/")),l=process.argv.slice(2),process.on("uncaughtException",function(Y){if(!(Y instanceof Nu))throw Y}),process.on("unhandledRejection",function(Y){throw Y}),d=(Y,ie)=>{if(qn())throw process.exitCode=Y,ie;S(ie),process.exit(Y)},a.inspect=function(){return"[Emscripten Module object]"}}else(h||f)&&(f?m=self.location.href:typeof document<"u"&&document.currentScript&&(m=document.currentScript.src),r&&(m=r),m.indexOf("blob:")!==0?m=m.substr(0,m.replace(/[?#].*/,"").lastIndexOf("/")+1):m="",v=Y=>{var ie=new XMLHttpRequest;return ie.open("GET",Y,!1),ie.send(null),ie.responseText},f&&(x=Y=>{var ie=new XMLHttpRequest;return ie.open("GET",Y,!1),ie.responseType="arraybuffer",ie.send(null),new Uint8Array(ie.response)}),y=(Y,ie,ke)=>{var Ye=new XMLHttpRequest;Ye.open("GET",Y,!0),Ye.responseType="arraybuffer",Ye.onload=()=>{if(Ye.status==200||Ye.status==0&&Ye.response){ie(Ye.response);return}ke()},Ye.onerror=ke,Ye.send(null)},k=Y=>document.title=Y);var $=a.print||console.log.bind(console),R=a.printErr||console.warn.bind(console);Object.assign(a,c),c=null,a.arguments&&(l=a.arguments),a.thisProgram&&(p=a.thisProgram),a.quit&&(d=a.quit);var D=4,F;a.wasmBinary&&(F=a.wasmBinary);var C=a.noExitRuntime||!0;typeof WebAssembly!="object"&&Cr("no native wasm support detected");var L,U=!1,H;function K(Y,ie){Y||Cr(ie)}var q=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0;function Z(Y,ie,ke){ie>>>=0;for(var Ye=ie+ke,kt=ie;Y[kt]&&!(kt>=Ye);)++kt;if(kt-ie>16&&Y.buffer&&q)return q.decode(Y.subarray(ie,kt));for(var St="";ie<kt;){var Ge=Y[ie++];if(!(Ge&128)){St+=String.fromCharCode(Ge);continue}var Ve=Y[ie++]&63;if((Ge&224)==192){St+=String.fromCharCode((Ge&31)<<6|Ve);continue}var zt=Y[ie++]&63;if((Ge&240)==224?Ge=(Ge&15)<<12|Ve<<6|zt:Ge=(Ge&7)<<18|Ve<<12|zt<<6|Y[ie++]&63,Ge<65536)St+=String.fromCharCode(Ge);else{var cr=Ge-65536;St+=String.fromCharCode(55296|cr>>10,56320|cr&1023)}}return St}function J(Y,ie){return Y>>>=0,Y?Z(ne,Y,ie):""}function ee(Y,ie,ke,Ye){if(ke>>>=0,!(Ye>0))return 0;for(var kt=ke,St=ke+Ye-1,Ge=0;Ge<Y.length;++Ge){var Ve=Y.charCodeAt(Ge);if(Ve>=55296&&Ve<=57343){var zt=Y.charCodeAt(++Ge);Ve=65536+((Ve&1023)<<10)|zt&1023}if(Ve<=127){if(ke>=St)break;ie[ke++>>>0]=Ve}else if(Ve<=2047){if(ke+1>=St)break;ie[ke++>>>0]=192|Ve>>6,ie[ke++>>>0]=128|Ve&63}else if(Ve<=65535){if(ke+2>=St)break;ie[ke++>>>0]=224|Ve>>12,ie[ke++>>>0]=128|Ve>>6&63,ie[ke++>>>0]=128|Ve&63}else{if(ke+3>=St)break;ie[ke++>>>0]=240|Ve>>18,ie[ke++>>>0]=128|Ve>>12&63,ie[ke++>>>0]=128|Ve>>6&63,ie[ke++>>>0]=128|Ve&63}}return ie[ke>>>0]=0,ke-kt}function se(Y,ie,ke){return ee(Y,ne,ie,ke)}var te,oe,ne,le,ce,we,ye,Ce,Ae;function qe(Y){te=Y,a.HEAP8=oe=new Int8Array(Y),a.HEAP16=le=new Int16Array(Y),a.HEAP32=we=new Int32Array(Y),a.HEAPU8=ne=new Uint8Array(Y),a.HEAPU16=ce=new Uint16Array(Y),a.HEAPU32=ye=new Uint32Array(Y),a.HEAPF32=Ce=new Float32Array(Y),a.HEAPF64=Ae=new Float64Array(Y)}var at=a.INITIAL_MEMORY||16777216,ht,st=[],Je=[],Be=[],ot=!1;function qn(){return C}function $t(){if(a.preRun)for(typeof a.preRun=="function"&&(a.preRun=[a.preRun]);a.preRun.length;)Sr(a.preRun.shift());Ss(st)}function kr(){ot=!0,Ss(Je)}function dn(){if(a.postRun)for(typeof a.postRun=="function"&&(a.postRun=[a.postRun]);a.postRun.length;)Kn(a.postRun.shift());Ss(Be)}function Sr(Y){st.unshift(Y)}function kn(Y){Je.unshift(Y)}function Kn(Y){Be.unshift(Y)}var wt=0,Pn=null,gn=null;function ns(Y){wt++,a.monitorRunDependencies&&a.monitorRunDependencies(wt)}function Zs(Y){if(wt--,a.monitorRunDependencies&&a.monitorRunDependencies(wt),wt==0&&(Pn!==null&&(clearInterval(Pn),Pn=null),gn)){var ie=gn;gn=null,ie()}}function Cr(Y){a.onAbort&&a.onAbort(Y),Y="Aborted("+Y+")",R(Y),U=!0,H=1,Y+=". Build with -sASSERTIONS for more info.";var ie=new WebAssembly.RuntimeError(Y);throw i(ie),ie}var Hl="data:application/octet-stream;base64,";function Tr(Y){return Y.startsWith(Hl)}function Js(Y){return Y.startsWith("file://")}var en;en="tfjs-backend-wasm.wasm",Tr(en)||(en=b(en));function oh(Y){try{if(Y==en&&F)return new Uint8Array(F);if(x)return x(Y);throw"both async and sync fetching of the wasm failed"}catch(ie){Cr(ie)}}function Fg(){if(!F&&(h||f)){if(typeof fetch=="function"&&!Js(en))return fetch(en,{credentials:"same-origin"}).then(function(Y){if(!Y.ok)throw"failed to load wasm binary file at '"+en+"'";return Y.arrayBuffer()}).catch(function(){return oh(en)});if(y)return new Promise(function(Y,ie){y(en,function(ke){Y(new Uint8Array(ke))},ie)})}return Promise.resolve().then(function(){return oh(en)})}function Rg(){var Y={env:jl,wasi_snapshot_preview1:jl};function ie(Ge,Ve){var zt=Ge.exports;a.asm=zt,L=a.asm.memory,qe(L.buffer),ht=a.asm.__indirect_function_table,kn(a.asm.__wasm_call_ctors),Zs("wasm-instantiate")}ns("wasm-instantiate");function ke(Ge){ie(Ge.instance)}function Ye(Ge){return Fg().then(function(Ve){return WebAssembly.instantiate(Ve,Y)}).then(function(Ve){return Ve}).then(Ge,function(Ve){R("failed to asynchronously prepare wasm: "+Ve),Cr(Ve)})}function kt(){return!F&&typeof WebAssembly.instantiateStreaming=="function"&&!Tr(en)&&!Js(en)&&!g&&typeof fetch=="function"?fetch(en,{credentials:"same-origin"}).then(function(Ge){var Ve=WebAssembly.instantiateStreaming(Ge,Y);return Ve.then(ke,function(zt){return R("wasm streaming compile failed: "+zt),R("falling back to ArrayBuffer instantiation"),Ye(ke)})}):Ye(ke)}if(a.instantiateWasm)try{var St=a.instantiateWasm(Y,ie);return St}catch(Ge){R("Module.instantiateWasm callback failed with error: "+Ge),i(Ge)}return kt().catch(i),{}}var Y0,Qs;function Nu(Y){this.name="ExitStatus",this.message="Program terminated with exit("+Y+")",this.status=Y}function Ss(Y){for(;Y.length>0;)Y.shift()(a)}function Pg(){Cr("")}function ih(){return 4294901760}function Ga(){return ih()}function Og(Y,ie,ke){ne.copyWithin(Y>>>0,ie>>>0,ie+ke>>>0)}function uh(Y){try{return L.grow(Y-te.byteLength+65535>>>16),qe(L.buffer),1}catch{}}function _u(Y){var ie=ne.length;Y=Y>>>0;var ke=ih();if(Y>ke)return!1;let Ye=(zt,cr)=>zt+(cr-zt%cr)%cr;for(var kt=1;kt<=4;kt*=2){var St=ie*(1+.2/kt);St=Math.min(St,Y+100663296);var Ge=Math.min(ke,Ye(Math.max(Y,St),65536)),Ve=uh(Ge);if(Ve)return!0}return!1}var bn={varargs:void 0,get:function(){bn.varargs+=4;var Y=we[bn.varargs-4>>>2];return Y},getStr:function(Y){var ie=J(Y);return ie}};function ch(Y){return 52}function Mg(Y,ie,ke,Ye,kt){return 70}var Lg=[null,[],[]];function Z0(Y,ie){var ke=Lg[Y];ie===0||ie===10?((Y===1?$:R)(Z(ke,0)),ke.length=0):ke.push(ie)}function J0(Y,ie,ke,Ye){for(var kt=0,St=0;St<ke;St++){var Ge=ye[ie>>>2],Ve=ye[ie+4>>>2];ie+=8;for(var zt=0;zt<Ve;zt++)Z0(Y,ne[Ge+zt>>>0]);kt+=Ve}return ye[Ye>>>2]=kt,0}function lh(Y){var ie=a["_"+Y];return ie}function Ha(Y,ie){oe.set(Y,ie>>>0)}function zg(Y,ie,ke,Ye,kt){var St={string:Sn=>{var ta=0;if(Sn!=null&&Sn!==0){var Nh=(Sn.length<<2)+1;ta=Zl(Nh),se(Sn,ta,Nh)}return ta},array:Sn=>{var ta=Zl(Sn.length);return Ha(Sn,ta),ta}};function Ge(Sn){return ie==="string"?J(Sn):ie==="boolean"?!!Sn:Sn}var Ve=lh(Y),zt=[],cr=0;if(Ye)for(var Cs=0;Cs<Ye.length;Cs++){var Th=St[ke[Cs]];Th?(cr===0&&(cr=kh()),zt[Cs]=Th(Ye[Cs])):zt[Cs]=Ye[Cs]}var Jl=Ve.apply(null,zt);function uv(Sn){return cr!==0&&Sh(cr),Ge(Sn)}return Jl=uv(Jl),Jl}function Bg(Y,ie,ke,Ye){ke=ke||[];var kt=ke.every(Ge=>Ge==="number"||Ge==="boolean"),St=ie!=="string";return St&&kt&&!Ye?lh(Y):function(){return zg(Y,ie,ke,arguments,Ye)}}var jl={abort:Pg,emscripten_get_heap_max:Ga,emscripten_memcpy_big:Og,emscripten_resize_heap:_u,fd_close:ch,fd_seek:Mg,fd_write:J0},Wg=Rg(),dh=a.___wasm_call_ctors=function(){return(dh=a.___wasm_call_ctors=a.asm.__wasm_call_ctors).apply(null,arguments)},ph=a._init=function(){return(ph=a._init=a.asm.init).apply(null,arguments)},Vg=a._init_with_threads_count=function(){return(Vg=a._init_with_threads_count=a.asm.init_with_threads_count).apply(null,arguments)},hh=a._get_threads_count=function(){return(hh=a._get_threads_count=a.asm.get_threads_count).apply(null,arguments)},Ug=a._register_tensor=function(){return(Ug=a._register_tensor=a.asm.register_tensor).apply(null,arguments)},De=a._dispose_data=function(){return(De=a._dispose_data=a.asm.dispose_data).apply(null,arguments)},ql=a._dispose=function(){return(ql=a._dispose=a.asm.dispose).apply(null,arguments)},Gg=a._Abs=function(){return(Gg=a._Abs=a.asm.Abs).apply(null,arguments)},fh=a._Acos=function(){return(fh=a._Acos=a.asm.Acos).apply(null,arguments)},Eu=a._Acosh=function(){return(Eu=a._Acosh=a.asm.Acosh).apply(null,arguments)},Hg=a._Add=function(){return(Hg=a._Add=a.asm.Add).apply(null,arguments)},jg=a._AddN=function(){return(jg=a._AddN=a.asm.AddN).apply(null,arguments)},qg=a._All=function(){return(qg=a._All=a.asm.All).apply(null,arguments)},Kg=a._Any=function(){return(Kg=a._Any=a.asm.Any).apply(null,arguments)},Xg=a._ArgMax=function(){return(Xg=a._ArgMax=a.asm.ArgMax).apply(null,arguments)},mh=a._ArgMin=function(){return(mh=a._ArgMin=a.asm.ArgMin).apply(null,arguments)},gh=a._Asin=function(){return(gh=a._Asin=a.asm.Asin).apply(null,arguments)},Yg=a._Asinh=function(){return(Yg=a._Asinh=a.asm.Asinh).apply(null,arguments)},Zg=a._Atan=function(){return(Zg=a._Atan=a.asm.Atan).apply(null,arguments)},Jg=a._Atan2=function(){return(Jg=a._Atan2=a.asm.Atan2).apply(null,arguments)},Kl=a._Atanh=function(){return(Kl=a._Atanh=a.asm.Atanh).apply(null,arguments)},Qg=a._AvgPool=function(){return(Qg=a._AvgPool=a.asm.AvgPool).apply(null,arguments)},eb=a._AvgPool3D=function(){return(eb=a._AvgPool3D=a.asm.AvgPool3D).apply(null,arguments)},tb=a._AvgPool3DGrad=function(){return(tb=a._AvgPool3DGrad=a.asm.AvgPool3DGrad).apply(null,arguments)},ja=a._AvgPoolGrad=function(){return(ja=a._AvgPoolGrad=a.asm.AvgPoolGrad).apply(null,arguments)},nb=a._BatchMatMul=function(){return(nb=a._BatchMatMul=a.asm.BatchMatMul).apply(null,arguments)},rb=a._Bincount=function(){return(rb=a._Bincount=a.asm.Bincount).apply(null,arguments)},bh=a._BitwiseAnd=function(){return(bh=a._BitwiseAnd=a.asm.BitwiseAnd).apply(null,arguments)},sb=a._Ceil=function(){return(sb=a._Ceil=a.asm.Ceil).apply(null,arguments)},Xl=a._ClipByValue=function(){return(Xl=a._ClipByValue=a.asm.ClipByValue).apply(null,arguments)},ab=a._Conv2D=function(){return(ab=a._Conv2D=a.asm.Conv2D).apply(null,arguments)},ob=a._Conv2DBackpropInput=function(){return(ob=a._Conv2DBackpropInput=a.asm.Conv2DBackpropInput).apply(null,arguments)},ib=a._Conv3D=function(){return(ib=a._Conv3D=a.asm.Conv3D).apply(null,arguments)},ea=a._Conv3DBackpropFilterV2=function(){return(ea=a._Conv3DBackpropFilterV2=a.asm.Conv3DBackpropFilterV2).apply(null,arguments)},Yl=a._Conv3DBackpropInputV2=function(){return(Yl=a._Conv3DBackpropInputV2=a.asm.Conv3DBackpropInputV2).apply(null,arguments)},ub=a._Cos=function(){return(ub=a._Cos=a.asm.Cos).apply(null,arguments)},cb=a._Cosh=function(){return(cb=a._Cosh=a.asm.Cosh).apply(null,arguments)},lb=a._CropAndResize=function(){return(lb=a._CropAndResize=a.asm.CropAndResize).apply(null,arguments)},db=a._Cumprod=function(){return(db=a._Cumprod=a.asm.Cumprod).apply(null,arguments)},yh=a._Cumsum=function(){return(yh=a._Cumsum=a.asm.Cumsum).apply(null,arguments)},vh=a._DenseBincount=function(){return(vh=a._DenseBincount=a.asm.DenseBincount).apply(null,arguments)},pb=a._DepthToSpace=function(){return(pb=a._DepthToSpace=a.asm.DepthToSpace).apply(null,arguments)},hb=a._DepthwiseConv2dNative=function(){return(hb=a._DepthwiseConv2dNative=a.asm.DepthwiseConv2dNative).apply(null,arguments)},xh=a._Diag=function(){return(xh=a._Diag=a.asm.Diag).apply(null,arguments)},wh=a._Dilation2D=function(){return(wh=a._Dilation2D=a.asm.Dilation2D).apply(null,arguments)},fb=a._Dilation2DBackpropFilter=function(){return(fb=a._Dilation2DBackpropFilter=a.asm.Dilation2DBackpropFilter).apply(null,arguments)},mb=a._Dilation2DBackpropInput=function(){return(mb=a._Dilation2DBackpropInput=a.asm.Dilation2DBackpropInput).apply(null,arguments)},gb=a._Elu=function(){return(gb=a._Elu=a.asm.Elu).apply(null,arguments)},bb=a._EluGrad=function(){return(bb=a._EluGrad=a.asm.EluGrad).apply(null,arguments)},Ih=a._Equal=function(){return(Ih=a._Equal=a.asm.Equal).apply(null,arguments)},Q0=a._Erf=function(){return(Q0=a._Erf=a.asm.Erf).apply(null,arguments)},yb=a._Exp=function(){return(yb=a._Exp=a.asm.Exp).apply(null,arguments)},vb=a._Expm1=function(){return(vb=a._Expm1=a.asm.Expm1).apply(null,arguments)},xb=a._FlipLeftRight=function(){return(xb=a._FlipLeftRight=a.asm.FlipLeftRight).apply(null,arguments)},wb=a._Floor=function(){return(wb=a._Floor=a.asm.Floor).apply(null,arguments)},Ib=a._FloorDiv=function(){return(Ib=a._FloorDiv=a.asm.FloorDiv).apply(null,arguments)},kb=a._FusedBatchNorm=function(){return(kb=a._FusedBatchNorm=a.asm.FusedBatchNorm).apply(null,arguments)},Sb=a._FusedConv2D=function(){return(Sb=a._FusedConv2D=a.asm.FusedConv2D).apply(null,arguments)},Cb=a._FusedDepthwiseConv2D=function(){return(Cb=a._FusedDepthwiseConv2D=a.asm.FusedDepthwiseConv2D).apply(null,arguments)},Tb=a._Gather=function(){return(Tb=a._Gather=a.asm.Gather).apply(null,arguments)},Nb=a._GatherNd=function(){return(Nb=a._GatherNd=a.asm.GatherNd).apply(null,arguments)},_b=a._Greater=function(){return(_b=a._Greater=a.asm.Greater).apply(null,arguments)},Eb=a._GreaterEqual=function(){return(Eb=a._GreaterEqual=a.asm.GreaterEqual).apply(null,arguments)},Ab=a._IsFinite=function(){return(Ab=a._IsFinite=a.asm.IsFinite).apply(null,arguments)},Db=a._IsInf=function(){return(Db=a._IsInf=a.asm.IsInf).apply(null,arguments)},$b=a._IsNan=function(){return($b=a._IsNan=a.asm.IsNan).apply(null,arguments)},Fb=a._LRN=function(){return(Fb=a._LRN=a.asm.LRN).apply(null,arguments)},Rb=a._LRNGrad=function(){return(Rb=a._LRNGrad=a.asm.LRNGrad).apply(null,arguments)},Pb=a._LeakyRelu=function(){return(Pb=a._LeakyRelu=a.asm.LeakyRelu).apply(null,arguments)},Ob=a._Less=function(){return(Ob=a._Less=a.asm.Less).apply(null,arguments)},Mb=a._LessEqual=function(){return(Mb=a._LessEqual=a.asm.LessEqual).apply(null,arguments)},Lb=a._LinSpace=function(){return(Lb=a._LinSpace=a.asm.LinSpace).apply(null,arguments)},zb=a._Log=function(){return(zb=a._Log=a.asm.Log).apply(null,arguments)},Bb=a._Log1p=function(){return(Bb=a._Log1p=a.asm.Log1p).apply(null,arguments)},Wb=a._LogicalAnd=function(){return(Wb=a._LogicalAnd=a.asm.LogicalAnd).apply(null,arguments)},Vb=a._LogicalNot=function(){return(Vb=a._LogicalNot=a.asm.LogicalNot).apply(null,arguments)},Ub=a._LogicalOr=function(){return(Ub=a._LogicalOr=a.asm.LogicalOr).apply(null,arguments)},Gb=a._LogicalXor=function(){return(Gb=a._LogicalXor=a.asm.LogicalXor).apply(null,arguments)},Hb=a._Max=function(){return(Hb=a._Max=a.asm.Max).apply(null,arguments)},jb=a._MaxPool=function(){return(jb=a._MaxPool=a.asm.MaxPool).apply(null,arguments)},qb=a._MaxPool3D=function(){return(qb=a._MaxPool3D=a.asm.MaxPool3D).apply(null,arguments)},Kb=a._MaxPool3DGrad=function(){return(Kb=a._MaxPool3DGrad=a.asm.MaxPool3DGrad).apply(null,arguments)},Xb=a._MaxPoolGrad=function(){return(Xb=a._MaxPoolGrad=a.asm.MaxPoolGrad).apply(null,arguments)},Yb=a._MaxPoolWithArgmax=function(){return(Yb=a._MaxPoolWithArgmax=a.asm.MaxPoolWithArgmax).apply(null,arguments)},Zb=a._Maximum=function(){return(Zb=a._Maximum=a.asm.Maximum).apply(null,arguments)},Jb=a._Mean=function(){return(Jb=a._Mean=a.asm.Mean).apply(null,arguments)},Qb=a._Min=function(){return(Qb=a._Min=a.asm.Min).apply(null,arguments)},ey=a._Minimum=function(){return(ey=a._Minimum=a.asm.Minimum).apply(null,arguments)},ty=a._MirrorPad=function(){return(ty=a._MirrorPad=a.asm.MirrorPad).apply(null,arguments)},ny=a._Mod=function(){return(ny=a._Mod=a.asm.Mod).apply(null,arguments)},ry=a._Multinomial=function(){return(ry=a._Multinomial=a.asm.Multinomial).apply(null,arguments)},sy=a._Multiply=function(){return(sy=a._Multiply=a.asm.Multiply).apply(null,arguments)},ay=a._Neg=function(){return(ay=a._Neg=a.asm.Neg).apply(null,arguments)},oy=a._NonMaxSuppressionV3=function(){return(oy=a._NonMaxSuppressionV3=a.asm.NonMaxSuppressionV3).apply(null,arguments)},iy=a._NonMaxSuppressionV4=function(){return(iy=a._NonMaxSuppressionV4=a.asm.NonMaxSuppressionV4).apply(null,arguments)},uy=a._NonMaxSuppressionV5=function(){return(uy=a._NonMaxSuppressionV5=a.asm.NonMaxSuppressionV5).apply(null,arguments)},cy=a._NotEqual=function(){return(cy=a._NotEqual=a.asm.NotEqual).apply(null,arguments)},ly=a._OneHot=function(){return(ly=a._OneHot=a.asm.OneHot).apply(null,arguments)},dy=a._PadV2=function(){return(dy=a._PadV2=a.asm.PadV2).apply(null,arguments)},py=a._Pow=function(){return(py=a._Pow=a.asm.Pow).apply(null,arguments)},hy=a._Prelu=function(){return(hy=a._Prelu=a.asm.Prelu).apply(null,arguments)},fy=a._Prod=function(){return(fy=a._Prod=a.asm.Prod).apply(null,arguments)},my=a._RealDiv=function(){return(my=a._RealDiv=a.asm.RealDiv).apply(null,arguments)},gy=a._Reciprocal=function(){return(gy=a._Reciprocal=a.asm.Reciprocal).apply(null,arguments)},by=a._Relu=function(){return(by=a._Relu=a.asm.Relu).apply(null,arguments)},yy=a._Relu6=function(){return(yy=a._Relu6=a.asm.Relu6).apply(null,arguments)},vy=a._ResizeBilinear=function(){return(vy=a._ResizeBilinear=a.asm.ResizeBilinear).apply(null,arguments)},xy=a._ResizeBilinearGrad=function(){return(xy=a._ResizeBilinearGrad=a.asm.ResizeBilinearGrad).apply(null,arguments)},wy=a._ResizeNearestNeighbor=function(){return(wy=a._ResizeNearestNeighbor=a.asm.ResizeNearestNeighbor).apply(null,arguments)},Iy=a._ResizeNearestNeighborGrad=function(){return(Iy=a._ResizeNearestNeighborGrad=a.asm.ResizeNearestNeighborGrad).apply(null,arguments)},ky=a._Reverse=function(){return(ky=a._Reverse=a.asm.Reverse).apply(null,arguments)},Sy=a._RotateWithOffset=function(){return(Sy=a._RotateWithOffset=a.asm.RotateWithOffset).apply(null,arguments)},Cy=a._Round=function(){return(Cy=a._Round=a.asm.Round).apply(null,arguments)},Ty=a._Rsqrt=function(){return(Ty=a._Rsqrt=a.asm.Rsqrt).apply(null,arguments)},Ny=a._ScatterNd=function(){return(Ny=a._ScatterNd=a.asm.ScatterNd).apply(null,arguments)},_y=a._SearchSorted=function(){return(_y=a._SearchSorted=a.asm.SearchSorted).apply(null,arguments)},Ey=a._SelectV2=function(){return(Ey=a._SelectV2=a.asm.SelectV2).apply(null,arguments)},Ay=a._Selu=function(){return(Ay=a._Selu=a.asm.Selu).apply(null,arguments)},Dy=a._Sigmoid=function(){return(Dy=a._Sigmoid=a.asm.Sigmoid).apply(null,arguments)},$y=a._Sign=function(){return($y=a._Sign=a.asm.Sign).apply(null,arguments)},Fy=a._Sin=function(){return(Fy=a._Sin=a.asm.Sin).apply(null,arguments)},Ry=a._Sinh=function(){return(Ry=a._Sinh=a.asm.Sinh).apply(null,arguments)},Py=a._Softmax=function(){return(Py=a._Softmax=a.asm.Softmax).apply(null,arguments)},Oy=a._Softplus=function(){return(Oy=a._Softplus=a.asm.Softplus).apply(null,arguments)},My=a._SparseFillEmptyRows=function(){return(My=a._SparseFillEmptyRows=a.asm.SparseFillEmptyRows).apply(null,arguments)},Ly=a._SparseReshape=function(){return(Ly=a._SparseReshape=a.asm.SparseReshape).apply(null,arguments)},zy=a._SparseSegmentReduction=function(){return(zy=a._SparseSegmentReduction=a.asm.SparseSegmentReduction).apply(null,arguments)},By=a._SparseToDense=function(){return(By=a._SparseToDense=a.asm.SparseToDense).apply(null,arguments)},Wy=a._Sqrt=function(){return(Wy=a._Sqrt=a.asm.Sqrt).apply(null,arguments)},Vy=a._Square=function(){return(Vy=a._Square=a.asm.Square).apply(null,arguments)},Uy=a._SquaredDifference=function(){return(Uy=a._SquaredDifference=a.asm.SquaredDifference).apply(null,arguments)},Gy=a._Step=function(){return(Gy=a._Step=a.asm.Step).apply(null,arguments)},Hy=a._StridedSlice=function(){return(Hy=a._StridedSlice=a.asm.StridedSlice).apply(null,arguments)},jy=a._Sub=function(){return(jy=a._Sub=a.asm.Sub).apply(null,arguments)},qy=a._Sum=function(){return(qy=a._Sum=a.asm.Sum).apply(null,arguments)},Ky=a._Tan=function(){return(Ky=a._Tan=a.asm.Tan).apply(null,arguments)},Xy=a._Tanh=function(){return(Xy=a._Tanh=a.asm.Tanh).apply(null,arguments)},Yy=a._TensorScatterUpdate=function(){return(Yy=a._TensorScatterUpdate=a.asm.TensorScatterUpdate).apply(null,arguments)},Zy=a._Tile=function(){return(Zy=a._Tile=a.asm.Tile).apply(null,arguments)},Jy=a._TopK=function(){return(Jy=a._TopK=a.asm.TopK).apply(null,arguments)},Qy=a._Transform=function(){return(Qy=a._Transform=a.asm.Transform).apply(null,arguments)},ev=a._Transpose=function(){return(ev=a._Transpose=a.asm.Transpose).apply(null,arguments)},tv=a.__FusedMatMul=function(){return(tv=a.__FusedMatMul=a.asm._FusedMatMul).apply(null,arguments)},nv=a._malloc=function(){return(nv=a._malloc=a.asm.malloc).apply(null,arguments)},rv=a._free=function(){return(rv=a._free=a.asm.free).apply(null,arguments)},sv=a.___errno_location=function(){return(sv=a.___errno_location=a.asm.__errno_location).apply(null,arguments)},kh=a.stackSave=function(){return(kh=a.stackSave=a.asm.stackSave).apply(null,arguments)},Sh=a.stackRestore=function(){return(Sh=a.stackRestore=a.asm.stackRestore).apply(null,arguments)},Zl=a.stackAlloc=function(){return(Zl=a.stackAlloc=a.asm.stackAlloc).apply(null,arguments)},av=a.dynCall_iijjiiii=function(){return(av=a.dynCall_iijjiiii=a.asm.dynCall_iijjiiii).apply(null,arguments)},ov=a.dynCall_jiji=function(){return(ov=a.dynCall_jiji=a.asm.dynCall_jiji).apply(null,arguments)};a.cwrap=Bg;var Au;gn=function Y(){Au||Ch(),Au||(gn=Y)};function Ch(Y){if(Y=Y||l,wt>0||($t(),wt>0))return;function ie(){Au||(Au=!0,a.calledRun=!0,!U&&(kr(),o(a),a.onRuntimeInitialized&&a.onRuntimeInitialized(),dn()))}a.setStatus?(a.setStatus("Running..."),setTimeout(function(){setTimeout(function(){a.setStatus("")},1),ie()},1)):ie()}if(a.preInit)for(typeof a.preInit=="function"&&(a.preInit=[a.preInit]);a.preInit.length>0;)a.preInit.pop()();Ch();var Du;u&&(Du={uncaughtException:process.listeners("uncaughtException").filter(function(Y){return!u.uncaughtException.indexOf(Y)>-1}),unhandledRejection:process.listeners("unhandledRejection").filter(function(Y){return!u.unhandledRejection.indexOf(Y)>-1})});var $u;if(typeof s<"u")$u=s;else if(typeof WasmBackendModuleThreadedSimd<"u")$u=WasmBackendModuleThreadedSimd;else throw new Error("Could not find wasm module in post.js");if(Du){var iv=$u._dispose;$u._dispose=function(){iv(),Du.uncaughtException.forEach(function(Y){process.removeListener("uncaughtException",Y)}),Du.unhandledRejection.forEach(function(Y){process.removeListener("unhandledRejection",Y)})}}return s.ready}})();typeof e=="object"&&typeof t=="object"?t.exports=n:typeof define=="function"&&define.amd?define([],function(){return n}):typeof e=="object"&&(e.WasmBackendModule=n)}}),_R=1e-7,ER=1e-4,Mf=class{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}},Md=class{refCount(e){return Yn("refCount")}incRef(e){return Yn("incRef")}timerAvailable(){return!0}time(e){return Yn("time")}read(e){return Yn("read")}readSync(e){return Yn("readSync")}readToGPU(e,t){return Yn("readToGPU")}numDataIds(){return Yn("numDataIds")}disposeData(e,t){return Yn("disposeData")}write(e,t,n){return Yn("write")}move(e,t,n,r,s){return Yn("move")}createTensorFromGPUData(e,t,n){return Yn("createTensorFromGPUData")}memory(){return Yn("memory")}floatPrecision(){return Yn("floatPrecision")}epsilon(){return this.floatPrecision()===32?_R:ER}dispose(){return Yn("dispose")}};function Yn(e){throw new Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function Y1(e){let t=e.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,of(e,t,n)}function AR(e,t){if(e.length!==t.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${e.length}Second array length was ${t.length}`);let n=e.length,r=0;for(;n>0;)r=Math.random()*n|0,n--,of(e,n,r),of(t,n,r)}function yd(e,t,n){return Math.max(e,Math.min(t,n))}function DR(e){return e%2===0?e:e+1}function of(e,t,n){let r=e[t];e[t]=e[n],e[n]=r}function $R(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}function FR(e,t){let n=Math.random();return t*n+(1-n)*e}function RR(e,t){let n=0;for(let r=0;r<e.length;r++){let s=Number(e[r])-Number(t[r]);n+=s*s}return n}function A(e,t){if(!e)throw new Error(typeof t=="string"?t:t())}function En(e,t,n=""){A(Os(e,t),()=>n+` Shapes ${e} and ${t} must match`)}function _o(e){A(e!=null,()=>"The input to the tensor constructor must be a non-null value.")}function gt(e){if(e.length===0)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function PR(e){return e.length===0}function Z1(e,t){if(e===t)return!0;if(e==null||t==null||e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==null&&t[n]!==null&&e[n]!==t[n])return!1;return!0}function Os(e,t){if(e===t)return!0;if(e==null||t==null||e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function Vu(e){return e%1===0}function OR(e){if(Math.tanh!=null)return Math.tanh(e);if(e===1/0)return 1;if(e===-1/0)return-1;{let t=Math.exp(2*e);return(t-1)/(t+1)}}function MR(e){let t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function LR(e){let t=new Uint32Array(e);for(let n=0;n<e;++n)t[n]=n;return Y1(t),t}function fd(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function zR(e,t=s=>0,n,r){return new Promise((s,a)=>{let o=0,i=()=>{if(e()){s();return}o++;let u=t(o);if(n!=null&&o>=n){a();return}r!=null?r(i,u):setTimeout(i,u)};i()})}function BR(e,t){let n=1,r=-1;for(let a=0;a<e.length;++a)if(e[a]>=0)n*=e[a];else if(e[a]===-1){if(r!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${a}`);r=a}else if(e[a]<0)throw Error(`Shapes can not be < 0. Found ${e[a]} at dim ${a}`);if(r===-1){if(t>0&&t!==n)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(n===0)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%n!==0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);let s=e.slice();return s[r]=t/n,s}function Pr(e,t){let n=t.length;return e=e==null?t.map((r,s)=>s):[].concat(e),A(e.every(r=>r>=-n&&r<n),()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`),A(e.every(r=>Vu(r)),()=>`All values in axis param must be integers but got axis ${e}`),e.map(r=>r<0?n+r:r)}function J1(e,t){let n=[],r=[],s=t!=null&&Array.isArray(t)&&t.length===0,a=t==null||s?null:Pr(t,e).sort(),o=0;for(let i=0;i<e.length;++i){if(a!=null){if(a[o]===i&&e[i]!==1)throw new Error(`Can't squeeze axis ${i} since its dim '${e[i]}' is not 1`);(a[o]==null||a[o]>i)&&e[i]===1&&(n.push(e[i]),r.push(i)),a[o]<=i&&o++}e[i]!==1&&(n.push(e[i]),r.push(i))}return{newShape:n,keptDims:r}}function Q1(e,t){return _x(e,t)}function _x(e,t){let n=null;if(e==null||e==="float32")n=new Float32Array(t);else if(e==="int32")n=new Int32Array(t);else if(e==="bool")n=new Uint8Array(t);else if(e==="string")n=new Array(t);else throw new Error(`Unknown data type ${e}`);return n}function eC(e,t){for(let n=0;n<e.length;n++){let r=e[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${t} being uploaded contains ${r}.`)}}function tC(e){return e==="bool"||e==="complex64"||e==="float32"||e==="int32"||e==="string"}function WR(e,t){return!(t==="complex64"||t==="float32"&&e!=="complex64"||t==="int32"&&e!=="float32"&&e!=="complex64"||t==="bool"&&e==="bool")}function uf(e){if(e==="float32"||e==="int32")return 4;if(e==="complex64")return 8;if(e==="bool")return 1;throw new Error(`Unknown dtype ${e}`)}function nC(e){if(e==null)return 0;let t=0;return e.forEach(n=>t+=n.length),t}function aa(e){return typeof e=="string"||e instanceof String}function rC(e){return typeof e=="boolean"}function sC(e){return typeof e=="number"}function Ld(e){return Array.isArray(e)?Ld(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?"int32":sC(e)?"float32":aa(e)?"string":rC(e)?"bool":"float32"}function pa(e){return!!(e&&e.constructor&&e.call&&e.apply)}function cf(e,t){for(let n=t;n<e;++n)if(e%n===0)return n;return e}function uc(e){let t=e.length;if(t<2)return[];let n=new Array(t-1);n[t-2]=e[t-1];for(let r=t-3;r>=0;--r)n[r]=n[r+1]*e[r+1];return n}function aC(e,t,n,r=!1){let s=new Array;if(t.length===1){let a=t[0]*(r?2:1);for(let o=0;o<a;o++)s[o]=n[e+o]}else{let a=t[0],o=t.slice(1),i=o.reduce((u,c)=>u*c)*(r?2:1);for(let u=0;u<a;u++)s[u]=aC(e+u*i,o,n,r)}return s}function Lu(e,t,n=!1){if(e.length===0)return t[0];let r=e.reduce((s,a)=>s*a)*(n?2:1);if(r===0)return[];if(r!==t.length)throw new Error(`[${e}] does not match the input size ${t.length}${n?" for a complex tensor":""}.`);return aC(0,e,t,n)}function VR(e,t){if(Array.isArray(e))return e;if(t==="float32")return e instanceof Float32Array?e:new Float32Array(e);if(t==="int32")return e instanceof Int32Array?e:new Int32Array(e);if(t==="bool"||t==="string")return Uint8Array.from(new Int32Array(e));throw new Error(`Unknown dtype ${t}`)}function Ex(e,t){let n=Lf(e,t);for(let r=0;r<n.length;r++)n[r]=1;return n}function Lf(e,t){if(t==null||t==="float32"||t==="complex64")return new Float32Array(e);if(t==="int32")return new Int32Array(e);if(t==="bool")return new Uint8Array(e);throw new Error(`Unknown data type ${t}`)}function UR(e,t){let n=e.reduce((r,s)=>r*s,1);if(t==null||t==="float32")return Lu(e,new Float32Array(n));if(t==="int32")return Lu(e,new Int32Array(n));if(t==="bool")return Lu(e,new Uint8Array(n));throw new Error(`Unknown data type ${t}`)}function or(e){e.forEach(t=>{A(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`)})}function GR(e,t,n){if(t===0)return 0;if(t===1)return e[0];let r=e[e.length-1];for(let s=0;s<e.length-1;++s)r+=n[s]*e[s];return r}function HR(e,t,n){if(t===0)return[];if(t===1)return[e];let r=new Array(t);for(let s=0;s<r.length-1;++s)r[s]=Math.floor(e/n[s]),e-=r[s]*n[s];return r[r.length-1]=e,r}function zf(e){return e&&e.then&&typeof e.then=="function"}var cS="tfjsflags",oC=class{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=jR,this.populateURLFlags()}setPlatform(e,t){this.platform!=null&&(G().getBool("IS_TEST")||G().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},this.urlFlags[e]!=null){let r=this.urlFlags[e];G().getBool("IS_TEST")||G().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${r}.`),this.set(e,r)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];let t=this.evaluateFlag(e);if(zf(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;let e=this.getQueryParams(this.global.location.search);cS in e&&e[cS].split(",").forEach(n=>{let[r,s]=n.split(":");this.urlFlags[r]=KR(r,s)})}};function jR(e){let t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(n,...r)=>(qR(t,r[0],r[1]),r.join("="))),t}function qR(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}function KR(e,t){let n=t.toLowerCase();return n==="true"||n==="false"?n==="true":`${+n}`===n?+n:t}function G(){return Ax}var Ax=null;function XR(e){Ax=e}var pv;function iC(){if(pv==null){let e;if(typeof window<"u")e=window;else if(typeof global<"u")e=global;else if(typeof process<"u")e=process;else if(typeof self<"u")e=self;else throw new Error("Could not find a global object");pv=e}return pv}function YR(){let e=iC();return e._tfGlobals==null&&(e._tfGlobals=new Map),e._tfGlobals}function Dx(e,t){let n=YR();if(n.has(e))return n.get(e);{let r=t();return n.set(e,r),n.get(e)}}var cc="Abs",Eo="Acos",Ao="Acosh",Sa="Add",Do="AddN",lc="All",dc="Any",pc="ArgMax",hc="ArgMin",$o="Asin",Fo="Asinh",Ro="Atan",Po="Atanh",Oo="Atan2",Mo="AvgPool",zd="AvgPoolGrad",fc="AvgPool3D",Bd="AvgPool3DGrad",Lo="BatchMatMul",mc="BatchToSpaceND",gc="Bincount",bc="BitwiseAnd",uC="BroadcastTo",Wd="BroadcastArgs",zo="Cast",Bo="Ceil",Ca="ClipByValue",Bf="Complex",Vd="ComplexAbs",yc="Concat",Wo="Conv2D",Wf="Conv2DBackpropFilter",Vo="Conv2DBackpropInput",Uo="Conv3D",vc="Conv3DBackpropFilterV2",xc="Conv3DBackpropInputV2",Go="Cos",Ho="Cosh",wc="Cumprod",jo="Cumsum",Ic="CropAndResize",Ud="DenseBincount",kc="DepthToSpace",qo="DepthwiseConv2dNative",Vf="DepthwiseConv2dNativeBackpropFilter",Uf="DepthwiseConv2dNativeBackpropInput",Gd="Diag",Ko="Dilation2D",Uu="Dilation2DBackpropInput",Gu="Dilation2DBackpropFilter",Gf="Draw",Xo="RealDiv",Hf="Einsum",Yo="Elu",Sc="EluGrad",Zo="Erf",Cc="Equal",Jo="Exp",Tc="ExpandDims",Qo="Expm1",jf="FFT",Hd="Fill",Nc="FlipLeftRight",ei="Floor",ti="FloorDiv",ni="FusedBatchNorm",_c="GatherV2",Ec="GatherNd",Ac="Greater",ri="GreaterEqual",si="Identity",qf="IFFT",Kf="Imag",ai="IsFinite",oi="IsInf",ii="IsNan",ui="LeakyRelu",Dc="Less",$c="LessEqual",Fc="LinSpace",ci="Log",li="Log1p",Rc="LogicalAnd",Pc="LogicalNot",Oc="LogicalOr",cC="LogicalXor",lC="LogSoftmax",ZR="LowerBound",di="LRN",Mc="LRNGrad",JR="MatrixBandPart",pi="Max",hi="Maximum",fi="MaxPool",jd="MaxPoolGrad",Lc="MaxPool3D",qd="MaxPool3DGrad",Kd="MaxPoolWithArgmax",mi="Mean",gi="Min",bi="Minimum",yi="MirrorPad",vi="Mod",zc="Multinomial",xi="Multiply",Bc="Neg",Wc="NotEqual",Vc="NonMaxSuppressionV3",Uc="NonMaxSuppressionV4",Gc="NonMaxSuppressionV5",Hc="OnesLike",wi="OneHot",jc="Pack",Ii="PadV2",QR="Pool",ki="Pow",Si="Prelu",Ci="Prod",Xf="RaggedGather",Yf="RaggedRange",Zf="RaggedTensorToTensor",Xd="Range",Jf="Real",Ti="Reciprocal",Ni="Relu",qc="Reshape",_i="ResizeNearestNeighbor",Kc="ResizeNearestNeighborGrad",Ei="ResizeBilinear",Xc="ResizeBilinearGrad",Ai="Relu6",Di="Reverse",$i="Round",Fi="Rsqrt",Yc="ScatterNd",Zc="TensorScatterUpdate",Jc="SearchSorted",Qc="Select",Ri="Selu",el="Slice",Pi="Sin",Oi="Sinh",Mi="Sign",Li="Sigmoid",zi="Softplus",Bi="Sqrt",Wi="Sum",tl="SpaceToBatchND",nl="SplitV",Vi="Softmax",Yd="SparseFillEmptyRows",rl="SparseReshape",Zd="SparseSegmentMean",Jd="SparseSegmentSum",sl="SparseToDense",Ui="SquaredDifference",Qd="Square",ep="StaticRegexReplace",al="StridedSlice",tp="StringNGrams",np="StringSplit",rp="StringToHashBucketFast",Gi="Sub",Hi="Tan",ji="Tanh",Ta="Tile",ol="TopK",il="Transform",$s="Transpose",sp="Unique",ul="Unpack",ap="UnsortedSegmentSum",eP="UpperBound",cl="ZerosLike",Na="Step",lf="FromPixels",ll="RotateWithOffset",co="_FusedMatMul",lo="FusedConv2D",po="FusedDepthwiseConv2D";function sa(...e){G().getBool("IS_TEST")||G().getBool("PROD")||console.warn(...e)}function tP(...e){G().getBool("IS_TEST")||G().getBool("PROD")||console.log(...e)}var Hu=Dx("kernelRegistry",()=>new Map),vd=Dx("gradRegistry",()=>new Map);function xd(e,t){let n=$x(e,t);return Hu.get(n)}function Nv(e){return vd.get(e)}function df(e){let t=Hu.entries(),n=[];for(;;){let{done:r,value:s}=t.next();if(r)break;let[a,o]=s,[i]=a.split("_");i===e&&n.push(o)}return n}function op(e){let{kernelName:t,backendName:n}=e,r=$x(t,n);Hu.has(r)&&sa(`The kernel '${t}' for backend '${n}' is already registered`),Hu.set(r,e)}function dC(e){let{kernelName:t}=e;vd.has(t)&&G().getBool("DEBUG")&&sa(`Overriding the gradient for '${t}'`),vd.set(t,e)}function nP(e,t){let n=$x(e,t);if(!Hu.has(n))throw new Error(`The kernel '${e}' for backend '${t}' is not registered`);Hu.delete(n)}function rP(e){if(!vd.has(e))throw new Error(`The gradient '${e}' for backend is not registered`);vd.delete(e)}function sP(e,t){df(e).forEach(r=>{let s=Object.assign({},r,{backendName:t});op(s)})}function $x(e,t){return`${t}_${e}`}var w={};Ee(w,{arraysEqual:()=>Os,arraysEqualWithNull:()=>Z1,assert:()=>A,assertNonNegativeIntegerDimensions:()=>or,assertNonNull:()=>_o,assertShapesMatch:()=>En,bytesFromStringArray:()=>nC,bytesPerElement:()=>uf,checkConversionForErrors:()=>eC,clamp:()=>yd,computeStrides:()=>uc,convertBackendValuesAndArrayBuffer:()=>VR,createScalarValue:()=>lP,createShuffledIndices:()=>LR,decodeString:()=>pf,distSquared:()=>RR,encodeString:()=>up,fetch:()=>pP,fingerPrint64:()=>cP,flatten:()=>ha,getArrayFromDType:()=>_x,getTypedArrayFromDType:()=>Q1,hasEncodingLoss:()=>WR,hexToLong:()=>ip,indexToLoc:()=>HR,inferDtype:()=>Ld,inferFromImplicitShape:()=>BR,isBoolean:()=>rC,isFunction:()=>pa,isInt:()=>Vu,isNumber:()=>sC,isPromise:()=>zf,isScalarShape:()=>PR,isString:()=>aa,isTypedArray:()=>nn,isValidDtype:()=>tC,locToIndex:()=>GR,makeOnesTypedArray:()=>Ex,makeZerosNestedTypedArray:()=>UR,makeZerosTypedArray:()=>Lf,nearestDivisor:()=>cf,nearestLargerEven:()=>DR,now:()=>wd,parseAxisParam:()=>Pr,randUniform:()=>FR,repeatedTry:()=>zR,rightPad:()=>fd,shuffle:()=>Y1,shuffleCombo:()=>AR,sizeFromShape:()=>gt,sizeToSquarishShape:()=>MR,squeezeShape:()=>J1,sum:()=>$R,swap:()=>of,tanh:()=>OR,toNestedArray:()=>Lu,toTypedArray:()=>Qf});function pC(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}var lS=ka(dR()),Za=lS.default||lS;function ip(e){return Za.fromString(e,!0,16)}var hC=ip("c3a5c85c97cb3127"),Xa=ip("b492b66fbe98f273"),Cn=ip("9ae16a3b2f90404f");function _v(e){return e.xor(e.shru(47))}function fC(e,t,n){let r=e.slice(t,t+n);return Za.fromBytes(Array.from(r),!0,!0)}function mt(e,t){return fC(e,t,8)}function dS(e,t){return fC(e,t,4)}function tn(e,t){return t===0?e:e.shru(t).or(e.shl(64-t))}function ca(e,t,n=ip("9ddfea08eb382d69")){let r=e.xor(t).mul(n);r=r.xor(r.shru(47));let s=t.xor(r).mul(n);return s=s.xor(s.shru(47)),s=s.mul(n),s}function aP(e,t,n,r,s,a){s=s.add(e),a=tn(a.add(s).add(r),21);let o=s;return s=s.add(t),s=s.add(n),a=a.add(tn(s,44)),[s.add(r),a.add(o)]}function Oh(e,t,n,r){return aP(mt(e,t),mt(e,t+8),mt(e,t+16),mt(e,t+24),n,r)}function oP(e,t=e.length){if(t>=8){let n=Cn.add(t*2),r=mt(e,0).add(Cn),s=mt(e,t-8),a=tn(s,37).mul(n).add(r),o=tn(r,25).add(s).mul(n);return ca(a,o,n)}if(t>=4){let n=Cn.add(t*2),r=dS(e,0);return ca(r.shl(3).add(t),dS(e,t-4),n)}if(t>0){let n=e[0],r=e[t>>1],s=e[t-1],a=n+(r<<8),o=t+(s<<2);return _v(Cn.mul(a).xor(hC.mul(o))).mul(Cn)}return Cn}function iP(e,t=e.length){let n=Cn.add(t*2),r=mt(e,0).mul(Xa),s=mt(e,8),a=mt(e,t-8).mul(n),o=mt(e,t-16).mul(Cn);return ca(tn(r.add(s),43).add(tn(a,30)).add(o),r.add(tn(s.add(Cn),18)).add(a),n)}function uP(e,t=e.length){let n=Cn.add(t*2),r=mt(e,0).mul(Cn),s=mt(e,8),a=mt(e,t-8).mul(n),o=mt(e,t-16).mul(Cn),i=tn(r.add(s),43).add(tn(a,30)).add(o),u=ca(i,r.add(tn(s.add(Cn),18)).add(a),n),c=mt(e,16).mul(n),l=mt(e,24),p=i.add(mt(e,t-32)).mul(n),d=u.add(mt(e,t-24)).mul(n);return ca(tn(c.add(l),43).add(tn(p,30)).add(d),c.add(tn(l.add(r),18)).add(p),n)}function cP(e,t=e.length){let n=Za.fromNumber(81,!0);if(t<=32)return t<=16?oP(e,t):iP(e,t);if(t<=64)return uP(e,t);let r=n,s=n.mul(Xa).add(113),a=_v(s.mul(Cn).add(113)).mul(Cn),o=[Za.UZERO,Za.UZERO],i=[Za.UZERO,Za.UZERO];r=r.mul(Cn).add(mt(e,0));let u=0,c=(t-1>>6)*64,l=c+(t-1&63)-63;do r=tn(r.add(s).add(o[0]).add(mt(e,u+8)),37).mul(Xa),s=tn(s.add(o[1]).add(mt(e,u+48)),42).mul(Xa),r=r.xor(i[1]),s=s.add(o[0]).add(mt(e,u+40)),a=tn(a.add(i[0]),33).mul(Xa),o=Oh(e,u,o[1].mul(Xa),r.add(i[0])),i=Oh(e,u+32,a.add(i[1]),s.add(mt(e,u+16))),[a,r]=[r,a],u+=64;while(u!==c);let p=Xa.add(a.and(255).shl(1));return u=l,i[0]=i[0].add(t-1&63),o[0]=o[0].add(i[0]),i[0]=i[0].add(o[0]),r=tn(r.add(s).add(o[0]).add(mt(e,u+8)),37).mul(p),s=tn(s.add(o[1]).add(mt(e,u+48)),42).mul(p),r=r.xor(i[1].mul(9)),s=s.add(o[0].mul(9).add(mt(e,u+40))),a=tn(a.add(i[0]),33).mul(p),o=Oh(e,u,o[1].mul(p),r.add(i[0])),i=Oh(e,u+32,a.add(i[1]),s.add(mt(e,u+16))),[a,r]=[r,a],ca(ca(o[0],i[0],p).add(_v(s).mul(hC)).add(a),ca(o[1],i[1],p).add(r),p)}function lP(e,t){return t==="string"?up(e):Qf([e],t)}function dP(e,t){return e instanceof Float32Array&&t==="float32"||e instanceof Int32Array&&t==="int32"||e instanceof Uint8Array&&t==="bool"}function Qf(e,t){if(t==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=ha(e)),G().getBool("DEBUG")&&eC(e,t),dP(e,t))return e;if(t==null||t==="float32"||t==="complex64")return new Float32Array(e);if(t==="int32")return new Int32Array(e);if(t==="bool"){let n=new Uint8Array(e.length);for(let r=0;r<n.length;++r)Math.round(e[r])!==0&&(n[r]=1);return n}else throw new Error(`Unknown data type ${t}`)}function wd(){return G().platform.now()}function pP(e,t){return G().platform.fetch(e,t)}function up(e,t="utf-8"){return t=t||"utf-8",G().platform.encode(e,t)}function pf(e,t="utf-8"){return t=t||"utf-8",G().platform.decode(e,t)}function nn(e){return G().platform.isTypedArray!=null?G().platform.isTypedArray(e):pC(e)}function ha(e,t=[],n=!1){if(t==null&&(t=[]),typeof e=="boolean"||typeof e=="number"||typeof e=="string"||zf(e)||e==null||nn(e)&&n)t.push(e);else if(Array.isArray(e)||nn(e))for(let r=0;r<e.length;++r)ha(e[r],t,n);else{let r=-1;for(let s of Object.keys(e))/^([1-9]+[0-9]*|0)$/.test(s)&&(r=Math.max(r,Number(s)));for(let s=0;s<=r;s++)ha(e[s],t,n)}return t}var hP=class{constructor(e,t){this.backendTimer=e,this.logger=t,t==null&&(this.logger=new mP)}profileKernel(e,t,n){let r,s=()=>{r=n()},a,o=wd();if(this.backendTimer.timerAvailable())a=this.backendTimer.time(s);else{s();for(let u of r)u.dataSync();a=Promise.resolve({kernelMs:wd()-o})}if(G().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let u=0;u<r.length;u++){let c=r[u];c.data().then(l=>{fP(l,c.dtype,e)})}return{kernelName:e,outputs:r,inputs:t,timeMs:a.then(u=>u.kernelMs),extraInfo:a.then(u=>u.getExtraProfileInfo!=null?u.getExtraProfileInfo():"")}}logKernelProfile(e){let{kernelName:t,outputs:n,timeMs:r,inputs:s,extraInfo:a}=e;n.forEach(o=>{Promise.all([o.data(),r,a]).then(i=>{this.logger.logKernelProfile(t,o,i[0],i[1],s,i[2])})})}};function fP(e,t,n){if(t!=="float32")return!1;for(let r=0;r<e.length;r++){let s=e[r];if(isNaN(s)||!isFinite(s))return console.warn(`Found ${s} in the result of '${n}'`),!0}return!1}var mP=class{logKernelProfile(e,t,n,r,s,a){let o=typeof r=="number"?fd(`${r}ms`,9):r.error,i=fd(e,25),u=t.rank,c=t.size,l=fd(t.shape.toString(),14),p="";for(let d in s){let h=s[d];if(h!=null){let f=h.shape||t.shape,g=f.length;p+=`${d}: ${g}D ${g>0?f:""} `}}console.log(`%c${i}	%c${o}	%c${u}D ${l}	%c${c}	%c${p}	%c${a}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}};function gP(e,t,n){let r={},s={};for(let u=0;u<t.length;u++)r[t[u].id]=!0;for(let u=0;u<e.length;u++){let c=e[u],l=c.inputs;for(let p in l){let d=l[p],h=!1;for(let f=0;f<t.length;f++)if(r[d.id]){c.outputs.forEach(g=>r[g.id]=!0),h=!0,s[c.id]=!0;break}if(h)break}}let a={};a[n.id]=!0;let o={};for(let u=e.length-1;u>=0;u--){let c=e[u],l=c.inputs;for(let p=0;p<c.outputs.length;p++)if(a[c.outputs[p].id]){for(let d in l)a[l[d].id]=!0,o[c.id]=!0;break}}let i=[];for(let u=0;u<e.length;u++){let c=e[u];if(s[c.id]&&o[c.id]){let l={};for(let d in c.inputs){let h=c.inputs[d];r[h.id]&&(l[d]=h)}let p=Object.assign({},c);p.inputs=l,p.outputs=c.outputs,i.push(p)}}return i}function bP(e,t,n,r){for(let s=t.length-1;s>=0;s--){let a=t[s],o=[];if(a.outputs.forEach(u=>{let c=e[u.id];c!=null?o.push(c):o.push(null)}),a.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${a.kernelName}.`);let i=a.gradient(o);for(let u in a.inputs){if(!(u in i))throw new Error(`Cannot backprop through input ${u}. Available gradients found: ${Object.keys(i)}.`);let c=n(()=>i[u]());if(c.dtype!=="float32")throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input ${u} must have 'float32' dtype, but has '${c.dtype}'`);let l=a.inputs[u];if(!Os(c.shape,l.shape))throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input '${u}' has shape '${c.shape}', which does not match the shape of the input '${l.shape}'`);if(e[l.id]==null)e[l.id]=c;else{let p=e[l.id];e[l.id]=r(p,c),p.dispose()}}}}var pS=20,Ql=3,hv=7;function yP(e,t,n,r){let s=uc(t),a=vP(e,t,n,s),o=t.length,i=Zh(e,t,n,s,a),u=["Tensor"];return r&&(u.push(`  dtype: ${n}`),u.push(`  rank: ${o}`),u.push(`  shape: [${t}]`),u.push("  values:")),u.push(i.map(c=>"    "+c).join(`
`)),u.join(`
`)}function vP(e,t,n,r){let s=gt(t),a=r[r.length-1],o=new Array(a).fill(0),i=t.length,u=n==="complex64"?ad(e):e;if(i>1)for(let c=0;c<s/a;c++){let l=c*a;for(let p=0;p<a;p++)o[p]=Math.max(o[p],sd(u[l+p],0,n).length)}return o}function sd(e,t,n){let r;return Array.isArray(e)?r=`${parseFloat(e[0].toFixed(hv))} + ${parseFloat(e[1].toFixed(hv))}j`:aa(e)?r=`'${e}'`:n==="bool"?r=mC(e):r=parseFloat(e.toFixed(hv)).toString(),fd(r,t)}function mC(e){return e===0?"false":"true"}function Zh(e,t,n,r,s,a=!0){let o=n==="complex64"?2:1,i=t[0],u=t.length;if(u===0){if(n==="complex64"){let g=ad(e);return[sd(g[0],0,n)]}return n==="bool"?[mC(e[0])]:[e[0].toString()]}if(u===1){if(i>pS){let m=Ql*o,b=Array.from(e.slice(0,m)),v=Array.from(e.slice((i-Ql)*o,i*o));return n==="complex64"&&(b=ad(b),v=ad(v)),["["+b.map((y,x)=>sd(y,s[x],n)).join(", ")+", ..., "+v.map((y,x)=>sd(y,s[i-Ql+x],n)).join(", ")+"]"]}return["["+(n==="complex64"?ad(e):Array.from(e)).map((m,b)=>sd(m,s[b],n)).join(", ")+"]"]}let c=t.slice(1),l=r.slice(1),p=r[0]*o,d=[];if(i>pS){for(let g=0;g<Ql;g++){let m=g*p,b=m+p;d.push(...Zh(e.slice(m,b),c,n,l,s,!1))}d.push("...");for(let g=i-Ql;g<i;g++){let m=g*p,b=m+p;d.push(...Zh(e.slice(m,b),c,n,l,s,g===i-1))}}else for(let g=0;g<i;g++){let m=g*p,b=m+p;d.push(...Zh(e.slice(m,b),c,n,l,s,g===i-1))}let h=u===2?",":"";d[0]="["+(i>0?d[0]+h:"");for(let g=1;g<d.length-1;g++)d[g]=" "+d[g]+h;let f=`,
`;for(let g=2;g<u;g++)f+=`
`;return d[d.length-1]=" "+d[d.length-1]+"]"+(a?"":f),d}function ad(e){let t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}var Vt=class{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=gt(e),n!=null){let r=n.length;A(r===this.size,()=>`Length of values '${r}' does not match the size inferred by the shape '${this.size}'.`)}if(t==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||_x(t,this.size),this.strides=uc(e)}set(e,...t){t.length===0&&(t=[0]),A(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);let n=this.locToIndex(t);this.values[n]=e}get(...e){e.length===0&&(e=[0]);let t=0;for(let r of e){if(r<0||r>=this.shape[t]){let s=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(s)}t++}let n=e[e.length-1];for(let r=0;r<e.length-1;++r)n+=this.strides[r]*e[r];return this.values[n]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];let t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return Wr().makeTensor(this.values,this.shape,this.dtype)}},Wr=null,Ou=null,xP=null;function wP(e){Wr=e}function IP(e){Ou=e}function kP(e){xP=e}var Te=class{constructor(e,t,n,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=gt(e),this.strides=uc(e),this.dataId=n,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){let e=await this.data();return Ou.buffer(this.shape,this.dtype,e)}bufferSync(){return Ou.buffer(this.shape,this.dtype,this.dataSync())}async array(){let e=await this.data();return Lu(this.shape,e,this.dtype==="complex64")}arraySync(){return Lu(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();let e=Wr().read(this.dataId);if(this.dtype==="string"){let t=await e;try{return t.map(n=>pf(n))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),Wr().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();let e=Wr().readSync(this.dataId);if(this.dtype==="string")try{return e.map(t=>pf(t))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();let e=await Wr().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(Wr().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return Ou.print(this,e)}clone(){return this.throwIfDisposed(),Ou.clone(this)}toString(e=!1){let t=this.dataSync();return yP(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),Ou.cast(this,e)}variable(e=!0,t,n){return this.throwIfDisposed(),Wr().makeVariable(this,e,t,n)}};Object.defineProperty(Te,Symbol.hasInstance,{value:e=>!!e&&e.data!=null&&e.dataSync!=null&&e.throwIfDisposed!=null});function Q(){return Dx("Tensor",()=>Te)}Q();var fa=class extends Te{constructor(e,t,n,r){super(e.shape,e.dtype,e.dataId,r),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!Os(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);Wr().disposeTensor(this),this.dataId=e.dataId,Wr().incRef(this,null)}dispose(){Wr().disposeVariable(this),this.isDisposedInternal=!0}};Object.defineProperty(fa,Symbol.hasInstance,{value:e=>e instanceof Te&&e.assign!=null&&e.assign instanceof Function});var Gr={};Ee(Gr,{assertTypesMatch:()=>yC,getTensorsInContainer:()=>Fx,isTensorInList:()=>CP,makeTypesMatch:()=>Dt});var Ev;(function(e){e.R0="R0",e.R1="R1",e.R2="R2",e.R3="R3",e.R4="R4",e.R5="R5",e.R6="R6"})(Ev||(Ev={}));var Av;(function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"})(Av||(Av={}));var Dv;(function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"})(Dv||(Dv={}));var $v;(function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"})($v||($v={}));var Fv;(function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"})(Fv||(Fv={}));var SP={float32:$v,int32:Av,bool:Dv,complex64:Fv};function mr(e,t){if(e==="string"||t==="string"){if(e==="string"&&t==="string")return"string";throw new Error(`Can not upcast ${e} with ${t}`)}return SP[e][t]}function em(e){return mr(e,"int32")}function gC(e){return e!=null&&typeof e=="object"&&"texture"in e&&e.texture instanceof WebGLTexture}function bC(e){return typeof GPUBuffer<"u"&&e!=null&&typeof e=="object"&&"buffer"in e&&e.buffer instanceof GPUBuffer}function Dt(e,t){if(e.dtype===t.dtype)return[e,t];let n=mr(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function yC(e,t){A(e.dtype===t.dtype,()=>`The dtypes of the first(${e.dtype}) and second(${t.dtype}) input must match`)}function CP(e,t){return t.some(n=>n.id===e.id)}function Fx(e){let t=[];return vC(e,t,new Set),t}function vC(e,t,n){if(e==null)return;if(e instanceof Te){t.push(e);return}if(!TP(e))return;let r=e;for(let s in r){let a=r[s];n.has(a)||(n.add(a),vC(a,t,n))}}function TP(e){return Array.isArray(e)||typeof e=="object"}function fv(e){return e.kernelName!=null}var hS=class{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(let e in this.registeredVariables)this.registeredVariables[e].dispose()}},Id=class{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new hS}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;let e=this.getSortedBackends();for(let t=0;t<e.length;t++){let n=e[t];if(await this.initializeBackend(n).success){await this.setBackend(n);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){let{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){let{asyncInit:t}=this.initializeBackend(e);if(t)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,n=1){return e in this.registryFactory?(sa(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:n},!0)}async setBackend(e){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;let{success:t,asyncInit:n}=this.initializeBackend(e);if(!(n?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new hP(this.backendInstance),!0}setupRegisteredKernels(){df(this.backendName).forEach(t=>{t.setupFunc!=null&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){df(e).forEach(n=>{n.disposeFunc!=null&&n.disposeFunc(this.registry[e])})}initializeBackend(e){let t=this.registryFactory[e];if(t==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{let n=t.factory();if(n&&!(n instanceof Md)&&typeof n.then=="function"){let r=++this.pendingBackendInitId,s=n.then(a=>r<this.pendingBackendInitId?!1:(this.registry[e]=a,this.pendingBackendInit=null,!0)).catch(a=>(r<this.pendingBackendInitId||(this.pendingBackendInit=null,sa(`Initialization of backend ${e} failed`),sa(a.stack||a.message)),!1));return this.pendingBackendInit=s,{success:s,asyncInit:!0}}else return this.registry[e]=n,{success:!0,asyncInit:!1}}catch(n){return sa(`Initialization of backend ${e} failed`),sa(n.stack||n.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){let e=this.getSortedBackends();for(let t=0;t<e.length;t++){let n=e[t],{success:r,asyncInit:s}=this.initializeBackend(n);if(s||r)return{name:n,asyncInit:s}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){let n=this.state.tensorInfo.get(t),r=n.backend,s=this.readSync(t),a=r.refCount(t);r.disposeData(t,!0),n.backend=e,e.move(t,s,n.shape,n.dtype,a),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let n=null;if(t==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");t=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof t!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");n=e}let r;return this.scopedRun(()=>this.startScope(n),()=>this.endScope(r),()=>(r=t(),r instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),r))}scopedRun(e,t,n){e();try{let r=n();return t(),r}catch(r){throw t(),r}}nextTensorId(){return Id.nextTensorId++}nextVariableId(){return Id.nextVariableId++}clone(e){let t=M.runKernel(si,{x:e}),n={x:e},r=a=>({x:()=>{let o="float32",i={x:a},u={dtype:o};return M.runKernel(zo,i,u)}}),s=[];return this.addTapeNode(this.state.activeScope.name,n,[t],r,s,{}),t}runKernel(e,t,n){if(this.backendName==null&&this.backend,!(xd(e,this.backendName)!=null))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,n){let r=this.backend.numDataIds(),s=0;n.forEach(i=>{s+=i.dtype==="complex64"?3:1});let a=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],o=r-t-s-a;if(o>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${o} data ids) after running '${e}'`)}runKernelFunc(e){let t,n=[],r=this.isTapeOn(),s=this.state.numBytes,a=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let o;this.backendName==null&&this.backend;let i,u=fv(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(fv(e)){let{kernelName:h,inputs:f,attrs:g}=e;this.backendName==null&&this.backend;let m=xd(h,this.backendName);A(m!=null,()=>`Cannot find registered kernel '${h}' for backend '${this.backendName}'`),o=()=>{let b=this.backend.numDataIds();i=m.kernelFunc({inputs:f,attrs:g,backend:this.backend});let v=Array.isArray(i)?i:[i];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(h,b,v);let y=v.map(x=>x.rank!=null?x:this.makeTensorFromTensorInfo(x));if(r){let x=this.getTensorsForGradient(h,f,y);n=this.saveTensorsForBackwardMode(x)}return y}}else{let{forwardFunc:h}=e,f=g=>{r&&(n=g.map(m=>this.keep(this.clone(m))))};o=()=>{let g=this.backend.numDataIds();i=this.tidy(()=>h(this.backend,f));let m=Array.isArray(i)?i:[i];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(u,g,m),m}}let{inputs:c,attrs:l}=e,p=fv(e)?null:e.backwardsFunc,d;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?t=o():(d=this.profiler.profileKernel(u,c,()=>o()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(d),t=d.outputs)}),r&&this.addTapeNode(u,c,t,p,n,l),this.state.profiling&&this.state.activeProfile.kernels.push({name:u,bytesAdded:this.state.numBytes-s,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-a,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(c).map(h=>c[h]!=null?c[h].shape:null),outputShapes:t.map(h=>h.shape),kernelTimeMs:d.timeMs,extraInfo:d.extraInfo}),Array.isArray(i)?t:t[0]}saveTensorsForBackwardMode(e){return e.map(n=>this.keep(this.clone(n)))}getTensorsForGradient(e,t,n){let r=Nv(e);if(r!=null){let s=r.inputsToSave||[],a=r.outputsToSave||[],o;r.saveAllInputs?(A(Array.isArray(t),()=>"saveAllInputs is true, expected inputs to be an array."),o=Object.keys(t).map(u=>t[u])):o=s.map(u=>t[u]);let i=n.filter((u,c)=>a[c]);return o.concat(i)}return[]}makeTensor(e,t,n,r){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",r=r||this.backend;let s=e;n==="string"&&aa(e[0])&&(s=e.map(i=>up(i)));let a=r.write(s,t,n),o=new Te(t,n,a,this.nextTensorId());if(this.trackTensor(o,r),n==="string"){let i=this.state.tensorInfo.get(a),u=nC(s);this.state.numBytes+=u-i.bytes,i.bytes=u}return o}makeTensorFromDataId(e,t,n,r){n=n||"float32";let s={dataId:e,shape:t,dtype:n};return this.makeTensorFromTensorInfo(s,r)}makeTensorFromTensorInfo(e,t){let{dataId:n,shape:r,dtype:s}=e,a=new Te(r,s,n,this.nextTensorId());return this.trackTensor(a,t),a}makeVariable(e,t=!0,n,r){n=n||this.nextVariableId().toString(),r!=null&&r!==e.dtype&&(e=e.cast(r));let s=new fa(e,t,n,this.nextTensorId());if(this.state.registeredVariables[s.name]!=null)throw new Error(`Variable with name ${s.name} was already registered`);return this.state.registeredVariables[s.name]=s,this.incRef(s,this.backend),s}trackTensor(e,t){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let n=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(n=e.size*uf(e.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:n})),e instanceof fa||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;let t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){let n=e.size*uf(e.dtype);this.state.numBytes-=n}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(let e in this.state.registeredVariables){let t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){let e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;let t=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(r=>r.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-n;for(let r of this.state.activeProfile.kernels)r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,t,n,r,s,a){let o={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:n,saved:s},i=Nv(e);i!=null&&(r=i.gradFunc),r!=null&&(o.gradient=u=>(u=u.map((c,l)=>{if(c==null){let p=n[l],d=Lf(p.size,p.dtype);return this.makeTensor(d,p.shape,p.dtype)}return c}),r(u.length>1?u:u[0],s,a))),this.state.activeTape.push(o)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){let t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){let t=Fx(e),n=new Set(t.map(s=>s.id));for(let s=0;s<this.state.activeScope.track.length;s++){let a=this.state.activeScope.track[s];!a.kept&&!n.has(a.id)&&a.dispose()}let r=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(s=>{!s.kept&&s.scopeId===r.id&&this.track(s)})}gradients(e,t,n,r=!1){if(A(t.length>0,()=>"gradients() received an empty list of xs."),n!=null&&n.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);let s=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));A(s instanceof Te,()=>"The result y returned by f() must be a tensor.");let a=gP(this.state.activeTape,t,s);if(!r&&a.length===0&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{let o={};o[s.id]=n??NP(s.shape),bP(o,a,u=>this.tidy(u),_P);let i=t.map(u=>o[u.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(u=>{for(let c of u.saved)c.dispose()}),this.state.activeTape=null),{value:s,grads:i}})}customGrad(e){return A(pa(e),()=>"The f passed in customGrad(f) must be a function."),(...t)=>{A(t.every(o=>o instanceof Te),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let n,r={};t.forEach((o,i)=>{r[i]=o});let s=(o,i)=>(n=e(...t,i),A(n.value instanceof Te,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),A(pa(n.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),n.value),a=(o,i)=>{let u=n.gradFunc(o,i),c=Array.isArray(u)?u:[u];A(c.length===t.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),A(c.every(p=>p instanceof Te),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");let l={};return c.forEach((p,d)=>{l[d]=()=>p}),l};return this.runKernelFunc({forwardFunc:s,backwardsFunc:a,inputs:r})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){let t=wd(),n=await this.backend.time(e);return n.wallMs=wd()-t,n}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new hS;for(let e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}};Id.nextTensorId=0;Id.nextVariableId=0;function NP(e){let t=Ex(gt(e),"float32");return M.makeTensor(t,e,"float32")}function xC(){let e=iC();if(e._tfengine==null){let t=new oC(e);e._tfengine=new Id(t)}return XR(e._tfengine.ENV),wP(()=>e._tfengine),e._tfengine}var M=xC();function _P(e,t){let n={a:e,b:t};return M.runKernel(Sa,n)}var cp={};Ee(cp,{isBrowser:()=>wC,isMobile:()=>DP,mockIsMobile:()=>AP});function EP(){return typeof navigator<"u"&&navigator!=null}var Rv;function AP(e){Rv=e}function DP(e){if(Rv!==void 0)return Rv;if(e||EP()){if(e||(e=navigator),e.product==="ReactNative")return!0;let t=e.userAgent||e.vendor||(typeof window<"u"?window.opera:"");if(!t){let n=e;return n.userAgentData&&n.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function wC(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}var Wn=G();Wn.registerFlag("DEBUG",()=>!1,e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});Wn.registerFlag("IS_BROWSER",()=>wC());Wn.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");Wn.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));Wn.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));Wn.registerFlag("PROD",()=>!1);Wn.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>Wn.getBool("DEBUG"));Wn.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);Wn.registerFlag("IS_TEST",()=>!1);Wn.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>Wn.getBool("DEBUG"));Wn.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);Wn.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);Wn.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);function ds(e,t){let n=e;if(nn(e))return t==="string"?[]:[e.length];if(gC(e)){let s=e.channels||"RGBA";return[e.height,e.width*s.length]}else if(bC(e))return[e.buffer.size/(t==null?4:uf(t))];if(!Array.isArray(e))return[];let r=[];for(;Array.isArray(n)||nn(n)&&t!=="string";)r.push(n.length),n=n[0];return Array.isArray(e)&&G().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&IC(e,r,[]),r}function IC(e,t,n){if(n=n||[],!Array.isArray(e)&&!nn(e)){A(t.length===0,()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);return}A(t.length>0,()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${e.length} elements`),A(e.length===t[0],()=>`Element arr[${n.join("][")}] should have ${t[0]} elements, but has ${e.length} elements`);let r=t.slice(1);for(let s=0;s<e.length;++s)IC(e[s],r,n.concat(s))}function fS(e,t,n,r){if(e!=="string_or_numeric"){if(e==null)throw new Error("Expected dtype cannot be null.");if(e!=="numeric"&&e!==t||e==="numeric"&&t==="string")throw new Error(`Argument '${n}' passed to '${r}' must be ${e} tensor, but got ${t} tensor`)}}function _(e,t,n,r="numeric"){if(e instanceof Te)return fS(r,e.dtype,t,n),e;let s=Ld(e);if(s!=="string"&&["bool","int32","float32"].indexOf(r)>=0&&(s=r),fS(r,s,t,n),e==null||!nn(e)&&!Array.isArray(e)&&typeof e!="number"&&typeof e!="boolean"&&typeof e!="string"){let u=e==null?"null":e.constructor.name;throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${u}'`)}let a=ds(e,s);!nn(e)&&!Array.isArray(e)&&(e=[e]);let i=s!=="string"?Qf(e,s):ha(e,[],!0);return M.makeTensor(i,a,s)}function kd(e,t,n,r="numeric"){if(!Array.isArray(e))throw new Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return e.map((a,o)=>_(a,`${t}[${o}]`,n,r))}var Rx="__op";function z(e){let t=Object.keys(e);if(t.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let n=t[0],r=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n=n+Rx;let s=(...a)=>{M.startScope(n);try{let o=r(...a);return zf(o)&&console.error("Cannot return a Promise inside of tidy."),M.endScope(o),o}catch(o){throw M.endScope(null),o}};return Object.defineProperty(s,"name",{value:n,configurable:!0}),s}function $P(e,t){let n=_(e,"real","complex"),r=_(t,"imag","complex");En(n.shape,r.shape,`real and imag shapes, ${n.shape} and ${r.shape}, must match in call to tf.complex().`);let s={real:n,imag:r};return M.runKernel(Bf,s)}var Rs=z({complex_:$P});function _a(e,t,n,r){if(r==null)r=Ld(e);else if(r==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(bC(e)||gC(e)){if(r!=="float32"&&r!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${r}.`);return M.backend.createTensorFromGPUData(e,t||n,r)}if(!nn(e)&&!Array.isArray(e)&&typeof e!="number"&&typeof e!="boolean"&&typeof e!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(t!=null){or(t);let s=gt(t),a=gt(n);A(s===a,()=>`Based on the provided shape, [${t}], the tensor should have ${s} values but has ${a}`);for(let o=0;o<n.length;++o){let i=n[o],u=o===n.length-1?i!==gt(t.slice(o)):!0;A(n[o]===t[o]||!u,()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `)}}return!nn(e)&&!Array.isArray(e)&&(e=[e]),t=t||n,e=r!=="string"?Qf(e,r):ha(e,[],!0),M.makeTensor(e,t,r)}function yn(e,t,n){let r=ds(e,n);return _a(e,t,r,n)}var Pv={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8},fs=class{static join(e){return new fs(e).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,e==null||(e instanceof Array||(e=[e]),e=e.map(n=>nn(n)?n.buffer:n),e.length===0))return;this.bufferUniformSize=e[0].byteLength;let t=0;for(let n=0;n<e.length;n++){let r=e[n];n!==e.length-1&&r.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);let s=t+r.byteLength;this.shards.push({buffer:r,start:t,end:s}),t=s}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(e=0,t=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(e=isNaN(Number(e))?0:e,t=isNaN(Number(t))?0:t,e=Math.max(0,e),t=Math.min(this.byteLength,t),t<=e)return new ArrayBuffer(0);let n=this.findShardForByte(e);if(n===-1)throw new Error(`Could not find start shard for byte ${e}`);let r=t-e,s=new ArrayBuffer(r),a=new Uint8Array(s),o=0;for(let i=n;i<this.shards.length;i++){let u=this.shards[i],l=e+o-u.start,p=o,h=Math.min(t,u.end)-u.start,f=new Uint8Array(u.buffer,l,h-l);if(a.set(f,p),o+=f.length,t<u.end)break}return s}findShardForByte(e){if(this.shards.length===0||e<0||e>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function t(r){return e<r.start?-1:e>=r.end?1:0}if(t(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;let n=FP(this.shards,t);return n===-1?-1:(this.previousShardIndex=n,this.previousShardIndex)}};function FP(e,t){let n=0,r=e.length;for(;n<=r;){let s=Math.floor((r-n)/2)+n,a=t(e[s]);if(a===0)return s;a<0?r=s:n=s+1}return-1}var hf=4;async function RP(e,t){let n=[],r=[],s=Array.isArray(e)?e.map(o=>o.name):Object.keys(e);for(let o=0;o<s.length;++o){let i=s[o],u=Array.isArray(e)?e[o].tensor:e[i];if(u.dtype!=="float32"&&u.dtype!=="int32"&&u.dtype!=="bool"&&u.dtype!=="string"&&u.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${i}': ${u.dtype}`);let c={name:i,shape:u.shape,dtype:u.dtype};if(u.dtype==="string"){let l=new Promise(async p=>{let d=await u.bytes(),h=d.reduce((m,b)=>m+b.length,0)+hf*d.length,f=new Uint8Array(h),g=0;for(let m=0;m<d.length;m++){let b=d[m],v=new Uint8Array(new Uint32Array([b.length]).buffer);f.set(v,g),g+=hf,f.set(b,g),g+=b.length}p(f)});r.push(l)}else r.push(u.data());t!=null&&(c.group=t),n.push(c)}let a=await Promise.all(r);return{data:PP(a),specs:n}}function kC(e,t){let n=new fs(e),r={},s,a=0;for(let o of t){let i=o.name,u=o.dtype,c=o.shape,l=gt(c),p;if("quantization"in o){let d=o.quantization;if(d.dtype==="uint8"||d.dtype==="uint16"){if(!("min"in d&&"scale"in d))throw new Error(`Weight ${o.name} with quantization ${d.dtype} doesn't have corresponding metadata min and scale.`)}else if(d.dtype==="float16"){if(u!=="float32")throw new Error(`Weight ${o.name} is quantized with ${d.dtype} which only supports weights of type float32 not ${u}.`)}else throw new Error(`Weight ${o.name} has unknown quantization dtype ${d.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);let h=Pv[d.dtype],f=n.slice(a,a+l*h),g=d.dtype==="uint8"?new Uint8Array(f):new Uint16Array(f);if(u==="float32")if(d.dtype==="uint8"||d.dtype==="uint16"){p=new Float32Array(g.length);for(let m=0;m<g.length;m++){let b=g[m];p[m]=b*d.scale+d.min}}else if(d.dtype==="float16")s===void 0&&(s=VP()),p=s(g);else throw new Error(`Unsupported quantization type ${d.dtype} for weight type float32.`);else if(u==="int32"){if(d.dtype!=="uint8"&&d.dtype!=="uint16")throw new Error(`Unsupported quantization type ${d.dtype} for weight type int32.`);p=new Int32Array(g.length);for(let m=0;m<g.length;m++){let b=g[m];p[m]=Math.round(b*d.scale+d.min)}}else throw new Error(`Unsupported dtype in weight '${i}': ${u}`);a+=l*h}else if(u==="string"){let d=gt(o.shape);p=[];for(let h=0;h<d;h++){let f=new Uint32Array(n.slice(a,a+hf))[0];a+=hf;let g=new Uint8Array(n.slice(a,a+f));p.push(g),a+=f}}else{let d=Pv[u],h=n.slice(a,a+l*d);if(u==="float32")p=new Float32Array(h);else if(u==="int32")p=new Int32Array(h);else if(u==="bool")p=new Uint8Array(h);else if(u==="complex64"){p=new Float32Array(h);let f=new Float32Array(p.length/2),g=new Float32Array(p.length/2);for(let v=0;v<f.length;v++)f[v]=p[v*2],g[v]=p[v*2+1];let m=yn(f,c,"float32"),b=yn(g,c,"float32");r[i]=Rs(m,b),m.dispose(),b.dispose()}else throw new Error(`Unsupported dtype in weight '${i}': ${u}`);a+=l*d}u!=="complex64"&&(r[i]=yn(p,c,u))}return r}function PP(e){if(e===null)throw new Error(`Invalid input value: ${JSON.stringify(e)}`);let t=0,n=[];e.forEach(a=>{if(t+=a.byteLength,n.push(a.byteLength===a.buffer.byteLength?a:new a.constructor(a)),!(a instanceof Float32Array||a instanceof Int32Array||a instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${a.constructor.name}`)});let r=new Uint8Array(t),s=0;return n.forEach(a=>{r.set(new Uint8Array(a.buffer),s),s+=a.byteLength}),r.buffer}var Px=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function mS(e){return Px?Buffer.byteLength(e,"utf8"):new Blob([e]).size}function OP(e){if(Px)return Buffer.from(e).toString("base64");let t=new Uint8Array(e),n="";for(let r=0,s=t.length;r<s;r++)n+=String.fromCharCode(t[r]);return btoa(n)}function MP(e){if(Px){let r=Buffer.from(e,"base64");return r.buffer.slice(r.byteOffset,r.byteOffset+r.byteLength)}let t=atob(e),n=new Uint8Array(t.length);for(let r=0;r<t.length;++r)n.set([t.charCodeAt(r)],r);return n.buffer}function LP(e){return fs.join(e)}function gS(e){let t="/";for(e=e.trim();e.endsWith(t);)e=e.slice(0,e.length-1);let n=e.split(t);return n[n.length-1]}function SC(e,t){let n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return e.signature!=null&&(n.signature=e.signature),e.userDefinedMetadata!=null&&(n.userDefinedMetadata=e.userDefinedMetadata),e.modelInitializer!=null&&(n.modelInitializer=e.modelInitializer),e.initializerSignature!=null&&(n.initializerSignature=e.initializerSignature),e.trainingConfig!=null&&(n.trainingConfig=e.trainingConfig),n}function CC(e,t,n){let r={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(e.trainingConfig!=null&&(r.trainingConfig=e.trainingConfig),e.weightsManifest!=null){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=t,r.weightData=n}return e.signature!=null&&(r.signature=e.signature),e.userDefinedMetadata!=null&&(r.userDefinedMetadata=e.userDefinedMetadata),e.modelInitializer!=null&&(r.modelInitializer=e.modelInitializer),e.initializerSignature!=null&&(r.initializerSignature=e.initializerSignature),r}async function Ox(e,t){let n,r;return e.weightsManifest!=null&&([n,r]=await t(e.weightsManifest)),CC(e,n,r)}function lp(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:e.modelTopology==null?0:mS(JSON.stringify(e.modelTopology)),weightSpecsBytes:e.weightSpecs==null?0:mS(JSON.stringify(e.weightSpecs)),weightDataBytes:e.weightData==null?0:new fs(e.weightData).byteLength}}function TC(e){let t=[];for(let n of e)t.push(...n.weights);return t}function zP(){let e=n=>{let r=n<<13,s=0;for(;!(r&8388608);)s-=8388608,r<<=1;return r&=-8388609,s+=947912704,r|s},t=new Uint32Array(2048);t[0]=0;for(let n=1;n<1024;n++)t[n]=e(n);for(let n=1024;n<2048;n++)t[n]=939524096+(n-1024<<13);return t}function BP(){let e=new Uint32Array(64);e[0]=0,e[31]=1199570944,e[32]=2147483648,e[63]=3347054592;for(let t=1;t<31;t++)e[t]=t<<23;for(let t=33;t<63;t++)e[t]=2147483648+(t-32<<23);return e}function WP(){let e=new Uint32Array(64);for(let t=0;t<64;t++)e[t]=1024;return e[0]=e[32]=0,e}function VP(){let e=zP(),t=BP(),n=WP();return r=>{let s=new ArrayBuffer(4*r.length),a=new Uint32Array(s);for(let o=0;o<r.length;o++){let i=r[o],u=e[n[i>>10]+(i&1023)]+t[i>>10];a[o]=u}return new Float32Array(s)}}var Ft=class{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return Ft.instance==null&&(Ft.instance=new Ft),Ft.instance}static registerSaveRouter(e){Ft.getInstance().saveRouters.push(e)}static registerLoadRouter(e){Ft.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return Ft.getHandlers(e,"save")}static getLoadHandlers(e,t){return Ft.getHandlers(e,"load",t)}static getHandlers(e,t,n){let r=[];return(t==="load"?Ft.getInstance().loadRouters:Ft.getInstance().saveRouters).forEach(a=>{let o=a(e,n);o!==null&&r.push(o)}),r}},UP=e=>Ft.registerSaveRouter(e),GP=e=>Ft.registerLoadRouter(e),HP=e=>Ft.getSaveHandlers(e),jP=(e,t)=>Ft.getLoadHandlers(e,t),Ov="tensorflowjs",Mv=1,ro="models_store",oa="model_info_store";function NC(){if(!G().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");let e=typeof window>"u"?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(t==null)throw new Error("The current browser does not appear to support IndexedDB.");return t}function Lv(e){let t=e.result;t.createObjectStore(ro,{keyPath:"modelPath"}),t.createObjectStore(oa,{keyPath:"modelPath"})}var ho=class{constructor(e){if(this.indexedDB=NC(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((n,r)=>{let s=this.indexedDB.open(Ov,Mv);s.onupgradeneeded=()=>Lv(s),s.onsuccess=()=>{let a=s.result;if(t==null){let o=a.transaction(ro,"readonly"),u=o.objectStore(ro).get(this.modelPath);u.onsuccess=()=>{if(u.result==null)return a.close(),r(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));n(u.result.modelArtifacts)},u.onerror=c=>(a.close(),r(u.error)),o.oncomplete=()=>a.close()}else{t.weightData=fs.join(t.weightData);let o=lp(t),i=a.transaction(oa,"readwrite"),u=i.objectStore(oa),c;try{c=u.put({modelPath:this.modelPath,modelArtifactsInfo:o})}catch(p){return r(p)}let l;c.onsuccess=()=>{l=a.transaction(ro,"readwrite");let p=l.objectStore(ro),d;try{d=p.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:o})}catch(h){return r(h)}d.onsuccess=()=>n({modelArtifactsInfo:o}),d.onerror=h=>{u=i.objectStore(oa);let f=u.delete(this.modelPath);f.onsuccess=()=>(a.close(),r(d.error)),f.onerror=g=>(a.close(),r(d.error))}},c.onerror=p=>(a.close(),r(c.error)),i.oncomplete=()=>{l==null?a.close():l.oncomplete=()=>a.close()}}},s.onerror=a=>r(s.error)})}};ho.URL_SCHEME="indexeddb://";var _C=e=>G().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(ho.URL_SCHEME)?qP(e.slice(ho.URL_SCHEME.length)):null;Ft.registerSaveRouter(_C);Ft.registerLoadRouter(_C);function qP(e){return new ho(e)}function KP(e){return e.startsWith(ho.URL_SCHEME)?e.slice(ho.URL_SCHEME.length):e}var XP=class{constructor(){this.indexedDB=NC()}async listModels(){return new Promise((e,t)=>{let n=this.indexedDB.open(Ov,Mv);n.onupgradeneeded=()=>Lv(n),n.onsuccess=()=>{let r=n.result,s=r.transaction(oa,"readonly"),o=s.objectStore(oa).getAll();o.onsuccess=()=>{let i={};for(let u of o.result)i[u.modelPath]=u.modelArtifactsInfo;e(i)},o.onerror=i=>(r.close(),t(o.error)),s.oncomplete=()=>r.close()},n.onerror=r=>t(n.error)})}async removeModel(e){return e=KP(e),new Promise((t,n)=>{let r=this.indexedDB.open(Ov,Mv);r.onupgradeneeded=()=>Lv(r),r.onsuccess=()=>{let s=r.result,a=s.transaction(oa,"readwrite"),o=a.objectStore(oa),i=o.get(e),u;i.onsuccess=()=>{if(i.result==null)return s.close(),n(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{let c=o.delete(e),l=()=>{u=s.transaction(ro,"readwrite");let d=u.objectStore(ro).delete(e);d.onsuccess=()=>t(i.result.modelArtifactsInfo),d.onerror=h=>n(i.error)};c.onsuccess=l,c.onerror=p=>(l(),s.close(),n(i.error))}},i.onerror=c=>(s.close(),n(i.error)),a.oncomplete=()=>{u==null?s.close():u.oncomplete=()=>s.close()}},r.onerror=s=>n(r.error)})}},Ds="/",Mu="tensorflowjs_models",EC="info",YP="model_topology",ZP="weight_specs",JP="weight_data",QP="model_metadata";function AC(e){return{info:[Mu,e,EC].join(Ds),topology:[Mu,e,YP].join(Ds),weightSpecs:[Mu,e,ZP].join(Ds),weightData:[Mu,e,JP].join(Ds),modelMetadata:[Mu,e,QP].join(Ds)}}function DC(e){for(let t of Object.values(e))window.localStorage.removeItem(t)}function eO(e){let t=e.split(Ds);if(t.length<3)throw new Error(`Invalid key format: ${e}`);return t.slice(1,t.length-1).join(Ds)}function tO(e){return e.startsWith(fo.URL_SCHEME)?e.slice(fo.URL_SCHEME.length):e}var fo=class{constructor(e){if(!G().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=AC(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{let t=JSON.stringify(e.modelTopology),n=JSON.stringify(e.weightSpecs),r=lp(e),s=fs.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,OP(s));let a={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,initializerSignature:e.initializerSignature!=null?e.initializerSignature:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(a)),{modelArtifactsInfo:r}}catch{throw DC(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){let e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");let t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(n==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=n;let r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(r==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=r;let s=this.LS.getItem(this.keys.modelMetadata);if(s!=null){let o=JSON.parse(s);t.format=o.format,t.generatedBy=o.generatedBy,t.convertedBy=o.convertedBy,o.signature!=null&&(t.signature=o.signature),o.userDefinedMetadata!=null&&(t.userDefinedMetadata=o.userDefinedMetadata),o.modelInitializer!=null&&(t.modelInitializer=o.modelInitializer),o.initializerSignature!=null&&(t.initializerSignature=o.initializerSignature),o.trainingConfig!=null&&(t.trainingConfig=o.trainingConfig)}let a=this.LS.getItem(this.keys.weightData);if(a==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=MP(a),t}};fo.URL_SCHEME="localstorage://";var $C=e=>G().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(fo.URL_SCHEME)?nO(e.slice(fo.URL_SCHEME.length)):null;Ft.registerSaveRouter($C);Ft.registerLoadRouter($C);function nO(e){return new fo(e)}var rO=class{constructor(){A(G().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),A(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){let e={},t=Mu+Ds,n=Ds+EC;for(let r=0;r<this.LS.length;++r){let s=this.LS.key(r);if(s.startsWith(t)&&s.endsWith(n)){let a=eO(s);e[a]=JSON.parse(this.LS.getItem(s))}}return e}async removeModel(e){e=tO(e);let t=AC(e);if(this.LS.getItem(t.info)==null)throw new Error(`Cannot find model at path '${e}'`);let n=JSON.parse(this.LS.getItem(t.info));return DC(t),n}},zu="://",On=class{constructor(){this.managers={}}static getInstance(){return On.instance==null&&(On.instance=new On),On.instance}static registerManager(e,t){A(e!=null,()=>"scheme must not be undefined or null."),e.endsWith(zu)&&(e=e.slice(0,e.indexOf(zu))),A(e.length>0,()=>"scheme must not be an empty string.");let n=On.getInstance();A(n.managers[e]==null,()=>`A model store manager is already registered for scheme '${e}'.`),n.managers[e]=t}static getManager(e){let t=On.getInstance().managers[e];if(t==null)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(On.getInstance().managers)}};function Jh(e){if(e.indexOf(zu)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${On.getSchemes().join(",")}`);return{scheme:e.split(zu)[0],path:e.split(zu)[1]}}async function FC(e,t,n=!1){A(e!==t,()=>`Old path and new path are the same: '${e}'`);let r=Ft.getLoadHandlers(e);A(r.length>0,()=>`Copying failed because no load handler is found for source URL ${e}.`),A(r.length<2,()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${e}.`);let s=r[0],a=Ft.getSaveHandlers(t);A(a.length>0,()=>`Copying failed because no save handler is found for destination URL ${t}.`),A(a.length<2,()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${t}.`);let o=a[0],i=Jh(e).scheme,u=Jh(e).path,c=i===Jh(e).scheme,l=await s.load();n&&c&&await On.getManager(i).removeModel(u);let p=await o.save(l);return n&&!c&&await On.getManager(i).removeModel(u),p.modelArtifactsInfo}async function sO(){let e=On.getSchemes(),t={};for(let n of e){let r=await On.getManager(n).listModels();for(let s in r){let a=n+zu+s;t[a]=r[s]}}return t}async function aO(e){let t=Jh(e);return On.getManager(t.scheme).removeModel(t.path)}async function oO(e,t){return FC(e,t,!1)}async function iO(e,t){return FC(e,t,!0)}var uO=class{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){if(typeof window>"u"||!G().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(e,t);return}this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",n=>{if(n.source===window&&n.data.name===this.messageName){n.stopPropagation();let r=this.functionRefs[n.data.index];r(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(e){return pC(e)}};if(G().get("IS_BROWSER")){G().setPlatform("browser",new uO);try{On.registerManager(fo.URL_SCHEME,new rO)}catch{}try{On.registerManager(ho.URL_SCHEME,new XP)}catch{}}var cO={importFetch:()=>pR()},mv,lO=class{constructor(){this.util=hR(),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return G().global.fetch!=null?G().global.fetch(e,t):(mv==null&&(mv=cO.importFetch()),mv(e,t))}now(){let e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return e.length===0?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}};G().get("IS_NODE")&&!G().get("IS_BROWSER")&&G().setPlatform("node",new lO);function ze(e,t="float32",n){return t=t||"float32",or(e),new Vt(e,t,n)}function dO(e,t){let n=_(e,"x","cast");if(!tC(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if(t==="string"&&n.dtype!=="string"||t!=="string"&&n.dtype==="string")throw new Error("Only strings can be casted to strings");let r={x:n},s={dtype:t};return M.runKernel(zo,r,s)}var ae=z({cast_:dO});function pO(e){let n={x:_(e,"x","clone","string_or_numeric")};return M.runKernel(si,n)}var us=z({clone_:pO});function Mx(e,t=!1){console.log(e.toString(t))}xC();var hO={buffer:ze,cast:ae,clone:us,print:Mx};IP(hO);function fO(){G().set("PROD",!0)}function mO(){G().set("DEBUG",!0)}function gO(){G().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function Lx(e){G().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}kP(Lx);function bO(){M.disposeVariables()}function Dr(){return M}function ff(){return M.memory()}function yO(e){return M.profile(e)}function O(e,t){return M.tidy(e,t)}function _e(e){Fx(e).forEach(n=>n.dispose())}function qt(e){return M.keep(e)}function vO(e){return M.time(e)}function xO(e){return M.setBackend(e)}function wO(){return M.ready()}function IO(){return M.backendName}function kO(e){M.removeBackend(e)}function SO(e){return M.findBackend(e)}function CO(e){return M.findBackendFactory(e)}function tm(e,t,n=1){return M.registerBackend(e,t,n)}function RC(){return M.backend}function TO(e,t){G().setPlatform(e,t)}function NO(e,t){let n=_(e,"a","add"),r=_(t,"b","add");[n,r]=Dt(n,r);let s={a:n,b:r};return M.runKernel(Sa,s)}var X=z({add_:NO});function _O(e,t){let n=_(e,"a","floorDiv"),r=_(t,"b","floorDiv");[n,r]=Dt(n,r);let s={a:n,b:r};return M.runKernel(ti,s)}var nm=z({floorDiv_:_O});function EO(e,t){let n=_(e,"a","div"),r=_(t,"b","div");if([n,r]=Dt(n,r),n.dtype==="int32"&&r.dtype==="int32")return nm(n,r);let s={a:n,b:r},a={};return M.runKernel(Xo,s,a)}var fe=z({div_:EO});function AO(e,t){let n=_(e,"a","mul"),r=_(t,"b","mul");[n,r]=Dt(n,r);let s={a:n,b:r};return M.runKernel(xi,s)}var B=z({mul_:AO});function DO(e){let t=_(e,"x","abs");if(t.dtype==="complex64"){let n={x:t};return M.runKernel(Vd,n)}else{let n={x:t};return M.runKernel(cc,n)}}var Bt=z({abs_:DO});function $O(e){let n={x:_(e,"x","acos")};return M.runKernel(Eo,n)}var zx=z({acos_:$O});function FO(e){let n={x:_(e,"x","acosh")};return M.runKernel(Ao,n)}var Bx=z({acosh_:FO});function RO(e){A(Array.isArray(e),()=>"The argument passed to tf.addN() must be a list of tensors"),A(e.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${e.length}`);let t=e.map((s,a)=>_(s,`tensors${a}`,"addN")),n=t[0];t.forEach(s=>{if(s.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),t.forEach(s=>{if(!Os(s.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});let r=t;return M.runKernel(Do,r)}var PC=z({addN_:RO});function PO(e,t=null,n=!1){let s={x:_(e,"x","all","bool")},a={axis:t,keepDims:n};return M.runKernel(lc,s,a)}var rm=z({all_:PO});function OO(e,t=null,n=!1){let s={x:_(e,"x","any","bool")},a={axis:t,keepDims:n};return M.runKernel(dc,s,a)}var Sd=z({any_:OO});function MO(e,t=0){let r={x:_(e,"x","argMax")},s={axis:t};return M.runKernel(pc,r,s)}var mo=z({argMax_:MO});function LO(e,t=0){let r={x:_(e,"x","argMin")},s={axis:t};return M.runKernel(hc,r,s)}var Wx=z({argMin_:LO});function zO(e){let n={x:_(e,"x","asin")};return M.runKernel($o,n)}var Vx=z({asin_:zO});function BO(e){let n={x:_(e,"x","asinh")};return M.runKernel(Fo,n)}var Ux=z({asinh_:BO});function WO(e){let n={x:_(e,"x","atan")};return M.runKernel(Ro,n)}var Gx=z({atan_:WO});function VO(e,t){let n=_(e,"a","atan2"),r=_(t,"b","atan2");[n,r]=Dt(n,r);let s={a:n,b:r};return M.runKernel(Oo,s)}var Hx=z({atan2_:VO});function UO(e){let n={x:_(e,"x","atanh")};return M.runKernel(Po,n)}var jx=z({atanh_:UO});function GO(e,t,n,r,s="NHWC",a){let o=e[3],i=[...t,o],u=LC(s);return dp(e,i,n,a,r,null,null,u)}function OC(e,t,n,r,s,a,o="channelsLast"){let[i,u]=Cd(t),c;if(o==="channelsLast")c=[i,u,e[3],e[3]];else if(o==="channelsFirst")c=[i,u,e[1],e[1]];else throw new Error(`Unknown dataFormat ${o}`);return dp(e,c,n,r,s,a,!1,o)}function HO(e,t,n,r,s,a,o="NDHWC"){let[i,u,c]=zv(t),l,p;if(o==="NDHWC")p="channelsLast",l=[i,u,c,e[4],e[4]];else if(o==="NCDHW")p="channelsFirst",l=[i,u,c,e[1],e[1]];else throw new Error(`Unknown dataFormat ${o}`);return MC(e,l,n,r,s,!1,p,a)}function dp(e,t,n,r,s,a,o=!1,i="channelsLast"){let[u,c,l,p]=[-1,-1,-1,-1];if(i==="channelsLast")[u,c,l,p]=e;else if(i==="channelsFirst")[u,p,c,l]=e;else throw new Error(`Unknown dataFormat ${i}`);let[d,h,,f]=t,[g,m]=Cd(n),[b,v]=Cd(r),y=Bu(d,b),x=Bu(h,v),{padInfo:k,outHeight:S,outWidth:N}=KO(s,c,l,g,m,y,x,a,i),E=o?f*p:f,$;return i==="channelsFirst"?$=[u,E,S,N]:i==="channelsLast"&&($=[u,S,N,E]),{batchSize:u,dataFormat:i,inHeight:c,inWidth:l,inChannels:p,outHeight:S,outWidth:N,outChannels:E,padInfo:k,strideHeight:g,strideWidth:m,filterHeight:d,filterWidth:h,effectiveFilterHeight:y,effectiveFilterWidth:x,dilationHeight:b,dilationWidth:v,inShape:e,outShape:$,filterShape:t}}function MC(e,t,n,r,s,a=!1,o="channelsLast",i){let[u,c,l,p,d]=[-1,-1,-1,-1,-1];if(o==="channelsLast")[u,c,l,p,d]=e;else if(o==="channelsFirst")[u,d,c,l,p]=e;else throw new Error(`Unknown dataFormat ${o}`);let[h,f,g,,m]=t,[b,v,y]=zv(n),[x,k,S]=zv(r),N=Bu(h,x),E=Bu(f,k),$=Bu(g,S),{padInfo:R,outDepth:D,outHeight:F,outWidth:C}=XO(s,c,l,p,b,v,y,N,E,$,i),L=a?m*d:m,U;return o==="channelsFirst"?U=[u,L,D,F,C]:o==="channelsLast"&&(U=[u,D,F,C,L]),{batchSize:u,dataFormat:o,inDepth:c,inHeight:l,inWidth:p,inChannels:d,outDepth:D,outHeight:F,outWidth:C,outChannels:L,padInfo:R,strideDepth:b,strideHeight:v,strideWidth:y,filterDepth:h,filterHeight:f,filterWidth:g,effectiveFilterDepth:N,effectiveFilterHeight:E,effectiveFilterWidth:$,dilationDepth:x,dilationHeight:k,dilationWidth:S,inShape:e,outShape:U,filterShape:t}}function jO(e,t,n,r,s){r==null&&(r=qx(e,t,n));let a=e[0],o=e[1],i=Td((a-t+2*r)/n+1,s),u=Td((o-t+2*r)/n+1,s);return[i,u]}function qO(e,t,n,r,s,a){s==null&&(s=qx(e,t[0],r[0]));let o=[0,0,0,n];for(let i=0;i<3;i++)e[i]+2*s>=t[i]&&(o[i]=Td((e[i]-t[i]+2*s)/r[i]+1,a));return o}function qx(e,t,n,r=1){let s=Bu(t,r);return Math.floor((e[0]*(n-1)-n+s)/2)}function Cd(e){return typeof e=="number"?[e,e,e]:e.length===2?[e[0],e[1],1]:e}function zv(e){return typeof e=="number"?[e,e,e]:e}function Bu(e,t){return t<=1?e:e+(e-1)*(t-1)}function KO(e,t,n,r,s,a,o,i,u){let c,l,p;if(typeof e=="number"){c={top:e,bottom:e,left:e,right:e,type:e===0?"VALID":"NUMBER"};let h=jO([t,n],a,r,e,i);l=h[0],p=h[1]}else if(e==="same"){l=Math.ceil(t/r),p=Math.ceil(n/s);let d=Math.max(0,(l-1)*r+a-t),h=Math.max(0,(p-1)*s+o-n),f=Math.floor(d/2),g=d-f,m=Math.floor(h/2),b=h-m;c={top:f,bottom:g,left:m,right:b,type:"SAME"}}else if(e==="valid")c={top:0,bottom:0,left:0,right:0,type:"VALID"},l=Math.ceil((t-a+1)/r),p=Math.ceil((n-o+1)/s);else if(typeof e=="object"){let d=u==="channelsLast"?e[1][0]:e[2][0],h=u==="channelsLast"?e[1][1]:e[2][1],f=u==="channelsLast"?e[2][0]:e[3][0],g=u==="channelsLast"?e[2][1]:e[3][1];c={top:d,bottom:h,left:f,right:g,type:d===0&&h===0&&f===0&&g===0?"VALID":"EXPLICIT"},l=Td((t-a+d+h)/r+1,i),p=Td((n-o+f+g)/s+1,i)}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:c,outHeight:l,outWidth:p}}function XO(e,t,n,r,s,a,o,i,u,c,l){let p,d,h,f;if(e==="valid"&&(e=0),typeof e=="number"){p={top:e,bottom:e,left:e,right:e,front:e,back:e,type:e===0?"VALID":"NUMBER"};let m=qO([t,n,r,1],[i,u,c],1,[s,a,o],e,l);d=m[0],h=m[1],f=m[2]}else if(e==="same"){d=Math.ceil(t/s),h=Math.ceil(n/a),f=Math.ceil(r/o);let g=(d-1)*s+i-t,m=(h-1)*a+u-n,b=(f-1)*o+c-r,v=Math.floor(g/2),y=g-v,x=Math.floor(m/2),k=m-x,S=Math.floor(b/2),N=b-S;p={top:x,bottom:k,left:S,right:N,front:v,back:y,type:"SAME"}}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:p,outDepth:d,outHeight:h,outWidth:f}}function Td(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error(`Unknown roundingMode ${t}`)}}function ma(e){let[t,n,r]=Cd(e);return t===1&&n===1&&r===1}function ms(e,t){return ma(e)||ma(t)}function go(e){return Cd(e).every(t=>t>0)}function LC(e){if(e==="NHWC")return"channelsLast";if(e==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${e}`)}function An(e,t,n){if(n!=null){if(typeof t=="string")throw Error(`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);if(typeof t=="number")A(Vu(t),()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);else if(typeof t=="object")t.forEach(r=>{r.forEach(s=>{A(Vu(s),()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${s}.`)})});else throw Error(`Error in ${e}: Unknown padding parameter: ${t}`)}}function YO(e,t){let r={x:_(e,"x","reshape","string_or_numeric")},s={shape:t};return M.runKernel(qc,r,s)}var W=z({reshape_:YO});function ZO(e,t,n,r,s){let a=_(e,"x","avgPool","float32"),o=1;A(ms(n,o),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`);let i=a,u=!1;a.rank===3&&(u=!0,i=W(a,[1,a.shape[0],a.shape[1],a.shape[2]])),A(i.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${i.rank}.`),An("avgPool",r,s);let c={x:i},l={filterSize:t,strides:n,pad:r,dimRoundingMode:s},p=M.runKernel(Mo,c,l);return p=ae(p,a.dtype),u?W(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var br=z({avgPool_:ZO});function JO(e,t,n,r,s,a="NDHWC"){let o=_(e,"x","avgPool3d","float32"),i=o,u=!1;o.rank===4&&(u=!0,i=W(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),A(i.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${i.rank}.`),A(a==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`),A(typeof n=="number"&&n>0||Array.isArray(n)&&n[0]>0&&n[1]>0&&n[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${n}'`),An("avgPool3d",r,s);let c={x:i},l={filterSize:t,strides:n,pad:r,dimRoundingMode:s,dataFormat:a},p=M.runKernel(fc,c,l);return p=ae(p,i.dtype),u?W(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}var Kx=z({avgPool3d_:JO});function QO(e,t=0){A(e.length>=1,()=>"Pass at least one tensor to concat");let n=kd(e,"tensors","concat","string_or_numeric");if(n[0].dtype==="complex64"&&n.forEach(a=>{if(a.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${a.dtype}. `)}),n.length===1)return us(n[0]);let r=n,s={axis:t};return M.runKernel(yc,r,s)}var tt=z({concat_:QO});function e3(e,t,n=!1,r=!1){let s=_(e,"a","matMul"),a=_(t,"b","matMul");[s,a]=Dt(s,a);let o={a:s,b:a},i={transposeA:n,transposeB:r};return M.runKernel(Lo,o,i)}var Fe=z({matMul_:e3});function t3(e){let n={x:_(e,"x","sigmoid","float32")};return M.runKernel(Li,n)}var hr=z({sigmoid_:t3});function n3(e,t,n){let r=_(e,"x","slice","string_or_numeric");if(r.rank===0)throw new Error("Slicing scalar is not possible");let s={x:r},a={begin:t,size:n};return M.runKernel(el,s,a)}var Ue=z({slice_:n3});function r3(e){let n={x:_(e,"x","tanh","float32")};return M.runKernel(ji,n)}var bo=z({tanh_:r3});function s3(e,t,n,r,s,a){let o=_(e,"forgetBias","basicLSTMCell"),i=_(t,"lstmKernel","basicLSTMCell"),u=_(n,"lstmBias","basicLSTMCell"),c=_(r,"data","basicLSTMCell"),l=_(s,"c","basicLSTMCell"),p=_(a,"h","basicLSTMCell"),d=tt([c,p],1),h=Fe(d,i),f=X(h,u),g=f.shape[0],m=f.shape[1]/4,b=[g,m],v=Ue(f,[0,0],b),y=Ue(f,[0,m],b),x=Ue(f,[0,m*2],b),k=Ue(f,[0,m*3],b),S=X(B(hr(v),bo(y)),B(l,hr(X(o,x)))),N=B(bo(S),hr(k));return[S,N]}var zC=z({basicLSTMCell_:s3});function a3(e,t,n){let r=_(e,"x","batchToSpaceND"),s=t.reduce((i,u)=>i*u);A(r.rank>=1+t.length,()=>`input rank is ${r.rank} but should be > than blockShape.length ${t.length}`),A(n.length===t.length,()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${t.length}`),A(r.shape[0]%s===0,()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${s}`);let a={x:r},o={blockShape:t,crops:n};return M.runKernel(mc,a,o)}var pp=z({batchToSpaceND_:a3});function o3(e){let t;return e.rank===0||e.rank===1?t=W(e,[1,1,1,e.size]):e.rank===2?t=W(e,[1,1,e.shape[0],e.shape[1]]):e.rank===3?t=W(e,[1,e.shape[0],e.shape[1],e.shape[2]]):t=e,t}function i3(e,t,n,r,s,a){a==null&&(a=.001);let o=_(e,"x","batchNorm"),i=_(t,"mean","batchNorm"),u=_(n,"variance","batchNorm"),c;s!=null&&(c=_(s,"scale","batchNorm"));let l;r!=null&&(l=_(r,"offset","batchNorm")),A(i.rank===u.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),A(l==null||i.rank===l.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),A(c==null||i.rank===c.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let d={x:o3(o),scale:c,offset:l,mean:i,variance:u},h={varianceEpsilon:a},f=M.runKernel(ni,d,h);return W(f,o.shape)}var Ea=z({batchNorm_:i3});function u3(e,t,n,r,s,a){let o=_(e,"x","batchNorm"),i=_(t,"mean","batchNorm"),u=_(n,"variance","batchNorm"),c;s!=null&&(c=_(s,"scale","batchNorm"));let l;return r!=null&&(l=_(r,"offset","batchNorm")),A(o.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${o.rank}.`),A(i.rank===2||i.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${i.rank}.`),A(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${u.rank}.`),c!=null&&A(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${c.rank}.`),l!=null&&A(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${l.rank}.`),Ea(o,i,u,l,c,a)}var Xx=z({batchNorm2d_:u3});function c3(e,t,n,r,s,a){let o=_(e,"x","batchNorm"),i=_(t,"mean","batchNorm"),u=_(n,"variance","batchNorm"),c;s!=null&&(c=_(s,"scale","batchNorm"));let l;return r!=null&&(l=_(r,"offset","batchNorm")),A(o.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${o.rank}.`),A(i.rank===3||i.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${i.rank}.`),A(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${u.rank}.`),c!=null&&A(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${c.rank}.`),l!=null&&A(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${l.rank}.`),Ea(o,i,u,l,c,a)}var Yx=z({batchNorm3d_:c3});function l3(e,t,n,r,s,a){let o=_(e,"x","batchNorm"),i=_(t,"mean","batchNorm"),u=_(n,"variance","batchNorm"),c;s!=null&&(c=_(s,"scale","batchNorm"));let l;return r!=null&&(l=_(r,"offset","batchNorm")),A(o.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${o.rank}.`),A(i.rank===4||i.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${i.rank}.`),A(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${u.rank}.`),c!=null&&A(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${c.rank}.`),l!=null&&A(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${l.rank}.`),Ea(o,i,u,l,c,a)}var Zx=z({batchNorm4d_:l3});function d3(e,t,n){let r=_(e,"x","bincount"),s=_(t,"weights","bincount");A(r.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`),A(n>=0,()=>`size must be non-negative, but got ${n}.`),A(s.size===r.size||s.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${s.shape}.`);let a={x:r,weights:s},o={size:n};return M.runKernel(gc,a,o)}var Jx=z({bincount_:d3});function p3(e,t){let n=_(e,"x","bitwiseAnd"),r=_(t,"y","bitwiseAnd");if(!Os(n.shape,r.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${n.shape}, y: ${r.shape}`);if(n.dtype!=="int32"||r.dtype!=="int32")throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${n.dtype} and type of y: ${r.dtype}`);let s={a:n,b:r};return M.runKernel(bc,s)}var BC=z({bitwiseAnd_:p3});function h3(e,t){let n=_(e,"s0","broadcastArgs","int32"),r=_(t,"s1","broadcastArgs","int32");if(n.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n.rank}`);if(r.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);let s={s0:n,s1:r};return M.runKernel(Wd,s)}var WC=z({broadcastArgs_:h3});function f3(e,t){let n=_(e,"broadcastTo","x"),r=n.shape;if(or(t),t.length<n.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`);if(t.length>n.rank){let c=n.shape.slice();for(;c.length<t.length;)c.unshift(1);n=W(n,c)}let s=n.shape,a=Array.from(t);for(let c=t.length-1;c>=0;c--)if(s[c]===t[c])a[c]=1;else if(n.shape[c]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${t}].`);if(a.map((c,l)=>c>1?l:-1).filter(c=>c>=0).length===0)return us(n);let i={x:n},u={reps:a};return M.runKernel(Ta,i,u)}var oo=z({broadcastTo_:f3});function m3(e){let n={x:_(e,"x","ceil","float32")};return M.runKernel(Bo,n)}var Qx=z({ceil_:m3});function xn(e,t,n){or(e),n=n||Ld(t);let r={shape:e,value:t,dtype:n};return M.runKernel(Hd,{},r)}function g3(e,t,n){let r=_(e,"x","clipByValue");if(A(t<=n,()=>`Error in clip: min (${t}) must be less than or equal to max (${n}).`),t===n)return xn(r.shape,t,r.dtype);let s={x:r},a={clipValueMin:t,clipValueMax:n};return M.runKernel(Ca,s,a)}var an=z({clipByValue_:g3});function b3(e){return tt(e,0)}var ew=z({concat1d_:b3});function y3(e,t){return tt(e,t)}var tw=z({concat2d_:y3});function v3(e,t){return tt(e,t)}var nw=z({concat3d_:v3});function x3(e,t){return tt(e,t)}var rw=z({concat4d_:x3});function w3(e,t,n,r,s="NHWC",a=[1,1],o){let i=_(e,"x","conv2d","float32"),u=_(t,"filter","conv2d","float32"),c=i,l=!1;i.rank===3&&(l=!0,c=W(i,[1,i.shape[0],i.shape[1],i.shape[2]])),A(c.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${c.rank}.`),A(u.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${u.rank}.`),An("conv2d",r,o);let p=s==="NHWC"?c.shape[3]:c.shape[1];A(p===u.shape[2],()=>`Error in conv2d: depth of input (${p}) must match input depth for filter ${u.shape[2]}.`),A(ms(n,a),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`),A(go(a),()=>"Error in conv2D: Dilated rates should be larger than 0."),A(go(n),()=>"Error in conv2D: Strides should be larger than 0.");let d={x:c,filter:u},h={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:o},f=M.runKernel(Wo,d,h);return l?W(f,[f.shape[1],f.shape[2],f.shape[3]]):f}var Pt=z({conv2d_:w3});function I3(e,t,n,r,s="NWC",a=1,o){let i=_(e,"x","conv1d"),u=_(t,"filter","conv1d"),c=i,l=!1;i.rank===2&&(l=!0,c=W(i,[1,i.shape[0],i.shape[1]])),A(c.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${c.rank}.`),A(u.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${u.rank}.`),An("conv1d",r,o),A(c.shape[2]===u.shape[1],()=>`Error in conv1d: depth of input (${c.shape[2]}) must match input depth for filter ${u.shape[1]}.`),A(ms(n,a),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${a}'`),A(go(a),()=>"Error in conv1D: Dilated rates should be larger than 0."),A(go(n),()=>"Error in conv1D: Stride should be larger than 0."),A(s==="NWC",()=>`Error in conv1d: got dataFormat of ${s} but only NWC is currently supported.`);let p=W(u,[1,u.shape[0],u.shape[1],u.shape[2]]),d=W(c,[c.shape[0],1,c.shape[1],c.shape[2]]),m=Pt(d,p,[1,n],r,"NHWC",[1,a],o);return l?W(m,[m.shape[2],m.shape[3]]):W(m,[m.shape[0],m.shape[2],m.shape[3]])}var sm=z({conv1d_:I3});function k3(e,t,n,r,s,a="NHWC",o){A(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let i=e,u=t,c=!1;t.rank===3&&(c=!0,u=W(t,[1,t.shape[0],t.shape[1],t.shape[2]]),i=[1,e[0],e[1],e[2]]),A(i.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${i.length}.`),A(u.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${u.rank}`),A(n.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`);let l=a==="NHWC"?i[3]:i[1],p=a==="NHWC"?u.shape[3]:u.shape[1];A(l===n.shape[2],()=>`Error in conv2dDerInput: depth of input (${l}) must match input depth for filter ${n.shape[2]}.`),A(p===n.shape[3],()=>`Error in conv2dDerInput: depth of output (${p}) must match output depth for filter ${n.shape[3]}.`),An("conv2dDerInput",s,o);let d={dy:u,filter:n},h={strides:r,pad:s,dataFormat:a,dimRoundingMode:o,inputShape:i},f=M.runKernel(Vo,d,h);return c?W(f,[f.shape[1],f.shape[2],f.shape[3]]):f}var sw=z({conv2DBackpropInput_:k3});function S3(e,t,n,r,s,a){let o=_(e,"x","conv2dTranspose"),i=_(t,"filter","conv2dTranspose");return sw(n,o,i,r,s,"NHWC",a)}var am=z({conv2dTranspose_:S3});function C3(e,t,n,r,s="NDHWC",a=[1,1,1]){let o=_(e,"x","conv3d"),i=_(t,"filter","conv3d"),u=o,c=!1;o.rank===4&&(c=!0,u=W(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),A(u.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${u.rank}.`),A(i.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${i.rank}.`),A(u.shape[4]===i.shape[3],()=>`Error in conv3d: depth of input (${u.shape[4]}) must match input depth for filter ${i.shape[3]}.`),A(ms(n,a),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`),A(s==="NDHWC",()=>`Error in conv3d: got dataFormat of ${s} but only NDHWC is currently supported.`),A(go(a),()=>"Error in conv3D: Dilated rates should be larger than 0."),A(go(n),()=>"Error in conv3D: Strides should be larger than 0.");let l={x:u,filter:i},p={strides:n,pad:r,dataFormat:s,dilations:a},d=M.runKernel(Uo,l,p);return c?W(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}var aw=z({conv3d_:C3});function T3(e,t,n,r,s){A(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let a=e,o=t,i=!1;t.rank===4&&(i=!0,o=W(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),a=[1,e[0],e[1],e[2],e[3]]);let u=a[4],c=o.shape[4];A(a.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${a.length}.`),A(o.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${o.rank}`),A(n.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`),A(u===n.shape[3],()=>`Error in conv3dDerInput: depth of input (${u}) must match input depth for filter ${n.shape[3]}.`),A(c===n.shape[4],()=>`Error in conv3dDerInput: depth of output (${c}) must match output depth for filter ${n.shape[4]}.`);let l={dy:o,filter:n},p={pad:s,strides:r,inputShape:a},d=M.runKernel(xc,l,p);return i?W(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}var VC=z({conv3DBackpropInput_:T3});function N3(e,t,n,r,s){let a=_(e,"x","conv3dTranspose"),o=_(t,"filter","conv3dTranspose");return VC(n,a,o,r,s)}var ow=z({conv3dTranspose_:N3});function _3(e){let n={x:_(e,"x","cos","float32")};return M.runKernel(Go,n)}var hp=z({cos_:_3});function E3(e){let n={x:_(e,"x","cosh","float32")};return M.runKernel(Ho,n)}var om=z({cosh_:E3});function A3(e,t=0,n=!1,r=!1){let a={x:_(e,"x","cumprod")},o={axis:t,exclusive:n,reverse:r};return M.runKernel(wc,a,o)}var Nd=z({cumprod_:A3});function D3(e,t=0,n=!1,r=!1){let a={x:_(e,"x","cumsum")},o={axis:t,exclusive:n,reverse:r};return M.runKernel(jo,a,o)}var im=z({cumsum_:D3});function $3(e,t,n,r=!1){let s=_(e,"x","denseBincount"),a=_(t,"weights","denseBincount");A(s.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${s.dtype}`),A(s.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${s.rank}.`),A(n>=0,()=>`size must be non-negative, but got ${n}.`),A(a.size===s.size||a.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${s.shape}, weights shape: ${a.shape}.`);let o={x:s,weights:a},i={size:n,binaryOutput:r};return M.runKernel(Ud,o,i)}var mf=z({denseBincount_:$3});function F3(e,t,n="NHWC"){let r=_(e,"x","depthToSpace","float32"),s=n==="NHWC"?r.shape[1]:r.shape[2],a=n==="NHWC"?r.shape[2]:r.shape[3],o=n==="NHWC"?r.shape[3]:r.shape[1];A(t>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`),A(s*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${s} and ${t}  for depthToSpace with input shape
    ${r.shape}`),A(a*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${a} and ${t} for depthToSpace with input shape
        ${r.shape}`),A(o%(t*t)===0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${o} for depthToSpace with input shape ${r.shape}`);let i={x:r},u={blockSize:t,dataFormat:n};return M.runKernel(kc,i,u)}var iw=z({depthToSpace_:F3});function R3(e,t,n,r,s="NHWC",a=[1,1],o){let i=_(e,"x","depthwiseConv2d","float32"),u=_(t,"filter","depthwiseConv2d","float32"),c=i,l=!1;i.rank===3&&(l=!0,c=W(i,[1,i.shape[0],i.shape[1],i.shape[2]])),A(c.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${c.rank}.`),A(u.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${u.rank}.`);let p=s==="NHWC"?c.shape[3]:c.shape[1];A(p===u.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${p}) must match the inChannels dimension in filter ${u.shape[2]}.`),An("depthwiseConv2d",r,o);let d={x:c,filter:u},h={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:o},f=M.runKernel(qo,d,h);return l?W(f,[f.shape[1],f.shape[2],f.shape[3]]):f}var Aa=z({depthwiseConv2d_:R3});function P3(e){let n={x:_(e,"x","diag")};return M.runKernel(Gd,n)}var UC=z({diag_:P3});function O3(e,t,n,r,s=[1,1],a="NHWC"){let o=_(e,"x","dilation2d"),i=_(t,"filter","dilation2d");A(o.rank===3||o.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${o.rank}.`),A(i.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${i.rank}.`),A(a==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${a}`);let u=o,c=!1;o.rank===3&&(u=W(o,[1,o.shape[0],o.shape[1],o.shape[2]]),c=!0),A(u.shape[3]===i.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${u.shape[3]} vs ${i.shape[2]}`);let l={x:u,filter:i},p={strides:n,pad:r,dilations:s},d=M.runKernel(Ko,l,p);return c?W(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var uw=z({dilation2d_:O3}),dl={};Ee(dl,{assertAndGetBroadcastShape:()=>lt,getBroadcastDims:()=>GC,getReductionAxes:()=>Ut});function GC(e,t){let n=e.length,r=[];for(let s=0;s<n;s++){let a=n-1-s,o=e[a]||1;(t[t.length-1-s]||1)>1&&o===1&&r.unshift(a)}return r}function Ut(e,t){let n=[];for(let r=0;r<t.length;r++){let s=e[e.length-r-1],a=t.length-r-1,o=t[a];(s==null||s===1&&o>1)&&n.unshift(a)}return n}function lt(e,t){let n=Math.max(e.length,t.length),r=new Array(n);for(let s=0;s<n;s++){let a=e[e.length-s-1];a==null&&(a=1);let o=t[t.length-s-1];if(o==null&&(o=1),a===1)r[n-s-1]=o;else if(o===1)r[n-s-1]=a;else if(a!==o){let i=`Operands could not be broadcast together with shapes ${e} and ${t}.`;throw Error(i)}else r[n-s-1]=a}return r}function M3(e,t){let n=_(e,"a","equal","string_or_numeric"),r=_(t,"b","equal","string_or_numeric");[n,r]=Dt(n,r),lt(n.shape,r.shape);let s={a:n,b:r};return M.runKernel(Cc,s)}var nr=z({equal_:M3});function L3(e,t,n){let r=_(t,"a","where"),s=_(n,"b","where"),a=_(e,"condition","where","bool"),o=lt(lt(a.shape,r.shape),s.shape),i=oo(a,o),u=oo(r,o),c=oo(s,o),l={condition:i,t:u,e:c};return M.runKernel(Qc,l)}var sn=z({where_:L3});function z3(e){let n={x:_(e,"x","zerosLike")};return M.runKernel(cl,n)}var je=z({zerosLike_:z3});function B3(e,t){let n=_(e,"a","div"),r=_(t,"b","div");[n,r]=Dt(n,r);let s=fe(n,r),a=je(s),o=nr(r,a);return sn(o,a,s)}var cw=z({divNoNan_:B3});function W3(e,t){let n=_(e,"t1","dot"),r=_(t,"t2","dot");A((n.rank===1||n.rank===2)&&(r.rank===1||r.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${r.rank}.`);let s=n.rank===1?n.size:n.shape[1],a=r.rank===1?r.size:r.shape[0];if(A(s===a,()=>`Error in dot: inner dimensions of inputs must match, but got ${s} and ${a}.`),n.rank===1&&r.rank===1){let o=W(n,[1,-1]),i=W(r,[-1,1]),u=Fe(o,i);return W(u,[])}else if(n.rank===1&&r.rank===2){let o=W(n,[1,-1]),i=W(r,[r.shape[0],r.shape[1]]),u=Fe(o,i);return W(u,[u.size])}else if(n.rank===2&&r.rank===1){let o=W(r,[-1,1]),i=Fe(n,o);return W(i,[i.size])}else{let o=W(r,[r.shape[0],r.shape[1]]);return Fe(n,o)}}var lw=z({dot_:W3});function V3(e,...t){let n=t.map((s,a)=>_(s,`tensors${a}`,"einsum")),r={equation:e};return M.runKernel(Hf,n,r)}var Ja=z({einsum_:V3});function U3(e){let n={x:_(e,"x","elu","float32")};return M.runKernel(Yo,n)}var pl=z({elu_:U3});function G3(e,t){let n=_(e,"x","ensureShape","string_or_numeric");if(!Z1(n.shape,t))throw new Error(`EnsureShape: Shape of tensor ${n.shape} is not compatible with expected shape ${t}`);return e}var HC=z({ensureShape_:G3});function H3(e){let t=_(e,"x","erf");A(t.dtype==="int32"||t.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),t.dtype==="int32"&&(t=ae(t,"float32"));let n={x:t};return M.runKernel(Zo,n)}var dw=z({erf_:H3});function pw(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function jC(e,t,n){let r=e.length+t.length,s=[],a=0,o=0;for(let i=0;i<r;i++)n.indexOf(i)===-1?s.push(e[a++]):s.push(t[o++]);return s}function qC(e,t){let n=[],r=e.length;for(let a=0;a<r;a++)t.indexOf(a)===-1&&n.push(e[a]);let s=t.map(a=>e[a]);return[n,s]}function yo(e,t){let n=t.map(r=>1);return jC(e,n,t)}function j3(e,t,n){A(pw(t,n),()=>`${e} supports only inner-most axes for now. Got axes ${t} and rank-${n} input.`)}function KC(e,t){if(pw(e,t))return null;let n=[];for(let r=0;r<t;++r)e.indexOf(r)===-1&&n.push(r);return e.forEach(r=>n.push(r)),n}function hw(e){return e.map((t,n)=>[n,t]).sort((t,n)=>t[1]-n[1]).map(t=>t[0])}function q3(e,t){let n=[];for(let r=t-e;r<t;++r)n.push(r);return n}function K3(e,t=null,n=!1){let s={x:_(e,"x","max")},a={reductionIndices:t,keepDims:n};return M.runKernel(pi,s,a)}var fr=z({max_:K3});function X3(e,t=null,n=!1){let s={x:_(e,"x","min")},a={axis:t,keepDims:n};return M.runKernel(gi,s,a)}var ju=z({min_:X3});function Y3(e,t){let n=_(e,"base","pow"),r=_(t,"exp","pow");[n,r]=Dt(n,r);let s={a:n,b:r};return M.runKernel(ki,s)}var Ps=z({pow_:Y3});function xe(e,t){if((nn(e)&&t!=="string"||Array.isArray(e))&&t!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(t==="string"&&nn(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return _a(e,[],[],t)}function Z3(e){let n={x:_(e,"x","sqrt","float32")};return M.runKernel(Bi,n)}var fn=z({sqrt_:Z3});function J3(e){let t=_(e,"x","square"),n={};return M.runKernel("Square",{x:t},n)}var ct=z({square_:J3});function Q3(e,t=null,n=!1){let r=_(e,"x","sum");r.dtype==="bool"&&(r=ae(r,"int32"));let s={x:r},a={axis:t,keepDims:n};return M.runKernel(Wi,s,a)}var ge=z({sum_:Q3});function eM(e,t="euclidean",n=null,r=!1){e=_(e,"x","norm");let s=XC(e,t,n),a=s.shape;if(r){let o=Pr(n,e.shape);a=yo(s.shape,o)}return W(s,a)}function XC(e,t,n=null){if(e.rank===0)return Bt(e);if(e.rank!==1&&n===null)return XC(W(e,[-1]),t,n);if(e.rank===1||typeof n=="number"||Array.isArray(n)&&n.length===1){if(t===1)return ge(Bt(e),n);if(t===1/0)return fr(Bt(e),n);if(t===-1/0)return ju(Bt(e),n);if(t==="euclidean"||t===2)return fn(ge(Ps(Bt(e),xe(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(n)&&n.length===2){if(t===1)return fr(ge(Bt(e),n[0]),n[1]-1);if(t===1/0)return fr(ge(Bt(e),n[1]),n[0]);if(t===-1/0)return ju(ge(Bt(e),n[1]),n[0]);if(t==="fro"||t==="euclidean")return fn(ge(ct(e),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}var hl=z({norm_:eM});function tM(e,t=null,n=!1){return hl(e,"euclidean",t,n)}var fw=z({euclideanNorm_:tM});function nM(e){let n={x:_(e,"x","exp")};return M.runKernel(Jo,n)}var vn=z({exp_:nM});function rM(e,t=0){let n=_(e,"x","expandDims","string_or_numeric");A(t<=n.rank,()=>"Axis must be <= rank of the tensor");let r={input:n},s={dim:t};return M.runKernel(Tc,r,s)}var jt=z({expandDims_:rM});function sM(e){let n={x:_(e,"x","expm1")};return M.runKernel(Qo,n)}var mw=z({expm1_:sM});function aM(e,t){let n=_(e,"x","tile","string_or_numeric");A(n.rank===t.length,()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`);let r={x:n},s={reps:t};return M.runKernel(Ta,r,s)}var Ln=z({tile_:aM});function oM(e,t,n,r="float32"){t==null&&(t=e);let s=ze([e,t],r),a=e<=t?e:t;for(let i=0;i<a;++i)s.set(1,i,i);let o=W(s.toTensor(),[e,t]);if(n==null)return o;if(n.length===1)return Ln(jt(o,0),[n[0],1,1]);if(n.length===2)return Ln(jt(jt(o,0),0),[n[0],n[1],1,1]);if(n.length===3)return Ln(jt(jt(jt(o,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}var um=z({eye_:oM});function iM(e){let n={x:_(e,"x","floor","float32")};return M.runKernel(ei,n)}var fl=z({floor_:iM});function uM(e,t,n=0,r=0){let s=_(e,"x","gather"),a=_(t,"indices","gather","int32"),o={x:s,indices:a},i={axis:n,batchDims:r};return M.runKernel(_c,o,i)}var ml=z({gather_:uM});function cM(e,t){let n=_(e,"a","greater","string_or_numeric"),r=_(t,"b","greater","string_or_numeric");[n,r]=Dt(n,r),lt(n.shape,r.shape);let s={a:n,b:r};return M.runKernel(Ac,s)}var Dn=z({greater_:cM});function lM(e,t){let n=_(e,"a","greaterEqual","string_or_numeric"),r=_(t,"b","greaterEqual","string_or_numeric");[n,r]=Dt(n,r),lt(n.shape,r.shape);let s={a:n,b:r};return M.runKernel(ri,s)}var Ms=z({greaterEqual_:lM});function dM(e){let n={input:_(e,"input","imag")};return M.runKernel(Kf,n)}var fp=z({imag_:dM});function pM(e){let n={x:_(e,"x","isFinite")};return M.runKernel(ai,n)}var gw=z({isFinite_:pM});function hM(e){let n={x:_(e,"x","isInf")};return M.runKernel(oi,n)}var bw=z({isInf_:hM});function fM(e){let n={x:_(e,"x","isNaN")};return M.runKernel(ii,n)}var yw=z({isNaN_:fM});function mM(e,t=.2){let r={x:_(e,"x","leakyRelu")},s={alpha:t};return M.runKernel(ui,r,s)}var mp=z({leakyRelu_:mM});function gM(e,t){let n=_(e,"a","less","string_or_numeric"),r=_(t,"b","less","string_or_numeric");[n,r]=Dt(n,r),lt(n.shape,r.shape);let s={a:n,b:r};return M.runKernel(Dc,s)}var qu=z({less_:gM});function bM(e,t){let n=_(e,"a","lessEqual","string_or_numeric"),r=_(t,"b","lessEqual","string_or_numeric");[n,r]=Dt(n,r),lt(n.shape,r.shape);let s={a:n,b:r};return M.runKernel($c,s)}var Da=z({lessEqual_:bM});function YC(e,t,n){if(n<=0)throw new Error("The number of values should be positive.");let r={start:e,stop:t,num:n};return M.runKernel(Fc,{},r)}function yM(e,t=5,n=1,r=1,s=.5){let a=_(e,"x","localResponseNormalization");A(a.rank===4||a.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${a.rank}.`),A(Vu(t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let o=a,i=!1;a.rank===3&&(i=!0,o=W(a,[1,a.shape[0],a.shape[1],a.shape[2]]));let u={x:o},c={depthRadius:t,bias:n,alpha:r,beta:s},l=M.runKernel(di,u,c);return i?W(l,[l.shape[1],l.shape[2],l.shape[3]]):l}var vw=z({localResponseNormalization_:yM});function vM(e){let n={x:_(e,"x","log","float32")};return M.runKernel(ci,n)}var rr=z({log_:vM});function xM(e){let n={x:_(e,"x","log1p")};return M.runKernel(li,n)}var gp=z({log1p_:xM});function wM(e){return A(pa(e),()=>"The f passed in grad(f) must be a function"),(t,n)=>{let r=_(t,"x","tf.grad","string_or_numeric"),s=n!=null?_(n,"dy","tf.grad"):null;return M.tidy(()=>{let{value:a,grads:o}=M.gradients(()=>e(r),[r],s);return s!=null&&En(a.shape,s.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),cm(o),o[0]})}}function IM(e){return A(pa(e),()=>"The f passed in grads(f) must be a function"),(t,n)=>{A(Array.isArray(t),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");let r=kd(t,"args","tf.grads","string_or_numeric"),s=n!=null?_(n,"dy","tf.grads"):null;return M.tidy(()=>{let{value:a,grads:o}=M.gradients(()=>e(...r),r,s);return s!=null&&En(a.shape,s.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),cm(o),o})}}function kM(e){return A(pa(e),()=>"The f passed in valueAndGrad(f) must be a function"),(t,n)=>{A(t instanceof Te,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),A(n==null||n instanceof Te,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");let{grads:r,value:s}=M.gradients(()=>e(t),[t],n);return cm(r),{grad:r[0],value:s}}}function SM(e){return A(pa(e),()=>"The f passed in valueAndGrads(f) must be a function"),(t,n)=>{A(Array.isArray(t)&&t.every(s=>s instanceof Te),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),A(n==null||n instanceof Te,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");let r=M.gradients(()=>e(...t),t,n);return n!=null&&En(r.value.shape,n.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),cm(r.grads),r}}function ZC(e,t){A(pa(e),()=>"The f passed in variableGrads(f) must be a function"),A(t==null||Array.isArray(t)&&t.every(c=>c instanceof fa),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");let n=t!=null;if(!n){t=[];for(let c in M.registeredVariables)t.push(M.registeredVariables[c])}let r=n?t.filter(c=>!c.trainable):null,s=t.length;t=t.filter(c=>c.trainable),A(t.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${s} variables is trainable.`);let a=!0,{value:o,grads:i}=M.gradients(e,t,null,a);A(i.some(c=>c!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),A(o.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${o.rank} tensor`);let u={};return t.forEach((c,l)=>{i[l]!=null&&(u[c.name]=i[l])}),r?.forEach(c=>u[c.name]=null),{value:o,grads:u}}function ps(e){return M.customGrad(e)}function cm(e){if(e.filter(n=>n==null).length>0)throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`)}function CM(e){let n={x:_(e,"x","neg")};return M.runKernel(Bc,n)}var bt=z({neg_:CM});function TM(e){let n={x:_(e,"x","softplus")};return M.runKernel(zi,n)}var qi=z({softplus_:TM});function NM(e){let t=_(e,"x","logSigmoid");return ps(r=>({value:bt(qi(bt(r))),gradFunc:o=>B(o,hr(bt(r)))}))(t)}var xw=z({logSigmoid_:NM});function _M(e,t){let n=_(e,"a","sub"),r=_(t,"b","sub");[n,r]=Dt(n,r);let s={a:n,b:r};return M.runKernel(Gi,s)}var de=z({sub_:_M});function EM(e,t=-1){let n=_(e,"logits","logSoftmax");if(t===-1&&(t=n.rank-1),t!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${t}`);return ps((s,a)=>{let i=fr(s,t,!0),u=de(s,i),c=de(ae(u,"float32"),rr(ge(vn(u),t,!0)));return a([c]),{value:c,gradFunc:(p,d)=>{let[h]=d,f=!0,g=vn(h);return de(p,B(ge(p,t,f),g))}}})(n)}var lm=z({logSoftmax_:EM});function AM(e,t=null,n=!1){let r=_(e,"x","logSumExp"),s=Pr(t,r.shape),a=fr(r,s,!0),o=de(r,a),i=vn(o),u=ge(i,s),c=rr(u),l=X(W(a,c.shape),c);if(n){let p=yo(l.shape,s);return W(l,p)}return l}var dm=z({logSumExp_:AM});function DM(e,t){let n=_(e,"a","logicalAnd","bool"),r=_(t,"b","logicalAnd","bool");lt(n.shape,r.shape);let s={a:n,b:r};return M.runKernel(Rc,s)}var Rr=z({logicalAnd_:DM});function $M(e){let n={x:_(e,"x","logicalNot","bool")};return M.runKernel(Pc,n)}var bp=z({logicalNot_:$M});function FM(e,t){let n=_(e,"a","logicalOr","bool"),r=_(t,"b","logicalOr","bool");lt(n.shape,r.shape);let s={a:n,b:r};return M.runKernel(Oc,s)}var pm=z({logicalOr_:FM});function RM(e,t){let n=_(e,"a","logicalXor","bool"),r=_(t,"b","logicalXor","bool");return lt(n.shape,r.shape),Rr(pm(e,t),bp(Rr(e,t)))}var ww=z({logicalXor_:RM}),Mh=2147483648;function PM(e,t,n="left"){let r=_(e,"sortedSequence","searchSorted"),s=_(t,"values","searchSorted"),a=r.shape[r.shape.length-1],o=s.shape[s.shape.length-1],i=W(r,[-1,a]),u=W(s,[-1,o]);if(i.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(i.shape[0]!==u.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(gt(u.shape)>=Mh)throw new Error(`values tensor size must less than ${Mh}`);if(i.shape[1]>=Mh)throw new Error(`trailing dim_size must less than ${Mh} for int32 output type, was ${i.shape[1]}`);let c={sortedSequence:i,values:u},l={side:n};return M.runKernel(Jc,c,l)}var hm=z({searchSorted_:PM});function JC(e,t){return hm(e,t,"left")}function OM(e,t,n,r,s){let a=_(e,"x","maxPool"),o=1,i=a,u=!1;a.rank===3&&(u=!0,i=W(a,[1,a.shape[0],a.shape[1],a.shape[2]])),A(i.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${i.rank}.`),A(ms(n,o),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`),An("maxPool",r,s);let c={x:i},l={filterSize:t,strides:n,pad:r,dimRoundingMode:s},p=M.runKernel(fi,c,l);return u?W(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var Ot=z({maxPool_:OM});function MM(e,t=[1,1,1],n,r,s,a="NDHWC"){let o=_(e,"x","maxPool3d"),i=o,u=!1;o.rank===4&&(u=!0,i=W(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),A(i.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${i.rank}.`),A(a==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`),An("maxPool3d",r,s);let c={x:i},l={filterSize:t,strides:n,pad:r,dimRoundingMode:s,dataFormat:a},p=M.runKernel(Lc,c,l);return u?W(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}var Iw=z({maxPool3d_:MM});function LM(e,t,n,r,s=!1){let o={x:_(e,"x","maxPoolWithArgmax")},i={filterSize:t,strides:n,pad:r,includeBatchInIndex:s},u=M.runKernel(Kd,o,i);return{result:u[0],indexes:u[1]}}var QC=z({maxPoolWithArgmax_:LM});function zM(e,t){let n=_(e,"a","maximum"),r=_(t,"b","maximum");[n,r]=Dt(n,r),n.dtype==="bool"&&(n=ae(n,"int32"),r=ae(r,"int32")),lt(n.shape,r.shape);let s={a:n,b:r};return M.runKernel(hi,s)}var gs=z({maximum_:zM});function BM(e,t=null,n=!1){let s={x:_(e,"x","mean")},a={axis:t,keepDims:n};return M.runKernel(mi,s,a)}var Et=z({mean_:BM});function Ct(e,t="float32"){if(or(e),t==="complex64"){let r=Ct(e,"float32"),s=Ct(e,"float32");return Rs(r,s)}let n=Lf(gt(e),t);return M.makeTensor(n,e,t)}function er(e,t="float32"){if(or(e),t==="complex64"){let r=er(e,"float32"),s=Ct(e,"float32");return Rs(r,s)}let n=Ex(gt(e),t);return M.makeTensor(n,e,t)}function eT(e,t,{indexing:n="xy"}={}){if(n!=="xy"&&n!=="ij")throw new TypeError(`${n} is not a valid third argument to meshgrid`);if(e===void 0)return[];let r=_(e,"x","meshgrid",e instanceof Te?e.dtype:"float32");if(t===void 0)return[r];let s=_(t,"y","meshgrid",t instanceof Te?t.dtype:"float32"),a=gt(r.shape),o=gt(s.shape);return n==="xy"?(r=W(r,[1,-1]),s=W(s,[-1,1]),[Fe(er([o,1],r.dtype),r),Fe(s,er([1,a],s.dtype))]):(r=W(r,[-1,1]),s=W(s,[1,-1]),[Fe(r,er([1,o],r.dtype)),Fe(er([a,1],s.dtype),s)])}function WM(e,t){let n=_(e,"a","minimum"),r=_(t,"b","minimum");[n,r]=Dt(n,r),n.dtype==="bool"&&(n=ae(n,"int32"),r=ae(r,"int32")),lt(n.shape,r.shape);let s={a:n,b:r};return M.runKernel(bi,s)}var ga=z({minimum_:WM});function VM(e,t,n){A(n==="reflect"||n==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`);let r=_(e,"x","mirrorPad");if(r.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");A(t.length===r.rank,()=>`Padding doesn't match input. Must be ${r.rank}. Got ${t.length}.`);let s=n==="reflect"?1:0;for(let i=0;i<r.rank;i++)A(t[i].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),A(t[i][0]>=0&&t[i][0]<=r.shape[i]-s&&t[i][1]>=0&&t[i][1]<=r.shape[i]-s,()=>`Padding in dimension ${i} cannot be greater than or equal to ${r.shape[i]-s} or less than 0 for input of shape ${r.shape}`);let a={paddings:t,mode:n},o={x:r};return M.runKernel(yi,o,a)}var kw=z({mirrorPad_:VM});function UM(e,t){let n=_(e,"a","mod"),r=_(t,"b","mod");[n,r]=Dt(n,r);let s={a:n,b:r};return M.runKernel(vi,s)}var Sw=z({mod_:UM});function GM(e,t=null,n=!1){e=_(e,"x","moments");let r=Pr(t,e.shape),s=Et(e,r,n),a=s.shape;n||(a=yo(s.shape,r));let o=ct(de(ae(e,"float32"),W(s,a))),i=Et(o,r,n);return{mean:s,variance:i}}var yp=z({moments_:GM});function HM(e,t,n,r){let s=_(t,"data","multiRNNCell"),a=kd(n,"c","multiRNNCell"),o=kd(r,"h","multiRNNCell"),i=s,u=[];for(let p=0;p<e.length;p++){let d=e[p](i,a[p],o[p]);u.push(d[0]),u.push(d[1]),i=d[1]}let c=[],l=[];for(let p=0;p<u.length;p+=2)c.push(u[p]),l.push(u[p+1]);return[c,l]}var tT=z({multiRNNCell_:HM});function jM(e,t,n,r=!1){let s=_(e,"logits","multinomial"),a=s.size,o=s.rank;if(a<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${a}.`);if(o>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${o}`);n=n||Math.random();let u={logits:o===1?W(s,[1,-1]):s},c={numSamples:t,seed:n,normalized:r},l=M.runKernel(zc,u,c);return o===1?W(l,[l.size]):l}var nT=z({multinomial_:jM});function qM(e,t){let n=_(e,"a","notEqual","string_or_numeric"),r=_(t,"b","notEqual","string_or_numeric");[n,r]=Dt(n,r),lt(n.shape,r.shape);let s={a:n,b:r};return M.runKernel(Wc,s)}var vo=z({notEqual_:qM});function KM(e,t,n=1,r=0,s="int32"){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);let o={indices:_(e,"indices","oneHot","int32")},i={dtype:s,depth:t,onValue:n,offValue:r};return M.runKernel(wi,o,i)}var Ku=z({oneHot_:KM});function XM(e){let n={x:_(e,"x","onesLike")};return M.runKernel(Hc,n)}var sr=z({onesLike_:XM});function YM(e,t){let n=_(e,"v1","outerProduct"),r=_(t,"v2","outerProduct");A(n.rank===1&&r.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${r.rank}.`);let s=W(n,[-1,1]),a=W(r,[1,-1]);return Fe(s,a)}var rT=z({outerProduct_:YM});function ZM(e,t,n=0){let r=_(e,"x","pad");if(r.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");let s={paddings:t,constantValue:n},a={x:r};return M.runKernel(Ii,a,s)}var yr=z({pad_:ZM});function JM(e,t,n=0){return A(t.length===2,()=>"Invalid number of paddings. Must be length of 2."),yr(e,[t],n)}var sT=z({pad1d_:JM});function QM(e,t,n=0){return A(t.length===2&&t[0].length===2&&t[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),yr(e,t,n)}var aT=z({pad2d_:QM});function eL(e,t,n=0){return A(t.length===3&&t[0].length===2&&t[1].length===2&&t[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),yr(e,t,n)}var oT=z({pad3d_:eL});function tL(e,t,n=0){return A(t.length===4&&t[0].length===2&&t[1].length===2&&t[2].length===2&&t[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),yr(e,t,n)}var iT=z({pad4d_:tL});function nL(e,t,n){let r=_(e,"x","spaceToBatchND");A(r.rank>=1+t.length,()=>`input rank ${r.rank} should be > than [blockShape] ${t.length}`),A(n.length===t.length,()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${t.length}`),A(r.shape.reduce((o,i,u)=>u>0&&u<=t.length?o&&(i+n[u-1][0]+n[u-1][1])%t[u-1]===0:o,!0),()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${t.toString()}`);let s={x:r},a={blockShape:t,paddings:n};return M.runKernel(tl,s,a)}var vp=z({spaceToBatchND_:nL});function rL(e,t,n,r,s,a,o){s==null&&(s=[1,1]),a==null&&(a=1),r===0&&(r="valid");let i=_(e,"x","maxPool"),u=i,c=!1;i.rank===3&&(c=!0,u=W(i,[1,i.shape[0],i.shape[1],i.shape[2]])),A(ms(a,s),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${a} and dilations '${s}'`);let l=OC(u.shape,t,a,s,r),p=[l.dilationHeight,l.dilationWidth],d;r==="same"?d=aL([l.filterHeight,l.filterWidth],p):d=[[0,0],[0,0]];let h=p[0]===1&&p[1]===1,[f,g]=sL([l.inHeight,l.inWidth],p,d),m=h?r:"valid",b=h?u:vp(u,p,f),y=(n==="avg"?()=>br(b,t,a,m,o):()=>Ot(b,t,a,m,o))(),x=h?y:pp(y,p,g);return c?W(x,[x.shape[1],x.shape[2],x.shape[3]]):x}function sL(e,t,n){let r=n.map(l=>l[0]),s=n.map(l=>l[1]),a=e.concat(r,s),o=t.map((l,p)=>(l-a[p]%l)%l),i=s.map((l,p)=>l+o[p]),u=t.map((l,p)=>[r[p],i[p]]),c=t.map((l,p)=>[0,o[p]]);return[u,c]}function aL(e,t){let r=e.map((o,i)=>o+(o-1)*(t[i]-1)).map(o=>o-1),s=r.map(o=>Math.floor(o/2)),a=r.map((o,i)=>o-s[i]);return r.map((o,i)=>[s[i],a[i]])}var Cw=z({pool_:rL});function oL(e,t){let n=_(e,"x","prelu"),r=_(t,"alpha","prelu"),s={x:n,alpha:r};return M.runKernel(Si,s)}var xp=z({prelu_:oL});function iL(e,t=null,n=!1){let r=_(e,"x","prod");r.dtype==="bool"&&(r=ae(r,"int32"));let s={x:r},a={axis:t,keepDims:n};return M.runKernel(Ci,s,a)}var Tw=z({prod_:iL});function uL(e,t,n,r){let s=e.map((l,p)=>_(l,`tensors${p}`,"raggedGather","int32")),a=_(t,"paramsDenseValues","raggedGather"),o=_(n,"indices","raggedGather","int32"),i={paramsNestedSplits:s,paramsDenseValues:a,indices:o},u={outputRaggedRank:r},c=M.runKernel(Xf,i,u);return{outputNestedSplits:c.slice(0,c.length-1),outputDenseValues:c[c.length-1]}}var uT=z({raggedGather_:uL});function cL(e,t,n){let r=_(e,"starts","raggedRange"),s=_(t,"limits","raggedRange",r.dtype),a=_(n,"deltas","raggedRange",r.dtype),o={starts:r,limits:s,deltas:a},i=M.runKernel(Yf,o);return{rtNestedSplits:i[0],rtDenseValues:i[1]}}var cT=z({raggedRange_:cL});function lL(e,t,n,r,s){let a=_(e,"shape","raggedTensorToTensor","int32"),o=_(t,"values","raggedTensorToTensor"),i=_(n,"defaultValue","raggedTensorToTensor",o.dtype),u=r.map((p,d)=>_(p,`tensors${d}`,"raggedTensorToTensor","int32")),c={shape:a,values:o,defaultValue:i,rowPartitionTensors:u},l={rowPartitionTypes:s};return M.runKernel(Zf,c,l)}var lT=z({raggedTensorToTensor_:lL});function dL(e,t,n){or(e);let r=gt(e),s=null;if(n==null||n==="float32")s=new Float32Array(r);else if(n==="int32")s=new Int32Array(r);else if(n==="bool")s=new Uint8Array(r);else throw new Error(`Unknown data type ${n}`);for(let a=0;a<r;a++)s[a]=t();return M.makeTensor(s,e,n)}var dT=z({rand_:dL}),Nw=ka(Of()),pT={};Ee(pT,{TEST_EPSILON_FLOAT16:()=>hT,createVideoElement:()=>vL,encodeStrings:()=>fT,expectArrayBuffersEqual:()=>yL,expectArraysClose:()=>hL,expectArraysEqual:()=>mL,expectNumbersClose:()=>gL,expectPromiseToFail:()=>fL,expectValuesInRange:()=>bL,play:()=>xL,testEpsilon:()=>_w});var pL=.001,hT=.1;function hL(e,t,n){return n==null&&(n=_w()),Bv(e,t,(r,s)=>Ew(r,s,n))}function _w(){return M.backend.floatPrecision()===32?pL:hT}function Bv(e,t,n){let r=!0;if((nn(e)||nn(t))&&(r=!1),nn(e)&&nn(t)&&(r=!0),r){let o=e.constructor.name,i=t.constructor.name;if(o!==i)throw new Error(`Arrays are of different type. Actual: ${o}. Expected: ${i}`)}if(Array.isArray(e)&&Array.isArray(t)){let o=ds(e),i=ds(t);if(!Os(o,i))throw new Error(`Arrays have different shapes. Actual: [${o}]. Expected: [${i}]`)}let s=nn(e)?e:ha(e),a=nn(t)?t:ha(t);if(s.length!==a.length)throw new Error(`Arrays have different lengths actual: ${s.length} vs expected: ${a.length}.
Actual:   ${s}.
Expected: ${a}.`);for(let o=0;o<a.length;++o){let i=s[o],u=a[o];if(!n(i,u))throw new Error(`Arrays differ: actual[${o}] = ${i}, expected[${o}] = ${u}.
Actual:   ${s}.
Expected: ${a}.`)}typeof expect<"u"&&expect().nothing()}function fL(e,t){e().then(()=>t.fail(),()=>t()),typeof expect<"u"&&expect().nothing()}function mL(e,t){let n=typeof t=="string"||typeof t=="number"||typeof t=="boolean"?[t]:t;return aa(e)||aa(e[0])||aa(t)||aa(t[0])?Bv(e,n,(r,s)=>r==s):Bv(e,t,(r,s)=>Ew(r,s,0))}function gL(e,t,n){if(n==null&&(n=_w()),!Ew(e,t,n))throw new Error(`Numbers differ: actual === ${e}, expected === ${t}`);typeof expect<"u"&&expect().nothing()}function Ew(e,t,n){return!isFinite(e)&&!isFinite(t)?!0:!(isNaN(e)||isNaN(t)||Math.abs(e-t)>n)}function bL(e,t,n){for(let r=0;r<e.length;r++)if(e[r]<t||e[r]>n)throw new Error(`Value out of range:${e[r]} low: ${t}, high: ${n}`)}function yL(e,t){let n=new Float32Array(e),r=new Float32Array(t);if(n.length!==r.length)throw new Error(`Expected ArrayBuffer to be of length ${r.length}, but it was ${n.length}`);for(let s=0;s<r.length;s++)if(n[s]!==r[s])throw new Error(`Expected ArrayBuffer value at ${s} to be ${r[s]} but got ${n[s]} instead`)}function fT(e){for(let t=0;t<e.length;t++){let n=e[t];Array.isArray(n)?fT(n):e[t]=up(n)}return e}function vL(e){let t=document.createElement("video");return"playsInline"in t&&(t.playsInline=!0),t.muted=!0,t.loop=!0,t.style.position="fixed",t.style.left="0px",t.style.top="0px",t.preload="auto",t.appendChild(e),new Promise(n=>{t.addEventListener("loadeddata",r=>n(t)),t.load()})}async function xL(e){await e.play(),"requestVideoFrameCallback"in e&&await new Promise(t=>{e.requestVideoFrameCallback(t)})}var Aw=class{constructor(e,t,n,r,s){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);let a=s||Math.random();this.random=Nw.alea(a.toString())}nextValue(){if(!isNaN(this.nextVal)){let r=this.nextVal;return this.nextVal=NaN,r}let e,t,n=!1;for(;!n;){let r,s,a;do r=2*this.random()-1,s=2*this.random()-1,a=r*r+s*s;while(a>=1||a===0);let o=Math.sqrt(-2*Math.log(a)/a);e=this.mean+this.stdDev*r*o,t=this.mean+this.stdDev*s*o,(!this.truncated||this.isValidTruncated(e))&&(n=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}},wL=class{constructor(e,t,n,r){this.alpha=e,this.beta=1/t,this.dtype=n;let s=r||Math.random();this.randu=Nw.alea(s.toString()),this.randn=new Aw(0,1,n,!1,this.randu()),e<1?this.d=e+2/3:this.d=e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,n,r,s,a;for(;;){do r=this.randn.nextValue(),a=1+this.c*r;while(a<=0);if(a*=a*a,e=r*r,t=1-.331*e*e,n=.5*e+this.d*(1-a+Math.log(a)),s=this.randu(),s<t||Math.log(s)<n)break}return a=1/this.beta*this.d*a,this.alpha<1&&(a*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(a)}convertValue(e){return this.dtype==="float32"?e:Math.round(e)}},IL=class{constructor(e=0,t=1,n,r){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=t-e,this.dtype=n,r==null&&(r=Math.random()),typeof r=="number"&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=Nw.alea(r)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}};function kL(e,t,n=1,r="float32",s){if(or(e),n==null&&(n=1),r==null&&(r="float32"),r!=="float32"&&r!=="int32")throw new Error(`Unsupported data type ${r}`);let a=new wL(t,n,r,s),o=ze(e,r);for(let i=0;i<o.values.length;i++)o.values[i]=a.nextValue();return o.toTensor()}var mT=z({randomGamma_:kL});function SL(e,t=0,n=1,r,s){if(or(e),r!=null&&r==="bool")throw new Error(`Unsupported data type ${r}`);let a=new Aw(t,n,r,!1,s),o=ze(e,r);for(let i=0;i<o.values.length;i++)o.values[i]=a.nextValue();return o.toTensor()}var fm=z({randomNormal_:SL});function CL(e,t,n){if(t!=null&&t==="bool")throw new Error(`Unsupported data type ${t}`);return fm(e,0,1,t,n)}var gT=z({randomStandardNormal_:CL});function TL(e,t=0,n=1,r="float32",s){or(e);let a=ze(e,r),o=new IL(t,n,null,s);for(let i=0;i<a.values.length;i++)a.values[i]=o.nextValue();return a.toTensor()}var $a=z({randomUniform_:TL});function NL(e,t,n,r){return $a(e,t,n,"int32",r)}var bT=z({randomUniformInt_:NL});function xo(e,t,n=1,r="float32"){if(n===0)throw new Error("Cannot have a step of zero");let s={start:e,stop:t,step:n,dtype:r};return M.runKernel(Xd,{},s)}function _L(e){let n={input:_(e,"input","real")};return M.runKernel(Jf,n)}var Xu=z({real_:_L});function EL(e){let n={x:_(e,"x","reciprocal")};return M.runKernel(Ti,n)}var Dw=z({reciprocal_:EL});function AL(e){let n={x:_(e,"x","relu")};return M.runKernel(Ni,n)}var Ke=z({relu_:AL});function DL(e){let n={x:_(e,"x","relu6")};return M.runKernel(Ai,n)}var mm=z({relu6_:DL});function $L(e,t){let r={x:_(e,"x","reverse")},s={dims:t};return M.runKernel(Di,r,s)}var gr=z({reverse_:$L});function FL(e){let t=_(e,"x","reverse");return A(t.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`),gr(t,0)}var yT=z({reverse1d_:FL});function RL(e,t){let n=_(e,"x","reverse");return A(n.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`),gr(n,t)}var vT=z({reverse2d_:RL});function PL(e,t){let n=_(e,"x","reverse");return A(n.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`),gr(n,t)}var xT=z({reverse3d_:PL});function OL(e,t){let n=_(e,"x","reverse");return A(n.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`),gr(n,t)}var wT=z({reverse4d_:OL});function ML(e){let n={x:_(e,"x","round")};return M.runKernel($i,n)}var gm=z({round_:ML});function LL(e){let n={x:_(e,"x","rsqrt","float32")};return M.runKernel(Fi,n)}var bm=z({rsqrt_:LL});function zL(e){let n={x:_(e,"x","selu")};return M.runKernel(Ri,n)}var ym=z({selu_:zL});function BL(e,t,n,r,s,a=[1,1],o="NHWC"){let i=_(e,"x","separableConv2d"),u=_(t,"depthwiseFilter","separableConv2d"),c=_(n,"pointwiseFilter","separableConv2d"),l=i,p=!1;if(i.rank===3&&(p=!0,l=W(i,[1,i.shape[0],i.shape[1],i.shape[2]])),o==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");A(l.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${l.rank}.`),A(u.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${u.rank}.`),A(c.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${u.rank}.`),A(c.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${c.shape[0]}.`),A(c.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${c.shape[1]}.`);let d=u.shape[2],h=u.shape[3];A(c.shape[2]===d*h,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${d*h}, but got ${c.shape[2]}.`);let f=Aa(l,u,r,s,o,a),m=Pt(f,c,1,"valid",o);return p?W(m,[m.shape[1],m.shape[2],m.shape[3]]):m}var Fa=z({separableConv2d_:BL});async function WL(e,t){let n=_(e,"x","setdiff1d"),r=_(t,"y","setdiff1d");A(n.dtype===r.dtype,()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${r.dtype}).`),A(n.rank===1,()=>`x should be 1D tensor, but got x (${n.shape}).`),A(r.rank===1,()=>`y should be 1D tensor, but got y (${r.shape}).`);let s=await n.data(),a=await r.data(),o=new Set(a),i=0;for(let l=0;l<s.length;l++)o.has(s[l])||i++;let u=new Vt([i],n.dtype),c=new Vt([i],"int32");for(let l=0,p=0;l<s.length;l++)o.has(s[l])||(u.values[p]=s[l],c.values[p]=l,p++);return[u.toTensor(),c.toTensor()]}var IT=WL;function VL(e){let n={x:_(e,"x","sign")};return M.runKernel(Mi,n)}var $w=z({sign_:VL});function UL(e){let n={x:_(e,"x","sin","float32")};return M.runKernel(Pi,n)}var vm=z({sin_:UL});function GL(e){let n={x:_(e,"x","sinh")};return M.runKernel(Oi,n)}var xm=z({sinh_:GL});function HL(e,t,n){let r=_(e,"x","slice1d");return A(r.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`),Ue(r,[t],[n])}var wp=z({slice1d_:HL});function jL(e,t,n){let r=_(e,"x","slice2d");return A(r.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`),Ue(r,t,n)}var wm=z({slice2d_:jL});function qL(e,t,n){let r=_(e,"x","slice3d");return A(r.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`),Ue(r,t,n)}var Ki=z({slice3d_:qL});function KL(e,t,n){let r=_(e,"x","slice4d");return A(r.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`),Ue(r,t,n)}var Yu=z({slice4d_:KL});function XL(e,t=-1){let n=_(e,"logits","softmax","float32");if(t===-1&&(t=n.rank-1),t!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${t}`);let r={logits:n},s={dim:t};return M.runKernel(Vi,r,s)}var Yr=z({softmax_:XL});function YL(e){A(e.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`);let t={input:e};return M.runKernel(jf,t)}var Ip=z({fft_:YL});function ZL(e){A(e.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`);let t={input:e};return M.runKernel(qf,t)}var Zu=z({ifft_:ZL});function JL(e){let t=e.shape[e.shape.length-1],n=e.size/t,r;if(t<=2){let s=W(e,[n,t]);r=Zu(s)}else{let s=[n,2*(t-1)],a=W(Xu(e),[n,t]),o=W(fp(e),[n,t]),i=gr(Ue(a,[0,1],[n,t-2]),1),u=B(gr(Ue(o,[0,1],[n,t-2]),1),xe(-1)),c=tt([a,i],1),l=tt([o,u],1),p=W(Rs(c,l),[s[0],s[1]]);r=Zu(p)}if(r=Xu(r),e.rank===3&&e.shape[0]!==0){let s=r,a=e.shape[0];r=W(r,[a,r.shape[0]/a,r.shape[1]]),s.dispose()}return r}var Im=z({irfft_:JL});function QL(e,t,n=0){let s={x:_(e,"x","split")},a={numOrSizeSplits:t,axis:n};return M.runKernel(nl,s,a)}var zn=z({split_:QL});function ez(e,t){A(e.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${e.dtype}`);let n=e.shape[e.shape.length-1],r=e.size/n,s;if(t!=null&&t<n){let f=e.shape.map(m=>0),g=e.shape.map(m=>m);g[e.shape.length-1]=t,s=Ue(e,f,g),n=t}else if(t!=null&&t>n){let f=e.shape.map(g=>g);f[e.shape.length-1]=t-n,s=tt([e,Ct(f)],e.shape.length-1),n=t}else s=e;let a=je(s),o=W(Rs(s,a),[r,n]),i=Ip(o),u=Math.floor(n/2)+1,c=Xu(i),l=fp(i),p=zn(c,[u,n-u],c.shape.length-1),d=zn(l,[u,n-u],l.shape.length-1),h=s.shape.slice();return h[s.shape.length-1]=u,W(Rs(p[0],d[0]),h)}var kp=z({rfft_:ez});function tz(e,t){let n=_(e,"a","squaredDifference"),r=_(t,"b","squaredDifference");[n,r]=Dt(n,r),lt(n.shape,r.shape);let s={a:n,b:r},a={};return M.runKernel(Ui,s,a)}var km=z({squaredDifference_:tz});function nz(e,t){let n=_(e,"x","squeeze","string_or_numeric");return W(n,J1(n.shape,t).newShape)}var Ra=z({squeeze_:nz});function rz(e,t=0){let n=kd(e,"tensors","stack","string_or_numeric");A(n.length>=1,()=>"Pass at least one tensor to tf.stack"),n.length>0&&A(t<=n[0].rank,()=>"Axis must be <= rank of the tensor");let r=n,s={axis:t};return M.runKernel(jc,r,s)}var Rt=z({stack_:rz});function sz(e,t=0){let r={x:_(e,"x","step")},s={alpha:t};return M.runKernel(Na,r,s)}var Xi=z({step_:sz});function az(e,t,n,r,s=0,a=0,o=0,i=0,u=0){let l={x:_(e,"x","stridedSlice","string_or_numeric")},p={begin:t,end:n,strides:r,beginMask:s,endMask:a,ellipsisMask:o,newAxisMask:i,shrinkAxisMask:u};return M.runKernel(al,l,p)}var Fw=z({stridedSlice_:az});function oz(e){let n={x:_(e,"x","tan","float32")};return M.runKernel(Hi,n)}var Rw=z({tan_:oz});function He(e,t){_o(e);let n=ds(e,t);if(n.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return _a(e,null,n,t)}function Fr(e,t,n){if(_o(e),t!=null&&t.length!==2)throw new Error("tensor2d() requires shape to have two numbers");let r=ds(e,n);if(r.length!==2&&r.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return _a(e,t,r,n)}function Sp(e,t,n){if(_o(e),t!=null&&t.length!==3)throw new Error("tensor3d() requires shape to have three numbers");let r=ds(e,n);if(r.length!==3&&r.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return _a(e,t,r,n)}function Or(e,t,n){if(_o(e),t!=null&&t.length!==4)throw new Error("tensor4d() requires shape to have four numbers");let r=ds(e,n);if(r.length!==4&&r.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return _a(e,t,r,n)}function kT(e,t,n){if(_o(e),t!=null&&t.length!==5)throw new Error("tensor5d() requires shape to have five numbers");let r=ds(e,n);if(r.length!==5&&r.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return _a(e,t,r,n)}function ST(e,t,n){if(_o(e),t!=null&&t.length!==6)throw new Error("tensor6d() requires shape to have six numbers");let r=ds(e,n);if(r.length!==6&&r.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return t=t||r,_a(e,t,r,n)}var Sm={};Ee(Sm,{calculateShapes:()=>CT,validateInput:()=>Cm,validateUpdateShape:()=>Pw});function Pw(e,t,n){let r=t.rank>1?t.shape[t.rank-1]:1,s=t.rank>1?t.rank-1:1,a=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${r}, and batchDim: ${s}.`;if(n.rank<s)throw new Error(a+` update.rank < ${s}. `);if(e.length<r+(n.rank-s))throw new Error(a+` Output shape length < ${r+(n.rank-s)}`);if(n.rank!==s+e.length-r)throw new Error(a+` update.rank != ${s+e.length-r}`);for(let o=0;o<s;++o)if(n.shape[o]!==t.shape[o])throw new Error(a+` updates.shape[${o}] (${n.shape[o]}) != indices.shape[${o}] (${t.shape[o]}).`);for(let o=0;o<n.rank-s;++o)if(n.shape[o+s]!==e[o+r])throw new Error(a+` updates.shape[${o+s}] (${n.shape[o+s]}) != shape[${o+s}] (${e[o+s]})`)}function Cm(e,t,n){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if(t.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(n.length===0){if(t.size===0)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(e.size===0)throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)}Pw(n,t,e)}function CT(e,t,n){let r=t.shape.length,s=r>1?t.shape[r-1]:1,a=n.length,o=1;for(let p=s;p<a;++p)o*=n[p];let i=s<1?1:s,u=gt(t.shape)/i,c=[...uc(n.slice(0,s)),1],l=gt(n);return{sliceRank:s,numUpdates:u,sliceSize:o,strides:c,outputSize:l}}function iz(e,t,n){let r=_(e,"tensor","tensorScatterupdate"),s=_(t,"indices","tensorScatterupdate","int32"),a=_(n,"updates","tensorScatterupdate");if(Cm(a,s,r.shape),r.dtype!==a.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${r.dtype} and ${a.dtype}.`);let o={tensor:r,indices:s,updates:a},i={};return M.runKernel(Zc,o,i)}var TT=z({tensorScatterUpdate_:iz});function uz(e,t=1,n=!0){let r=_(e,"x","topk");if(r.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");let s=r.shape[r.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>s)throw new Error(`'k' passed to topk() must be <= the last dimension (${s}) but got ${t}`);let a={x:r},o={k:t,sorted:n},[i,u]=M.runKernel(ol,a,o);return{values:i,indices:u}}var Ow=z({topk_:uz});function cz(e,t=0,n=1,r,s){if(or(e),r!=null&&r==="bool")throw new Error("Unsupported data type $ { dtype }");let a=new Aw(t,n,r,!0,s),o=ze(e,r);for(let i=0;i<o.values.length;i++)o.values[i]=a.nextValue();return o.toTensor()}var Tm=z({truncatedNormal_:cz});function lz(e,t=0){let n=_(e,"x","unique","string_or_numeric");A(n.rank>0,()=>"The input tensor must be at least 1D");let r={x:n},s={axis:t},[a,o]=M.runKernel(sp,r,s);return{values:a,indices:o}}var Mw=z({unique_:lz});function dz(e,t,n){let r=_(e,"x","unsortedSegmentSum"),s=_(t,"segmentIds","unsortedSegmentSum","int32");A(Vu(n),()=>"numSegments must be of dtype int");let a={x:r,segmentIds:s},o={numSegments:n};return M.runKernel(ap,a,o)}var Nm=z({unsortedSegmentSum_:dz});function pz(e,t=0){let n=_(e,"x","unstack","string_or_numeric");A(t>=-n.shape.length&&t<n.shape.length,()=>`Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`);let r={value:n},s={axis:t};return M.runKernel(ul,r,s)}var dt=z({unstack_:pz});function NT(e,t){return hm(e,t,"right")}function Lw(e,t=!0,n,r){return M.makeVariable(e,t,n,r)}function _T(e,t){let n=[];for(let a=0;a<t.length;a++)t[a]&&n.push(a);let r=ze(e,"int32"),s=ze([n.length,e.length],"int32");for(let a=0;a<n.length;a++){let o=r.indexToLoc(n[a]),i=a*e.length;s.values.set(o,i)}return s.toTensor()}async function hz(e){let t=_(e,"condition","whereAsync","bool"),n=await t.data(),r=_T(t.shape,n);return e!==t&&t.dispose(),r}var zw=hz;async function fz(e,t,n){let r=_(e,"tensor","boolMask"),s=_(t,"mask","boolMask","bool"),a=n??0,o=s.rank,i=r.shape;A(o>0,()=>"mask cannot be scalar"),En(i.slice(a,a+o),s.shape,"mask's shape must match the first K dimensions of tensor's shape,");let u=1;for(let g=a;g<a+o;g++)u*=i[g];let c=i.slice(0,a).concat([u],i.slice(a+o)),l=W(r,c),p=W(s,[-1]),d=await zw(p),h=Ra(d,[1]),f=ml(l,h,a);return e!==r&&r.dispose(),t!==s&&s.dispose(),h.dispose(),l.dispose(),p.dispose(),d.dispose(),f}var ET=fz;function mz(e,t,n){let r=_(e,"x","transpose");if(t==null&&(t=r.shape.map((o,i)=>i).reverse()),A(r.rank===t.length,()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${t}.`),t.forEach(o=>{A(o>=0&&o<r.rank,()=>`All entries in 'perm' must be between 0 and ${r.rank-1} but got ${t}`)}),r.rank<=1)return r.clone();let s={x:r},a={perm:t};return r.dtype==="complex64"?O(()=>{let o=Xu(r),i=fp(r);return o=M.runKernel($s,{x:o},a),i=M.runKernel($s,{x:i},a),n&&(i=bt(i)),Rs(o,i)}):M.runKernel($s,s,a)}var Re=z({transpose_:mz});function gz(e,t,n,r,s=!0){let a=_(e,"v","movingAverage"),o=_(t,"x","movingAverage"),i=_(n,"decay","movingAverage");yC(a,o),A(Os(a.shape,o.shape),()=>"Shape mismatch in v and x");let u=xe(1),c=de(u,i),l=B(de(o,a),c);if(s){A(r!=null,()=>"When using zeroDebias: true, step is required.");let p=_(r,"step","movingAverage");l=fe(l,de(u,Ps(i,p)))}return X(a,l)}var AT=z({movingAverage_:gz});function bz(e,t,n){or(n);let r=_(e,"indices","scatterND","int32"),s=_(t,"updates","scatterND");Cm(s,r,n);let a={indices:r,updates:s},o={shape:n};return M.runKernel(Yc,a,o)}var DT=z({scatterND_:bz});function yz(e,t,n,r){if(e.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${e.shape}.`);let s=e.rank>0?e.shape[0]:1,a=e.rank>1?e.shape[1]:1;if(n.length!==a)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${a}.`);let o=t.size;if(!(t.rank===0||t.rank===1&&o===s))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${s}]`);if(t.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}function vz(e,t,n,r=0){or(n);let s=_(e,"sparseIndices","sparseToDense","int32"),a=_(t,"sparseValues","sparseToDense","string_or_numeric"),o=_(r,"defaultValue","sparseToDense",a.dtype);yz(s,a,n,o);let i={sparseIndices:s,sparseValues:a,defaultValue:o},u={outputShape:n};return M.runKernel(sl,i,u)}var $T=z({sparseToDense_:vz});function xz(e,t){let n=_(t,"indices","gatherND","int32"),s={params:_(e,"x","gatherND","string_or_numeric"),indices:n};return M.runKernel(Ec,s)}var FT=z({gatherND_:xz});function wz(e,t){if(t==null)return e.shape.slice();if(Os(e.shape,t))return t;if(e.shape.length===t.length){let n=[];for(let r=0;r<e.shape.length;r++)t[r]==null&&e.shape[r]!=null?n.push(e.shape[r]):n.push(t[r]);return n}return t}function Iz(e,t,n,r){let s=_(e,"x","dropout");if(A(s.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${s.dtype} tensor instead.`),A(t>=0&&t<1,()=>`rate must be a float in the range [0, 1), but got ${t}.`),t===0)return e instanceof Te?s.clone():s;let a=wz(s,n),o=1-t,i=fe(fl(X($a(a,0,1,"float32",r),o)),o);return B(s,i)}var Bw=z({dropout_:Iz});function Ww(e){return Math.floor(Math.pow(2,Math.ceil(Math.log(e)/Math.log(2))))}function _m(e,t,n){let r=1-e%2,s=new Float32Array(e);for(let a=0;a<e;++a){let o=2*Math.PI*a/(e+r-1);s[a]=t-n*Math.cos(o)}return He(s,"float32")}async function kz(e,t,n=1){let r=_(e,"predictions","inTopK"),s=_(t,"targets","inTopK");A(r.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`),A(r.rank-1===s.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${s.rank}`),En(r.shape.slice(0,r.shape.length-1),s.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");let a=r.shape[r.shape.length-1];A(n>0&&n<=a,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${a}), but got ${n}`);let o=await r.data(),i=await s.data(),[u,c]=[o.length/a,a],l=Q1("bool",u);for(let p=0;p<u;p++){let d=p*c,h=o.subarray(d,d+c),f=[];for(let g=0;g<h.length;g++)f.push({value:h[g],index:g});f.sort((g,m)=>m.value-g.value),l[p]=0;for(let g=0;g<n;g++)if(f[g].index===i[p]){l[p]=1;break}}return e!==r&&r.dispose(),t!==s&&s.dispose(),yn(l,s.shape,"bool")}var RT=kz,Ju={};Ee(Ju,{conv2d:()=>Tz,depthwiseConv2d:()=>Az,matMul:()=>$z});function Sz(e,t,n,r,s,a="NHWC",o){let i=e;e.rank===3&&(i=W(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let u=t;u.rank===3&&(u=W(t,[1,t.shape[0],t.shape[1],t.shape[2]])),A(i.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${i.shape}.`),A(u.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${u.shape}.`),A(n.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`);let c=a==="NHWC"?i.shape[3]:i.shape[1],l=a==="NHWC"?u.shape[3]:u.shape[1];A(c===n[2],()=>`Error in conv2dDerFilter: depth of input ${c}) must match input depth in filter (${n[2]}.`),A(l===n[3],()=>`Error in conv2dDerFilter: depth of dy (${l}) must match output depth for filter (${n[3]}).`),An("conv2dDerFilter",s,o);let p={x:i,dy:u},d={strides:r,pad:s,dataFormat:a,dimRoundingMode:o,filterShape:n};return M.runKernel(Wf,p,d)}var Vw=z({conv2DBackpropFilter_:Sz});function Em(e,t,n){if(n==null||n==="linear")return e;if(n==="relu")return B(e,Xi(t));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function Am(e,t){let n=t,r=Ut(e.shape,t.shape);return r.length>0&&(n=ge(n,r)),W(n,e.shape)}function Dm(e,t,n,r){if(t==="linear")return e;if(t==="relu")return Ke(e);if(t==="elu")return pl(e);if(t==="relu6")return mm(e);if(t==="prelu")return xp(e,n);if(t==="leakyrelu")return mp(e,r);if(t==="sigmoid")return hr(e);throw new Error(`Unknown fused activation ${t}.`)}var $m=(e,t)=>!(e>0)||t==="linear";function Cz({x:e,filter:t,strides:n,pad:r,dataFormat:s="NHWC",dilations:a=[1,1],dimRoundingMode:o,bias:i,activation:u="linear",preluActivationWeights:c,leakyreluAlpha:l}){if(u=u||"linear",$m(M.state.gradientDepth,u)===!1){A(s==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${s} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let S=Pt(e,t,n,r,s,a,o);return i!=null&&(S=X(S,i)),Dm(S,u,c,l)}let p=_(e,"x","conv2d","float32"),d=_(t,"filter","conv2d","float32"),h=p,f=!1;p.rank===3&&(f=!0,h=W(p,[1,p.shape[0],p.shape[1],p.shape[2]])),A(h.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${h.rank}.`),A(d.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${d.rank}.`),An("fused conv2d",r,o);let g=s==="NHWC"?h.shape[3]:h.shape[1];A(d.shape[2]===g,()=>`Error in conv2d: depth of input (${g}) must match input depth for filter ${d.shape[2]}.`),A(ms(n,a),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`);let m=dp(h.shape,d.shape,n,a,r,o),b;i!=null&&(b=_(i,"bias","fused conv2d"),[b]=Dt(b,p),s==="NHWC"?lt(m.outShape,b.shape):(A(b.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${b.shape.length}.`),A(b.shape.length===0||b.shape[0]===m.outChannels||b.shape[0]===1,()=>`Error in fused conv2d: bias shape (${b.shape}) is not compatible with the number of output channels (${m.outChannels})`)));let v;if(c!=null){let S=c.shape;if(A(S.length<=1||S.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${S.length}.`),S.length===1)A(S[0]===1||S[0]===m.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${S}) is not compatible with the number of output channels (${m.outChannels}).`);else if(S.length===3)try{lt(S,m.outShape)}catch{let E=`Error in fused conv2d: PReLU activation weights (${S}) is not compatible with the output shape of the conv2d (${m.outShape}).`;throw Error(E)}v=_(c,"prelu weights","fused conv2d")}let y=(S,N)=>{A(s==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${s} but only NHWC is currently supported.`);let[E,$,R,D]=N,F=Em(S,R,u);A(ma(a),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`);let C=sw($.shape,F,E,n,r),L=Vw($,F,E.shape,n,r),U=[C,L];if(D!=null){let H=Am(D,F);U.push(H)}return U},x={x:h,filter:d,bias:b,preluActivationWeights:v},k={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:o,activation:u,leakyreluAlpha:l};return i==null?ps((N,E,$)=>{let R=M.runKernel(lo,x,k);return $([E,N,R]),f&&(R=W(R,[R.shape[1],R.shape[2],R.shape[3]])),{value:R,gradFunc:y}})(h,d):ps((N,E,$,R)=>{let D=M.runKernel(lo,x,k);return R([E,N,D,$]),f&&(D=W(D,[D.shape[1],D.shape[2],D.shape[3]])),{value:D,gradFunc:y}})(h,d,b)}var Tz=z({fusedConv2d_:Cz});function Nz(e,t,n,r,s,a=[1,1],o){let i=e;e.rank===3&&(i=W(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let u=t;u.rank===3&&(u=W(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let c={x:i,dy:u},l={strides:r,pad:s,dimRoundingMode:o,dilations:a,filterShape:n};return M.runKernel(Vf,c,l)}var PT=z({depthwiseConv2dNativeBackpropFilter_:Nz});function _z(e,t,n,r,s,a=[1,1],o){let i=t,u=!1;t.rank===3&&(u=!0,i=W(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let c={dy:i,filter:n},l={strides:r,pad:s,dimRoundingMode:o,dilations:a,inputShape:e},p=M.runKernel(Uf,c,l);return u?W(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var OT=z({depthwiseConv2dNativeBackpropInput_:_z});function Ez({x:e,filter:t,strides:n,pad:r,dataFormat:s="NHWC",dilations:a=[1,1],dimRoundingMode:o,bias:i,activation:u="linear",preluActivationWeights:c,leakyreluAlpha:l}){if($m(M.state.gradientDepth,u)===!1){let k=Aa(e,t,n,r,s,a,o);return i!=null&&(k=X(k,i)),Dm(k,u,c,l)}let p=_(e,"x","depthwiseConv2d","float32"),d=_(t,"filter","depthwiseConv2d","float32"),h=p,f=!1;p.rank===3&&(f=!0,h=W(p,[1,p.shape[0],p.shape[1],p.shape[2]])),A(h.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${h.rank}.`),A(d.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${d.rank}.`),A(h.shape[3]===d.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${h.shape[3]}) must match the inChannels dimension in filter ${d.shape[2]}.`),a==null&&(a=[1,1]),A(ms(n,a),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`),An("fused depthwiseConv2d",r,o);let g=dp(h.shape,d.shape,n,a,r,o,!0),m;i!=null&&(m=_(i,"bias","fused conv2d"),[m]=Dt(m,p),lt(g.outShape,m.shape));let b;c!=null&&(b=_(c,"prelu weights","fused depthwiseConv2d"));let v=(k,S)=>{A(ma(a),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);let[N,E,$,R]=S,D=Em(k,$,u),F=OT(E.shape,D,N,n,r,a,o),C=PT(E,D,N.shape,n,r,a,o);if(R!=null){let L=Am(m,D);return[F,C,L]}return[F,C]},y={x:h,filter:d,bias:m,preluActivationWeights:b},x={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:o,activation:u,leakyreluAlpha:l};return i==null?ps((S,N,E)=>{let $=M.runKernel(po,y,x);return E([N,S,$]),f&&($=W($,[$.shape[1],$.shape[2],$.shape[3]])),{value:$,gradFunc:v}})(h,d):ps((S,N,E,$)=>{let R=M.runKernel(po,y,x);return $([N,S,R,E]),f&&(R=W(R,[R.shape[1],R.shape[2],R.shape[3]])),{value:R,gradFunc:v}})(h,d,m)}var Az=z({fusedDepthwiseConv2d_:Ez});function Dz({a:e,b:t,transposeA:n=!1,transposeB:r=!1,bias:s,activation:a="linear",preluActivationWeights:o,leakyreluAlpha:i=.2}){if($m(M.state.gradientDepth,a)===!1){let D=Fe(e,t,n,r);return s!=null&&(D=X(D,s)),Dm(D,a,o,i)}let u=_(e,"a","fused matMul"),c=_(t,"b","fused matMul");[u,c]=Dt(u,c);let l=n?u.shape[u.rank-2]:u.shape[u.rank-1],p=r?c.shape[c.rank-1]:c.shape[c.rank-2],d=n?u.shape[u.rank-1]:u.shape[u.rank-2],h=r?c.shape[c.rank-2]:c.shape[c.rank-1],f=u.shape.slice(0,-2),g=c.shape.slice(0,-2),m=gt(f),b=gt(g);A(l===p,()=>`Error in fused matMul: inner shapes (${l}) and (${p}) of Tensors with shapes ${u.shape} and ${c.shape} and transposeA=${n} and transposeB=${r} must match.`);let y=lt(u.shape.slice(0,-2),c.shape.slice(0,-2)).concat([d,h]),x=n?W(u,[m,l,d]):W(u,[m,d,l]),k=r?W(c,[b,h,p]):W(c,[b,p,h]),S;s!=null&&(S=_(s,"bias","fused matMul"),[S]=Dt(S,u),lt(y,S.shape));let N;o!=null&&(N=_(o,"prelu weights","fused matMul"));let E=(D,F)=>{let[C,L,U,H]=F,K=Em(W(D,U.shape),U,a),q,Z;if(!n&&!r?(q=Fe(K,L,!1,!0),Z=Fe(C,K,!0,!1)):!n&&r?(q=Fe(K,L,!1,!1),Z=Fe(K,C,!0,!1)):n&&!r?(q=Fe(L,K,!1,!0),Z=Fe(C,K,!1,!1)):(q=Fe(L,K,!0,!0),Z=Fe(K,C,!0,!0)),s!=null){let J=Am(H,K);return[q,Z,J]}else return[q,Z]},$={a:x,b:k,bias:S,preluActivationWeights:N},R={transposeA:n,transposeB:r,activation:a,leakyreluAlpha:i};return s==null?ps((F,C,L)=>{let U=M.runKernel(co,$,R);return L([F,C,U]),{value:W(U,y),gradFunc:E}})(x,k):ps((F,C,L,U)=>{let H=M.runKernel(co,$,R);return U([F,C,H,L]),{value:W(H,y),gradFunc:E}})(x,k,S)}var $z=z({fusedMatMul_:Dz});function Fz(e){return _m(e,.54,.46)}var Rz=z({hammingWindow_:Fz});function Pz(e){return _m(e,.5,.5)}var MT=z({hannWindow_:Pz});function Oz(e,t,n,r=!1,s=0){let a=0,o=[];for(;a+t<=e.size;)o.push(Ue(e,a,t)),a+=n;if(r)for(;a<e.size;){let i=a+t-e.size,u=tt([Ue(e,a,t-i),xn([i],s)]);o.push(u),a+=n}return o.length===0?Fr([],[0,t]):W(tt(o),[o.length,t])}var LT=z({frame_:Oz});function Mz(e,t,n,r,s=MT){r==null&&(r=Ww(t));let a=LT(e,t,n),o=B(a,s(t));return kp(o,r)}var Lz=z({stft_:Mz});function zz(e,t,n,r,s="bilinear",a=0){let o=_(e,"image","cropAndResize"),i=_(t,"boxes","cropAndResize","float32"),u=_(n,"boxInd","cropAndResize","int32"),c=i.shape[0];A(o.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${o.rank}.`),A(i.rank===2&&i.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${c},4] but had shape ${i.shape}.`),A(u.rank===1&&u.shape[0]===c,()=>`Error in cropAndResize: boxInd must be have size [${c}] but had shape ${i.shape}.`),A(r.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),A(r[0]>=1&&r[1]>=1,()=>`cropSize must be atleast [1,1], but was ${r}`),A(s==="bilinear"||s==="nearest",()=>`method must be bilinear or nearest, but was ${s}`);let l={image:o,boxes:i,boxInd:u},p={method:s,extrapolationValue:a,cropSize:r};return M.runKernel(Ic,l,p)}var Bz=z({cropAndResize_:zz});function Wz(e){let t=_(e,"image","flipLeftRight","float32");A(t.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`);let n={image:t};return M.runKernel(Nc,n,{})}var Vz=z({flipLeftRight_:Wz});function Uz(e){let t=_(e,"image","grayscaleToRGB"),n=t.rank-1,r=t.shape[n];A(t.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`),A(r===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`);let s=new Array(t.rank);return s.fill(1,0,n),s[n]=3,Ln(t,s)}var Gz=z({grayscaleToRGB_:Uz});function Hz(e){let t=_(e,"image","RGBToGrayscale"),n=t.rank-1,r=t.shape[n];A(t.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${t.rank}.`),A(r===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${r}.`);let s=t.dtype,a=ae(t,"float32"),o=He([.2989,.587,.114]),i;switch(t.rank){case 2:i=Ja("ij,j->i",a,o);break;case 3:i=Ja("ijk,k->ij",a,o);break;case 4:i=Ja("ijkl,l->ijk",a,o);break;case 5:i=Ja("ijklm,m->ijkl",a,o);break;case 6:i=Ja("ijklmn,n->ijklm",a,o);break;default:throw new Error("Not a valid tensor rank.")}return i=jt(i,-1),ae(i,s)}var jz=z({rgbToGrayscale_:Hz});function qz(e,t,n=0,r=.5){let s=_(e,"image","rotateWithOffset","float32");A(s.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${s.rank}.`);let a={image:s},o={radians:t,fillValue:n,center:r};return M.runKernel(ll,a,o)}var Kz=z({rotateWithOffset_:qz});function gl(e,t,n,r,s,a){r==null&&(r=.5),s==null&&(s=Number.NEGATIVE_INFINITY),a==null&&(a=0);let o=e.shape[0];return n=Math.min(n,o),A(0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),A(e.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`),A(e.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`),A(t.rank===1,()=>"scores must be a 1D tensor"),A(t.shape[0]===o,()=>`scores has incompatible shape with boxes. Expected ${o}, but was ${t.shape[0]}`),A(0<=a&&a<=1,()=>`softNmsSigma must be in [0, 1], but was '${a}'`),{maxOutputSize:n,iouThreshold:r,scoreThreshold:s,softNmsSigma:a}}function Xz(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY){let a=_(e,"boxes","nonMaxSuppression","float32"),o=_(t,"scores","nonMaxSuppression","float32"),i=gl(a,o,n,r,s);n=i.maxOutputSize,r=i.iouThreshold,s=i.scoreThreshold;let u={maxOutputSize:n,iouThreshold:r,scoreThreshold:s};return M.runKernel(Vc,{boxes:a,scores:o},u)}var Yz=z({nonMaxSuppression_:Xz});function Zz(e,t,n){let r=Jz(e,t,n),s=r<0?-(r+1):r;e.splice(s,0,t)}function Jz(e,t,n){return eB(e,t,n||Qz)}function Qz(e,t){return e>t?1:e<t?-1:0}function eB(e,t,n){let r=0,s=e.length,a=0,o=!1;for(;r<s;){a=r+(s-r>>>1);let i=n(t,e[a]);i>0?r=a+1:(s=a,o=!i)}return o?r:-r-1}function zT(e,t,n,r,s){return Uw(e,t,n,r,s,0)}function BT(e,t,n,r,s,a){return Uw(e,t,n,r,s,0,!1,a,!0)}function WT(e,t,n,r,s,a){return Uw(e,t,n,r,s,a,!0)}function Uw(e,t,n,r,s,a,o=!1,i=!1,u=!1){let c=[];for(let m=0;m<t.length;m++)t[m]>s&&c.push({score:t[m],boxIndex:m,suppressBeginIndex:0});c.sort(bS);let l=a>0?-.5/a:0,p=[],d=[];for(;p.length<n&&c.length>0;){let m=c.pop(),{score:b,boxIndex:v,suppressBeginIndex:y}=m;if(b<s)break;let x=!1;for(let k=p.length-1;k>=y;--k){let S=tB(e,v,p[k]);if(S>=r){x=!0;break}if(m.score=m.score*nB(r,l,S),m.score<=s)break}m.suppressBeginIndex=p.length,x||(m.score===b?(p.push(v),d.push(m.score)):m.score>s&&Zz(c,m,bS))}let h=p.length,f=n-h;i&&f>0&&(p.push(...new Array(f).fill(0)),d.push(...new Array(f).fill(0)));let g={selectedIndices:p};return o&&(g.selectedScores=d),u&&(g.validOutputs=h),g}function tB(e,t,n){let r=e.subarray(t*4,t*4+4),s=e.subarray(n*4,n*4+4),a=Math.min(r[0],r[2]),o=Math.min(r[1],r[3]),i=Math.max(r[0],r[2]),u=Math.max(r[1],r[3]),c=Math.min(s[0],s[2]),l=Math.min(s[1],s[3]),p=Math.max(s[0],s[2]),d=Math.max(s[1],s[3]),h=(i-a)*(u-o),f=(p-c)*(d-l);if(h<=0||f<=0)return 0;let g=Math.max(a,c),m=Math.max(o,l),b=Math.min(i,p),v=Math.min(u,d),y=Math.max(b-g,0)*Math.max(v-m,0);return y/(h+f-y)}function nB(e,t,n){let r=Math.exp(t*n*n);return n<=e?r:0}function bS(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}async function rB(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY){let a=_(e,"boxes","nonMaxSuppressionAsync"),o=_(t,"scores","nonMaxSuppressionAsync"),i=gl(a,o,n,r,s);n=i.maxOutputSize,r=i.iouThreshold,s=i.scoreThreshold;let u=await Promise.all([a.data(),o.data()]),c=u[0],l=u[1],{selectedIndices:p}=zT(c,l,n,r,s);return a!==e&&a.dispose(),o!==t&&o.dispose(),He(p,"int32")}var sB=rB;function aB(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,a=0){let o=_(e,"boxes","nonMaxSuppression"),i=_(t,"scores","nonMaxSuppression"),u=gl(o,i,n,r,s,a);n=u.maxOutputSize,r=u.iouThreshold,s=u.scoreThreshold,a=u.softNmsSigma;let c={boxes:o,scores:i},l={maxOutputSize:n,iouThreshold:r,scoreThreshold:s,softNmsSigma:a},p=M.runKernel(Gc,c,l);return{selectedIndices:p[0],selectedScores:p[1]}}var oB=z({nonMaxSuppressionWithScore_:aB});async function iB(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,a=0){let o=_(e,"boxes","nonMaxSuppressionAsync"),i=_(t,"scores","nonMaxSuppressionAsync"),u=gl(o,i,n,r,s,a);n=u.maxOutputSize,r=u.iouThreshold,s=u.scoreThreshold,a=u.softNmsSigma;let c=await Promise.all([o.data(),i.data()]),l=c[0],p=c[1],{selectedIndices:d,selectedScores:h}=WT(l,p,n,r,s,a);return o!==e&&o.dispose(),i!==t&&i.dispose(),{selectedIndices:He(d,"int32"),selectedScores:He(h)}}var uB=iB;function cB(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,a=!1){let o=_(e,"boxes","nonMaxSuppression"),i=_(t,"scores","nonMaxSuppression"),u=gl(o,i,n,r,s,null),c=u.maxOutputSize,l=u.iouThreshold,p=u.scoreThreshold,d={boxes:o,scores:i},h={maxOutputSize:c,iouThreshold:l,scoreThreshold:p,padToMaxOutputSize:a},f=M.runKernel(Uc,d,h);return{selectedIndices:f[0],validOutputs:f[1]}}var lB=z({nonMaxSuppressionPadded_:cB});async function dB(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,a=!1){let o=_(e,"boxes","nonMaxSuppressionAsync"),i=_(t,"scores","nonMaxSuppressionAsync"),u=gl(o,i,n,r,s,null),c=u.maxOutputSize,l=u.iouThreshold,p=u.scoreThreshold,[d,h]=await Promise.all([o.data(),i.data()]),{selectedIndices:f,validOutputs:g}=BT(d,h,c,l,p,a);return o!==e&&o.dispose(),i!==t&&i.dispose(),{selectedIndices:He(f,"int32"),validOutputs:xe(g,"int32")}}var pB=dB;function hB(e,t,n=!1,r=!1){let s=_(e,"images","resizeBilinear");A(s.rank===3||s.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${s.rank}.`),A(t.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`),A(r===!1||n===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let a=s,o=!1;s.rank===3&&(o=!0,a=W(s,[1,s.shape[0],s.shape[1],s.shape[2]]));let[]=t,i={images:a},u={alignCorners:n,halfPixelCenters:r,size:t},c=M.runKernel(Ei,i,u);return o?W(c,[c.shape[1],c.shape[2],c.shape[3]]):c}var VT=z({resizeBilinear_:hB});function fB(e,t,n=!1,r=!1){let s=_(e,"images","resizeNearestNeighbor");A(s.rank===3||s.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${s.rank}.`),A(t.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`),A(s.dtype==="float32"||s.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),A(r===!1||n===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let a=s,o=!1;s.rank===3&&(o=!0,a=W(s,[1,s.shape[0],s.shape[1],s.shape[2]]));let[]=t,i={images:a},u={alignCorners:n,halfPixelCenters:r,size:t},c=M.runKernel(_i,i,u);return o?W(c,[c.shape[1],c.shape[2],c.shape[3]]):c}var UT=z({resizeNearestNeighbor_:fB});function mB(e,t="binary",n=!1,r=.5){let s=_(e,"image","threshold"),a=.2989,o=.587,i=.114,u=s.shape[0]*s.shape[1],c=B(He([r]),255),l,p,d,h;if(A(s.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${s.rank}.`),A(s.shape[2]===3||s.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${s.shape[2]}.`),A(s.dtype==="int32"||s.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${s.dtype}.`),A(t==="otsu"||t==="binary",()=>`Method must be binary or otsu, but was ${t}`),s.shape[2]===3){[l,p,d]=zn(s,[1,1,1],-1);let m=B(l,a),b=B(p,o),v=B(d,i);h=X(X(m,b),v)}else h=e;if(t==="otsu"){let m=Jx(ae(gm(h),"int32"),yn([]),256);c=gB(m,u)}let f=n?Da(h,c):Dn(h,c);return ae(B(f,255),"int32")}function gB(e,t){let n=He([-1]),r=He([0]),s=He([0]),a,o,i,u,c,l;for(let p=0;p<e.size-1;p++){a=Ue(e,0,p+1),o=Ue(e,p+1),c=fe(ge(a),t),l=fe(ge(o),t);let d=ge(B(a,xo(0,a.size)));i=fe(d,ge(a));let h=xn(o.shape,a.size),f=X(xo(0,o.size),h),g=B(o,f);u=fe(ge(g),ge(o));let m=de(i,u),b=de(i,u),v=B(c,l);s=B(B(v,m),b);let y=Dn(s,r);r=sn(y,s,r),n=sn(y,He([p]),n)}return n}var bB=z({threshold_:mB});function yB(e,t,n="nearest",r="constant",s=0,a){let o=_(e,"image","transform","float32"),i=_(t,"transforms","transform","float32");A(o.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${o.rank}.`),A(i.rank===2&&(i.shape[0]===o.shape[0]||i.shape[0]===1)&&i.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),A(a==null||a.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${a}.`);let u={image:o,transforms:i},c={interpolation:n,fillMode:r,fillValue:s,outputShape:a};return M.runKernel(il,u,c)}var vB=z({transform_:yB});function xB(e,t,n){let r=_(e,"a","bandPart");A(r.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`);let s=r.shape,[a,o]=r.shape.slice(-2),i,u;typeof t=="number"?(A(t%1===0,()=>`bandPart(): numLower must be an integer, got ${t}.`),A(t<=a,()=>`bandPart(): numLower (${t}) must not be greater than the number of rows (${a}).`),i=_(t<0?a:t,"numLower","bandPart")):(A(t.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),i=sn(qu(t,0),a,ga(t,a))),typeof n=="number"?(A(n%1===0,()=>`bandPart(): numUpper must be an integer, got ${n}.`),A(n<=o,()=>`bandPart(): numUpper (${n}) must not be greater than the number of columns (${o}).`),u=_(n<0?o:n,"numUpper","bandPart")):(A(n.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),u=sn(qu(n,0),o,ga(n,o)));let c=W(xo(0,a,1,"int32"),[-1,1]),l=xo(0,o,1,"int32"),p=de(c,l),d=Rr(Da(p,i),Ms(p,bt(u))),h=Ct([a,o],r.dtype);return W(Rt(dt(W(r,[-1,a,o])).map(f=>sn(d,f,h))),s)}var wB=z({bandPart_:xB});function IB(e){let t;if(Array.isArray(e)){t=!1,A(e!=null&&e.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");let s=e[0].shape[0];for(let a=1;a<e.length;++a)A(e[a].shape[0]===s,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[a].shape[0]} vs. ${s})`)}else t=!0,e=zn(e,e.shape[0],0).map(s=>Ra(s,[0]));A(e.length<=e[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`);let n=[],r=e;for(let s=0;s<e.length;++s)n.push(M.tidy(()=>{let a=r[s];if(s>0)for(let o=0;o<s;++o){let i=B(ge(B(n[o],a)),n[o]);a=de(a,i)}return fe(a,hl(a,"euclidean"))}));return t?Rt(n,0):n}var kB=z({gramSchmidt_:IB});function SB(e,t=!1){if(A(e.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`),e.rank===2)return yS(e,t);{let n=e.shape.slice(0,e.shape.length-2).reduce((u,c)=>u*c),r=dt(W(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),s=[],a=[];r.forEach(u=>{let[c,l]=yS(u,t);s.push(c),a.push(l)});let o=W(Rt(s,0),e.shape),i=W(Rt(a,0),e.shape);return[o,i]}}function yS(e,t=!1){return M.tidy(()=>{A(e.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`);let n=e.shape[0],r=e.shape[1],s=um(n),a=us(e),o=Fr([[1]],[1,1]),i=us(o),u=n>=r?r:n;for(let c=0;c<u;++c){let l=a,p=i,d=s;[i,a,s]=M.tidy(()=>{let h=Ue(a,[c,c],[n-c,1]),f=hl(h),g=Ue(a,[c,c],[1,1]),m=sn(Dn(g,0),Fr([[-1]]),Fr([[1]])),b=de(g,B(m,f)),v=fe(h,b);v.shape[0]===1?i=us(o):i=tt([o,Ue(v,[1,0],[v.shape[0]-1,v.shape[1]])],0);let y=bt(fe(Fe(m,b),f)),x=Ue(a,[c,0],[n-c,r]),k=B(y,i),S=Re(i);if(c===0)a=de(x,Fe(k,Fe(S,x)));else{let $=de(x,Fe(k,Fe(S,x)));a=tt([Ue(a,[0,0],[c,r]),$],0)}let N=Re(k),E=Ue(s,[0,c],[n,s.shape[1]-c]);if(c===0)s=de(E,Fe(Fe(E,i),N));else{let $=de(E,Fe(Fe(E,i),N));s=tt([Ue(s,[0,0],[n,c]),$],1)}return[i,a,s]}),_e([l,p,d])}return!t&&n>r&&(s=Ue(s,[0,0],[n,r]),a=Ue(a,[0,0],[r,r])),[s,a]})}var CB=z({qr_:SB}),Tn;(function(e){e[e.NONE=0]="NONE",e[e.MEAN=1]="MEAN",e[e.SUM=2]="SUM",e[e.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(Tn||(Tn={}));function TB(e,t,n=Tn.SUM_BY_NONZERO_WEIGHTS){let r=_(e,"losses","computeWeightedLoss"),s=null;t!=null&&(s=_(t,"weights","computeWeightedLoss"));let a=s==null?r:B(r,s);if(n===Tn.NONE)return a;if(n===Tn.SUM)return ge(a);if(n===Tn.MEAN){if(s==null)return Et(a);{let o=r.size/s.size,i=fe(ge(a),ge(s));return o>1?fe(i,xe(o)):i}}if(n===Tn.SUM_BY_NONZERO_WEIGHTS){if(s==null)return fe(ge(a),xe(r.size));{let o=B(s,er(r.shape)),i=ae(ge(vo(o,xe(0))),"float32");return fe(ge(a),i)}}throw Error(`Unknown reduction: ${n}`)}var Ls=z({computeWeightedLoss_:TB});function NB(e,t,n,r=Tn.SUM_BY_NONZERO_WEIGHTS){let s=_(e,"labels","absoluteDifference"),a=_(t,"predictions","absoluteDifference"),o=null;n!=null&&(o=_(n,"weights","absoluteDifference")),En(s.shape,a.shape,"Error in absoluteDifference: ");let i=Bt(de(s,a));return Ls(i,o,r)}var _B=z({absoluteDifference_:NB});function EB(e,t,n,r,s=Tn.SUM_BY_NONZERO_WEIGHTS){let a=_(e,"labels","cosineDistance"),o=_(t,"predictions","cosineDistance"),i=null;r!=null&&(i=_(r,"weights","cosineDistance")),En(a.shape,o.shape,"Error in cosineDistance: ");let u=xe(1),c=de(u,ge(B(a,o),n,!0));return Ls(c,i,s)}var AB=z({cosineDistance_:EB});function DB(e,t,n,r=Tn.SUM_BY_NONZERO_WEIGHTS){let s=_(e,"labels","hingeLoss"),a=_(t,"predictions","hingeLoss"),o=null;n!=null&&(o=_(n,"weights","hingeLoss")),En(s.shape,a.shape,"Error in hingeLoss: ");let i=xe(1);s=de(B(xe(2),s),i);let u=Ke(de(i,B(s,a)));return Ls(u,o,r)}var $B=z({hingeLoss_:DB});function FB(e,t,n,r=1,s=Tn.SUM_BY_NONZERO_WEIGHTS){let a=_(e,"labels","huberLoss"),o=_(t,"predictions","huberLoss"),i=null;n!=null&&(i=_(n,"weights","huberLoss")),En(a.shape,o.shape,"Error in huberLoss: ");let u=xe(r),c=Bt(de(o,a)),l=ga(c,u),p=de(c,l),d=X(B(xe(.5),ct(l)),B(u,p));return Ls(d,i,s)}var RB=z({huberLoss_:FB});function PB(e,t,n,r=1e-7,s=Tn.SUM_BY_NONZERO_WEIGHTS){let a=_(e,"labels","logLoss"),o=_(t,"predictions","logLoss"),i=null;n!=null&&(i=_(n,"weights","logLoss")),En(a.shape,o.shape,"Error in logLoss: ");let u=xe(1),c=xe(r),l=bt(B(a,rr(X(o,c)))),p=B(de(u,a),rr(X(de(u,o),c))),d=de(l,p);return Ls(d,i,s)}var OB=z({logLoss_:PB});function MB(e,t,n,r=Tn.SUM_BY_NONZERO_WEIGHTS){let s=_(e,"labels","meanSquaredError"),a=_(t,"predictions","meanSquaredError"),o=null;n!=null&&(o=_(n,"weights","meanSquaredError")),En(s.shape,a.shape,"Error in meanSquaredError: ");let i=km(s,a);return Ls(i,o,r)}var LB=z({meanSquaredError_:MB});function zB(e,t){let n=_(e,"labels","sigmoidCrossEntropyWithLogits"),r=_(t,"logits","sigmoidCrossEntropyWithLogits");En(n.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");let s=Ke(r),a=B(r,n),o=gp(vn(bt(Bt(r))));return X(de(s,a),o)}function BB(e,t,n,r=0,s=Tn.SUM_BY_NONZERO_WEIGHTS){let a=_(e,"multiClassLabels","sigmoidCrossEntropy"),o=_(t,"logits","sigmoidCrossEntropy"),i=null;if(n!=null&&(i=_(n,"weights","sigmoidCrossEntropy")),En(a.shape,o.shape,"Error in sigmoidCrossEntropy: "),r>0){let c=xe(r),l=xe(1),p=xe(.5);a=X(B(a,de(l,c)),B(p,c))}let u=zB(a,o);return Ls(u,i,s)}var WB=z({sigmoidCrossEntropy_:BB});function VB(e,t,n=-1){if(n===-1&&(n=t.rank-1),n!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${n}`);return ps((s,a,o)=>{let u=dm(a,[n],!0),c=de(ae(a,"float32"),u);o([s,c]);let l=bt(B(c,s));return{value:ge(l,[n]),gradFunc:(h,f)=>{let[g,m]=f,b=yo(h.shape,[n]);return[B(W(h,b),de(ae(g,"float32"),vn(m))),B(W(h,b),de(vn(m),ae(g,"float32")))]}}})(e,t)}function UB(e,t,n,r=0,s=Tn.SUM_BY_NONZERO_WEIGHTS){let a=_(e,"onehotLabels","softmaxCrossEntropy"),o=_(t,"logits","softmaxCrossEntropy"),i=null;if(n!=null&&(i=_(n,"weights","softmaxCrossEntropy")),En(a.shape,o.shape,"Error in softmaxCrossEntropy: "),r>0){let c=xe(r),l=xe(1),p=xe(a.shape[1]);a=X(B(a,de(l,c)),fe(c,p))}let u=VB(a,o);return Ls(u,i,s)}var GB=z({softmaxCrossEntropy_:UB});function HB(e,t,n,r){let s=_(e,"indices","sparseFillEmptyRows","int32"),a=_(t,"values","sparseFillEmptyRows"),o=_(n,"denseShape","sparseFillEmptyRows","int32"),i=_(r,"defaultValue","sparseFillEmptyRows",a.dtype);if(s.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${s.shape}`);if(a.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${a.shape}`);if(o.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${o.shape}`);if(i.rank!==0)throw new Error(`Default value should be a scalar but received shape ${i.shape}`);let u={indices:s,values:a,denseShape:o,defaultValue:i},c=M.runKernel(Yd,u);return{outputIndices:c[0],outputValues:c[1],emptyRowIndicator:c[2],reverseIndexMap:c[3]}}var jB=z({sparseFillEmptyRows_:HB});function qB(e,t,n){let r=_(e,"inputIndices","sparseReshape","int32"),s=_(t,"inputShape","sparseReshape","int32"),a=_(n,"newShape","sparseReshape","int32");if(r.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${r.shape}`);if(s.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${s.shape}`);if(a.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${a.shape}`);let o={inputIndices:r,inputShape:s,newShape:a},i=M.runKernel(rl,o);return{outputIndices:i[0],outputShape:i[1]}}var KB=z({sparseReshape_:qB});function XB(e,t,n){let r=_(e,"data","sparseSegmentMean"),s=_(t,"indices","sparseSegmentMean","int32"),a=_(n,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${s.shape}`);if(a.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${a.shape}`);let o={data:r,indices:s,segmentIds:a};return M.runKernel(Zd,o)}var YB=z({sparseSegmentMean_:XB});function ZB(e,t,n){let r=_(e,"data","sparseSegmentSum"),s=_(t,"indices","sparseSegmentSum","int32"),a=_(n,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${s.shape}`);if(a.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${a.shape}`);let o={data:r,indices:s,segmentIds:a};return M.runKernel(Jd,o)}var JB=z({sparseSegmentSum_:ZB});function QB(e,t,n,r,s,a,o,i){let u=_(e,"data","stringNGrams","string");if(u.dtype!=="string")throw new Error("Data must be of datatype string");if(u.shape.length!==1)throw new Error(`Data must be a vector, saw: ${u.shape}`);let c=_(t,"dataSplits","stringNGrams");if(c.dtype!=="int32")throw new Error("Data splits must be of datatype int32");let l={separator:n,nGramWidths:r,leftPad:s,rightPad:a,padWidth:o,preserveShortSequences:i},p={data:u,dataSplits:c},d=M.runKernel(tp,p,l);return{nGrams:d[0],nGramsSplits:d[1]}}var eW=z({stringNGrams_:QB});function tW(e,t,n=!0){let r=_(e,"input","stringSplit","string"),s=_(t,"delimiter","stringSplit","string");if(r.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(s.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${s.shape}`);let a={skipEmpty:n},o={input:r,delimiter:s},i=M.runKernel(np,o,a);return{indices:i[0],values:i[1],shape:i[2]}}var nW=z({stringSplit_:tW});function rW(e,t){let n=_(e,"input","stringToHashBucketFast","string"),r={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");let s={input:n};return M.runKernel(rp,s,r)}var sW=z({stringToHashBucketFast_:rW});function aW(e,t,n,r=!0){let s=_(e,"input","staticRegexReplace","string"),a={pattern:t,rewrite:n,replaceGlobal:r};return M.runKernel(ep,{x:s},a)}var oW=z({staticRegexReplace_:aW}),GT={fft:Ip,ifft:Zu,rfft:kp,irfft:Im},HT={hammingWindow:Rz,hannWindow:MT,frame:LT,stft:Lz},tr={flipLeftRight:Vz,grayscaleToRGB:Gz,resizeNearestNeighbor:UT,resizeBilinear:VT,rgbToGrayscale:jz,rotateWithOffset:Kz,cropAndResize:Bz,nonMaxSuppression:Yz,nonMaxSuppressionAsync:sB,nonMaxSuppressionWithScore:oB,nonMaxSuppressionWithScoreAsync:uB,nonMaxSuppressionPadded:lB,nonMaxSuppressionPaddedAsync:pB,threshold:bB,transform:vB},Gw={bandPart:wB,gramSchmidt:kB,qr:CB},jT={absoluteDifference:_B,computeWeightedLoss:Ls,cosineDistance:AB,hingeLoss:$B,huberLoss:RB,logLoss:OB,meanSquaredError:LB,sigmoidCrossEntropy:WB,softmaxCrossEntropy:GB},qT={sparseFillEmptyRows:jB,sparseReshape:KB,sparseSegmentMean:YB,sparseSegmentSum:JB},KT={stringNGrams:eW,stringSplit:nW,stringToHashBucketFast:sW,staticRegexReplace:oW},re={};Ee(re,{Serializable:()=>XT,SerializationMap:()=>Qa,getRegisteredName:()=>uW,registerClass:()=>YT});var iW=new Map,Wv=new Map,XT=class{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}},Qa=class{constructor(){this.classNameMap={}}static getMap(){return Qa.instance==null&&(Qa.instance=new Qa),Qa.instance}static register(e){Qa.getMap().classNameMap[e.className]=[e,e.fromConfig]}};function YT(e,t,n){A(e.className!=null,()=>"Class being registered does not have the static className property defined."),A(typeof e.className=="string",()=>"className is required to be a string, but got type "+typeof e.className),A(e.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof t>"u"&&(t="Custom"),typeof n>"u"&&(n=e.className);let r=n,s=t+">"+r;return Qa.register(e),iW.set(s,e),Wv.set(e,s),e}function uW(e){return Wv.has(e)?Wv.get(e):e.className}var zs=class extends XT{minimize(e,t=!1,n){let{value:r,grads:s}=this.computeGradients(e,n);if(n!=null){let a=n.map(o=>({name:o.name,tensor:s[o.name]}));this.applyGradients(a)}else this.applyGradients(s);return _e(s),t?r:(r.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return ZC(e,t)}dispose(){this.iterations_!=null&&_e(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:xe(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}};Object.defineProperty(zs,Symbol.hasInstance,{value:e=>e.minimize!=null&&e.computeGradients!=null&&e.applyGradients!=null});var Hw=class extends zs{static get className(){return"Adadelta"}constructor(e,t,n=null){super(),this.learningRate=e,this.rho=t,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],n==null&&(this.epsilon=M.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(n=>n.name):Object.keys(e)).forEach((n,r)=>{let s=M.registeredVariables[n],a=!1;this.accumulatedGrads[r]==null&&(this.accumulatedGrads[r]={originalName:`${n}/accum_grad`,variable:O(()=>je(s).variable(a))}),this.accumulatedUpdates[r]==null&&(this.accumulatedUpdates[r]={originalName:`${n}/accum_var`,variable:O(()=>je(s).variable(a))});let o=Array.isArray(e)?e[r].tensor:e[n];if(o==null)return;let i=this.accumulatedGrads[r].variable,u=this.accumulatedUpdates[r].variable;O(()=>{let c=X(B(i,this.rho),B(ct(o),1-this.rho)),l=B(fe(fn(X(u,this.epsilon)),fn(X(i,this.epsilon))),o),p=X(B(u,this.rho),B(ct(l),1-this.rho));i.assign(c),u.assign(p);let d=X(B(l,-this.learningRate),s);s.assign(d)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(_e(this.accumulatedGrads.map(e=>e.variable)),_e(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){let e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=e.length/2,n=!1;this.accumulatedGrads=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(n)})),this.accumulatedUpdates=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}},jw=class extends zs{static get className(){return"Adagrad"}constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(n=>n.name):Object.keys(e)).forEach((n,r)=>{let s=M.registeredVariables[n];this.accumulatedGrads[r]==null&&(this.accumulatedGrads[r]={originalName:`${n}/accumulator`,variable:O(()=>xn(s.shape,this.initialAccumulatorValue).variable(!1))});let a=Array.isArray(e)?e[r].tensor:e[n];if(a==null)return;let o=this.accumulatedGrads[r].variable;O(()=>{let i=X(o,ct(a));o.assign(i);let u=X(B(fe(a,fn(X(i,M.backend.epsilon()))),-this.learningRate),s);s.assign(u)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&_e(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=!1;this.accumulatedGrads=e.map(n=>({originalName:n.name,variable:n.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}},qw=class extends zs{static get className(){return"Adam"}constructor(e,t,n,r=null){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],O(()=>{this.accBeta1=xe(t).variable(),this.accBeta2=xe(n).variable()}),r==null&&(this.epsilon=M.backend.epsilon())}applyGradients(e){let t=Array.isArray(e)?e.map(n=>n.name):Object.keys(e);O(()=>{let n=de(1,this.accBeta1),r=de(1,this.accBeta2);t.forEach((s,a)=>{let o=M.registeredVariables[s],i=!1;this.accumulatedFirstMoment[a]==null&&(this.accumulatedFirstMoment[a]={originalName:`${s}/m`,variable:O(()=>je(o).variable(i))}),this.accumulatedSecondMoment[a]==null&&(this.accumulatedSecondMoment[a]={originalName:`${s}/v`,variable:O(()=>je(o).variable(i))});let u=Array.isArray(e)?e[a].tensor:e[s];if(u==null)return;let c=this.accumulatedFirstMoment[a].variable,l=this.accumulatedSecondMoment[a].variable,p=X(B(c,this.beta1),B(u,1-this.beta1)),d=X(B(l,this.beta2),B(ct(u),1-this.beta2)),h=fe(p,n),f=fe(d,r);c.assign(p),l.assign(d);let g=X(B(fe(h,X(fn(f),this.epsilon)),-this.learningRate),o);o.assign(g)}),this.accBeta1.assign(B(this.accBeta1,this.beta1)),this.accBeta2.assign(B(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&_e(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedSecondMoment!=null&&_e(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){let e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e),O(()=>{this.accBeta1.assign(Ps(this.beta1,this.iterations_+1)),this.accBeta2.assign(Ps(this.beta2,this.iterations_+1))});let t=e.length/2,n=!1;this.accumulatedFirstMoment=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(n)})),this.accumulatedSecondMoment=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}},Kw=class extends zs{static get className(){return"Adamax"}constructor(e,t,n,r=null,s=0){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.decay=s,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],O(()=>{this.iteration=xe(0).variable(),this.accBeta1=xe(t).variable()}),r==null&&(this.epsilon=M.backend.epsilon())}applyGradients(e){let t=Array.isArray(e)?e.map(n=>n.name):Object.keys(e);O(()=>{let n=de(1,this.accBeta1),r=fe(-this.learningRate,X(B(this.iteration,this.decay),1));t.forEach((s,a)=>{let o=M.registeredVariables[s],i=!1;this.accumulatedFirstMoment[a]==null&&(this.accumulatedFirstMoment[a]={originalName:`${s}/m`,variable:je(o).variable(i)}),this.accumulatedWeightedInfNorm[a]==null&&(this.accumulatedWeightedInfNorm[a]={originalName:`${s}/v`,variable:je(o).variable(i)});let u=Array.isArray(e)?e[a].tensor:e[s];if(u==null)return;let c=this.accumulatedFirstMoment[a].variable,l=this.accumulatedWeightedInfNorm[a].variable,p=X(B(c,this.beta1),B(u,1-this.beta1)),d=B(l,this.beta2),h=Bt(u),f=gs(d,h);c.assign(p),l.assign(f);let g=X(B(fe(r,n),fe(p,X(f,this.epsilon))),o);o.assign(g)}),this.iteration.assign(X(this.iteration,1)),this.accBeta1.assign(B(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&_e(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedWeightedInfNorm!=null&&_e(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}},Fm=class extends zs{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(n=>n.name):Object.keys(e)).forEach((n,r)=>{let s=Array.isArray(e)?e[r].tensor:e[n];if(s==null)return;let a=M.registeredVariables[n];O(()=>{let o=X(B(this.c,s),a);a.assign(o)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=qt(xe(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),e.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}},Xw=class extends Fm{static get className(){return"Momentum"}constructor(e,t,n=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=n,this.accumulations=[],this.m=xe(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(n=>n.name):Object.keys(e)).forEach((n,r)=>{let s=M.registeredVariables[n];this.accumulations[r]==null&&(this.accumulations[r]={originalName:`${n}/momentum`,variable:O(()=>je(s).variable(!1))});let a=this.accumulations[r].variable,o=Array.isArray(e)?e[r].tensor:e[n];o!=null&&O(()=>{let i,u=X(B(this.m,a),o);this.useNesterov?i=X(B(this.c,X(o,B(u,this.m))),s):i=X(B(this.c,u),s),a.assign(u),s.assign(i)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&_e(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=!1;this.accumulations=e.map(n=>({originalName:n.name,variable:n.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}},Yw=class extends zs{static get className(){return"RMSProp"}constructor(e,t=.9,n=0,r=null,s=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=n,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=s,r==null&&(this.epsilon=M.backend.epsilon()),e==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(n=>n.name):Object.keys(e)).forEach((n,r)=>{let s=M.registeredVariables[n],a=!1;this.accumulatedMeanSquares[r]==null&&(this.accumulatedMeanSquares[r]={originalName:`${n}/rms`,variable:O(()=>je(s).variable(a))}),this.accumulatedMoments[r]==null&&(this.accumulatedMoments[r]={originalName:`${n}/momentum`,variable:O(()=>je(s).variable(a))}),this.accumulatedMeanGrads[r]==null&&this.centered&&(this.accumulatedMeanGrads[r]={originalName:`${n}/mg`,variable:O(()=>je(s).variable(a))});let o=Array.isArray(e)?e[r].tensor:e[n];if(o==null)return;let i=this.accumulatedMeanSquares[r].variable,u=this.accumulatedMoments[r].variable;O(()=>{let c=X(B(i,this.decay),B(ct(o),1-this.decay));if(this.centered){let l=this.accumulatedMeanGrads[r].variable,p=X(B(l,this.decay),B(o,1-this.decay)),d=fe(B(o,this.learningRate),fn(de(c,X(ct(p),this.epsilon)))),h=X(B(u,this.momentum),d);i.assign(c),l.assign(p),u.assign(h);let f=de(s,h);s.assign(f)}else{let l=X(B(i,this.decay),B(ct(o),1-this.decay)),p=X(B(u,this.momentum),fe(B(o,this.learningRate),fn(X(l,this.epsilon))));i.assign(l),u.assign(p);let d=de(s,p);s.assign(d)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&_e(this.accumulatedMeanSquares.map(e=>e.variable)),this.accumulatedMeanGrads!=null&&this.centered&&_e(this.accumulatedMeanGrads.map(e=>e.variable)),this.accumulatedMoments!=null&&_e(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){let e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=this.centered?e.length/3:e.length/2,n=!1;this.accumulatedMeanSquares=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(n)})),this.accumulatedMoments=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(n)})),this.centered&&(this.accumulatedMeanGrads=e.slice(t*2,t*3).map(r=>({originalName:r.name,variable:r.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}},cW=[Hw,jw,qw,Kw,Xw,Yw,Fm];function lW(){for(let e of cW)YT(e)}var Kt={};Ee(Kt,{CompositeArrayBuffer:()=>fs,browserFiles:()=>bW,browserHTTPRequest:()=>IW,concatenateArrayBuffers:()=>LP,copyModel:()=>oO,decodeWeights:()=>kC,encodeWeights:()=>RP,fromMemory:()=>SW,fromMemorySync:()=>tN,getLoadHandlers:()=>jP,getModelArtifactsForJSON:()=>Ox,getModelArtifactsForJSONSync:()=>CC,getModelArtifactsInfoForJSON:()=>lp,getSaveHandlers:()=>HP,getWeightSpecs:()=>TC,http:()=>Jw,isHTTPScheme:()=>Vv,listModels:()=>sO,loadWeights:()=>yW,moveModel:()=>iO,registerLoadRouter:()=>GP,registerSaveRouter:()=>UP,removeModel:()=>aO,weightsLoaderFactory:()=>JT,withSaveHandler:()=>CW,withSaveHandlerSync:()=>TW});var dW="model",pW=".json",hW=".weights.bin";function vS(e){return new Promise(t=>setTimeout(t)).then(e)}var Qu=class{constructor(e){if(!G().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(Qu.URL_SCHEME)&&(e=e.slice(Qu.URL_SCHEME.length)),(e==null||e.length===0)&&(e=dW),this.modelJsonFileName=e+pW,this.weightDataFileName=e+hW}async save(e){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");let t=fs.join(e.weightData),n=window.URL.createObjectURL(new Blob([t],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{let r=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],s=SC(e,r),a=window.URL.createObjectURL(new Blob([JSON.stringify(s)],{type:"application/json"})),o=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(o.download=this.modelJsonFileName,o.href=a,await vS(()=>o.dispatchEvent(new MouseEvent("click"))),e.weightData!=null){let i=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;i.download=this.weightDataFileName,i.href=n,await vS(()=>i.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:lp(e)}}}};Qu.URL_SCHEME="downloads://";var fW=class{constructor(e){if(e==null||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,t)=>{let n=new FileReader;n.onload=r=>{let s=JSON.parse(r.target.result),a=s.modelTopology;if(a==null){t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(s.weightsManifest==null){t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){e({modelTopology:a});return}let i=Ox(s,u=>this.loadWeights(u));e(i)},n.onerror=r=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),n.readAsText(this.jsonFile)})}loadWeights(e){let t=[],n=[];for(let a of e)t.push(...a.weights),n.push(...a.paths);let r=this.checkManifestAndWeightFiles(e),s=n.map(a=>this.loadWeightsFile(a,r[a]));return Promise.all(s).then(a=>[t,a])}loadWeightsFile(e,t){return new Promise((n,r)=>{let s=new FileReader;s.onload=a=>{let o=a.target.result;n(o)},s.onerror=a=>r(`Failed to weights data from file of path '${e}'.`),s.readAsArrayBuffer(t)})}checkManifestAndWeightFiles(e){let t=[],n=this.weightsFiles.map(s=>gS(s.name)),r={};for(let s of e)s.paths.forEach(a=>{let o=gS(a);if(t.indexOf(o)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${o}'`);if(t.push(o),n.indexOf(o)===-1)throw new Error(`Weight file with basename '${o}' is not provided.`);r[a]=this.weightsFiles[n.indexOf(o)]});if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return r}},mW=e=>G().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Qu.URL_SCHEME)?gW(e.slice(Qu.URL_SCHEME.length)):null;Ft.registerSaveRouter(mW);function gW(e="model"){return new Qu(e)}function bW(e){return new fW(e)}function xS(e,t,n,r){o(e),n=n??0,r=r??1,i(n,r);let s=0,a=u=>(u.then(c=>{let l=n+ ++s/e.length*(r-n);return t(l),c}),u);function o(u){A(u!=null&&Array.isArray(u)&&u.length>0,()=>"promises must be a none empty array")}function i(u,c){A(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${u}`),A(c>=0&&c<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${c}`),A(c>=u,()=>`startFraction must be no more than endFraction, but got startFraction ${u} and endFraction ${c}`)}return Promise.all(e.map(a))}async function ZT(e,t){t==null&&(t={});let n=t.fetchFunc==null?G().platform.fetch:t.fetchFunc,r=e.map(p=>n(p,t.requestInit,{isBinary:!0})),s=0,a=.5,i=(t.onProgress==null?await Promise.all(r):await xS(r,t.onProgress,s,a)).map(p=>p.arrayBuffer()),u=.5,c=1;return t.onProgress==null?await Promise.all(i):await xS(i,t.onProgress,u,c)}async function yW(e,t="",n,r){return JT(o=>ZT(o,{requestInit:r}))(e,t,n)}function JT(e){return async(t,n="",r)=>{let s=t.map(()=>!1),a={},o=r!=null?r.map(()=>!1):[],i=[];if(t.forEach((h,f)=>{let g=0;h.weights.forEach(m=>{let b="quantization"in m?m.quantization.dtype:m.dtype,v=Pv[b]*gt(m.shape),y=()=>{s[f]=!0,a[f]==null&&(a[f]=[]),a[f].push({manifestEntry:m,groupOffset:g,sizeBytes:v})};r!=null?r.forEach((x,k)=>{x===m.name&&(y(),o[k]=!0)}):y(),i.push(m.name),g+=v})}),!o.every(h=>h)){let h=r.filter((f,g)=>!o[g]);throw new Error(`Could not find weights in manifest with names: ${h.join(", ")}. 
Manifest JSON has weights with names: ${i.join(", ")}.`)}let u=s.reduce((h,f,g)=>(f&&h.push(g),h),[]),c=[];u.forEach(h=>{t[h].paths.forEach(f=>{let g=n+(n.endsWith("/")?"":"/")+f;c.push(g)})});let l=await e(c),p={},d=0;return u.forEach(h=>{let f=t[h].paths.length,g=new fs(l.slice(d,d+f));a[h].forEach(b=>{let v=g.slice(b.groupOffset,b.groupOffset+b.sizeBytes),y=kC(v,[b.manifestEntry]);for(let x in y)p[x]=y[x]}),d+=f}),p}}var vW="application/octet-stream",xW="application/json",Zw=class{constructor(e,t){if(this.DEFAULT_METHOD="POST",t==null&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.onProgress=t.onProgress,this.weightUrlConverter=t.weightUrlConverter,t.fetchFunc!=null?(A(typeof t.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=G().platform.fetch,A(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&A(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,t.requestInit!=null&&t.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{}}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");let t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;let n=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],r=SC(e,n);if(t.body.append("model.json",new Blob([JSON.stringify(r)],{type:xW}),"model.json"),e.weightData!=null){let a=fs.join(e.weightData);t.body.append("model.weights.bin",new Blob([a],{type:vW}),"model.weights.bin")}let s=await this.fetch(this.path,t);if(s.ok)return{modelArtifactsInfo:lp(e),responses:[s]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${s.status}.`)}async load(){let e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch{let a=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?a+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":a+=" Please make sure the server is serving valid JSON for this request.",new Error(a)}let n=t.modelTopology,r=t.weightsManifest;if(n==null&&r==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return Ox(t,s=>this.loadWeights(s))}async loadWeights(e){let t=Array.isArray(this.path)?this.path[1]:this.path,[n,r]=wW(t),s=this.weightPathPrefix||n,a=TC(e),o=[],i=[];for(let c of e)for(let l of c.paths)this.weightUrlConverter!=null?i.push(this.weightUrlConverter(l)):o.push(s+l+r);this.weightUrlConverter&&o.push(...await Promise.all(i));let u=await ZT(o,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress});return[a,u]}};Zw.URL_SCHEME_REGEX=/^https?:\/\//;function wW(e){let t=e.lastIndexOf("/"),n=e.lastIndexOf("?"),r=e.substring(0,t),s=n>t?e.substring(n):"";return[r+"/",s]}function Vv(e){return e.match(Zw.URL_SCHEME_REGEX)!=null}var QT=(e,t)=>{if(typeof fetch>"u"&&(t==null||t.fetchFunc==null))return null;{let n=!0;if(Array.isArray(e)?n=e.every(r=>Vv(r)):n=Vv(e),n)return Jw(e,t)}return null};Ft.registerSaveRouter(QT);Ft.registerLoadRouter(QT);function Jw(e,t){return new Zw(e,t)}function IW(e,t){return Jw(e,t)}var gv=class{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}},eN=class{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}},kW=class{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}};function SW(e,t,n,r){let s=arguments;return new kW(tN(...s))}function tN(e,t,n,r){return arguments.length===1?e.modelTopology!=null||e.weightSpecs!=null?new gv(e):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new gv({modelTopology:e})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new gv({modelTopology:e,weightSpecs:t,weightData:n,trainingConfig:r}))}function CW(e){return new eN(e)}function TW(e){return new eN(e)}var nN={};Ee(nN,{confusionMatrix:()=>_W});function NW(e,t,n){let r=_(e,"labels","confusionMatrix"),s=_(t,"predictions","confusionMatrix");A(n==null||n>0&&Number.isInteger(n),()=>`If provided, numClasses must be a positive integer, but got ${n}`),A(r.rank===1,()=>`Expected the rank of labels to be 1, but got ${r.rank}`),A(s.rank===1,()=>`Expected the rank of predictions to be 1, but got ${s.rank}`),A(r.shape[0]===s.shape[0],()=>`Mismatch in the number of examples: ${r.shape[0]} vs. ${s.shape[0]}. Labels and predictions should have the same number of elements.`),A(n>0&&Number.isInteger(n),()=>`numClasses is required to be a positive integer, but got ${n}`);let a=Ku(ae(r,"int32"),n),o=Ku(ae(s,"int32"),n),i=Re(a),u=Fe(i,o);return ae(u,"int32")}var _W=z({confusionMatrix_:NW}),Yi={};Ee(Yi,{draw:()=>OW,fromPixels:()=>MW,fromPixelsAsync:()=>FW,toPixels:()=>PW});var qa,wS=!1;function rN(e,t=3){if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(e==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,r=!1,s=!1,a=!1,o=!1,i=!1;if(e.data instanceof Uint8Array)n=!0;else if(typeof ImageData<"u"&&e instanceof ImageData)r=!0;else if(typeof HTMLVideoElement<"u"&&e instanceof HTMLVideoElement)s=!0;else if(typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement)a=!0;else if(e.getContext!=null)o=!0;else if(typeof ImageBitmap<"u"&&e instanceof ImageBitmap)i=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${e.constructor.name}`);if(xd(lf,M.backendName)!=null){let f={pixels:e},g={numChannels:t};return M.runKernel(lf,f,g)}let[c,l]=s?[e.videoWidth,e.videoHeight]:[e.width,e.height],p;if(o)p=e.getContext("2d").getImageData(0,0,c,l).data;else if(r||n)p=e.data;else if(a||s||i){if(qa==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")qa=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else qa=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});qa.canvas.width=c,qa.canvas.height=l,qa.drawImage(e,0,0,c,l),p=qa.getImageData(0,0,c,l).data}let d;if(t===4)d=new Int32Array(p);else{let f=c*l;d=new Int32Array(f*t);for(let g=0;g<f;g++)for(let m=0;m<t;++m)d[g*t+m]=p[g*4+m]}return Sp(d,[l,c,t],"int32")}function EW(e){return e!=null&&e.data instanceof Uint8Array}function AW(){return typeof window<"u"&&typeof ImageBitmap<"u"&&window.hasOwnProperty("createImageBitmap")}function DW(e){return e!=null&&e.width!==0&&e.height!==0}function $W(e){return AW()&&!(e instanceof ImageBitmap)&&DW(e)&&!EW(e)}async function FW(e,t=3){let n=null;if(G().getBool("WRAP_TO_IMAGEBITMAP")&&$W(e)){let r;try{r=await createImageBitmap(e,{premultiplyAlpha:"none"})}catch{r=null}r!=null&&r.width===e.width&&r.height===e.height?n=r:n=e}else n=e;return rN(n,t)}function sN(e){if(e.rank!==2&&e.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${e.rank}.`);let t=e.rank===2?1:e.shape[2];if(t>4||t===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${t}`);if(e.dtype!=="float32"&&e.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${e.dtype}. Please use float32 or int32 tensors.`)}function RW(e){let t=e?.alpha||1;if(t>1||t<0)throw new Error(`Alpha value ${t} is suppoed to be in range [0 - 1].`)}async function PW(e,t){let n=_(e,"img","toPixels");if(!(e instanceof Te)){let c=n;n=ae(c,"int32"),c.dispose()}sN(n);let[r,s]=n.shape.slice(0,2),a=n.rank===2?1:n.shape[2],o=await n.data(),i=n.dtype==="float32"?255:1,u=new Uint8ClampedArray(s*r*4);for(let c=0;c<r*s;++c){let l=[0,0,0,255];for(let d=0;d<a;d++){let h=o[c*a+d];if(n.dtype==="float32"){if(h<0||h>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${h}.`)}else if(n.dtype==="int32"&&(h<0||h>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${h}.`);a===1?(l[0]=h*i,l[1]=h*i,l[2]=h*i):l[d]=h*i}let p=c*4;u[p+0]=Math.round(l[0]),u[p+1]=Math.round(l[1]),u[p+2]=Math.round(l[2]),u[p+3]=Math.round(l[3])}if(t!=null){wS||xd(Gf,M.backendName)!=null&&(console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."),wS=!0),t.width=s,t.height=r;let c=t.getContext("2d"),l=new ImageData(u,s,r);c.putImageData(l,0,0)}return n!==e&&n.dispose(),u}function OW(e,t,n){let r=_(e,"img","draw");if(!(e instanceof Te)){let o=r;r=ae(o,"int32"),o.dispose()}sN(r),RW(n?.imageOptions);let s={image:r},a={canvas:t,options:n};M.runKernel(Gf,s,a)}var MW=z({fromPixels_:rN}),Qw={};Ee(Qw,{prepareAndValidate:()=>aN});function aN(e,t){let n=e.shape.length,r=t.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if(t.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[r-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[r-1]} vs. ${n}`);if(gt(e.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);let s=t.shape,a=s[s.length-1],o=1;for(let p=0;p<s.length-1;++p)o*=s[p];let i=e.shape,u=s.slice();u.pop();let c=1;for(let p=a;p<n;++p)c*=i[p],u.push(i[p]);let l=[...uc(e.shape).map(p=>p/c),1].slice(0,a);return[u,o,c,l]}var Yt={};Ee(Yt,{assertParamsValid:()=>zW,computeFlatOffset:()=>GW,computeOutShape:()=>WW,getNormalizedAxes:()=>VW,isSliceContinous:()=>UW,maskToAxes:()=>BW,parseSliceParams:()=>fN,sliceInfo:()=>HW,startForAxis:()=>pN,startIndicesWithElidedDims:()=>cN,stopForAxis:()=>hN,stopIndicesWithElidedDims:()=>lN,stridesForAxis:()=>dN,stridesWithElidedDims:()=>oN});var Uv=-2,LW=-1;function zW(e,t,n){let r=e.shape.length;A(r===t.length,()=>`Error in slice${r}D: Length of begin ${t} must match the rank of the array (${r}).`),A(r===n.length,()=>`Error in slice${r}D: Length of size ${n} must match the rank of the array (${r}).`);for(let s=0;s<r;++s)A(t[s]+n[s]<=e.shape[s],()=>`Error in slice${r}D: begin[${s}] + size[${s}] (${t[s]+n[s]}) would overflow input.shape[${s}] (${e.shape[s]})`)}function BW(e){let t=[],n=0;for(;e>0;)e&1&&t.push(n),e/=2,n++;return t}function WW(e,t,n){let r=[];for(let s=0;s<e.length;s++)r[s]=Math.ceil((t[s]-e[s])/n[s]);return r}function oN(e,t,n,r){let s=[...e];for(let a=s.length;a<r.length;a++)s.push(1);for(let a=0;a<n;a++)a===0?s[t]=1:(s.splice(t,0,1),s.pop());return s}function iN(e,t,n){return n<=e?n:n-(t-1)}function uN(e,t){let n=[];for(let r=0;r<e;r++)n.push(t+r);return n}function VW(e,t,n,r,s,a,o,i,u){let c=e.length,l=new Array(c),p=new Array(c),d=new Array(c);if(t.length&&n>0){let h=t[0],f=n+1;l=cN(o,h,f,r,e),p=lN(i,h,f,s,e),d=oN(a,h,f,e)}else for(let h=0;h<c;h++)l[h]=pN(o,r,a,e,h,u),p[h]=hN(i,s,a,e,h,u),d[h]=dN(a,h,u);return{begin:l,end:p,strides:d}}function cN(e,t,n,r,s){let a=[...s],o=uN(n,t);for(let i=0;i<a.length;i++)if(o.indexOf(i)>-1)a[i]=0;else{let u=iN(t,n,i),c=r[u];e&1<<u&&(c=0),a[i]=c}return a}function lN(e,t,n,r,s){let a=[...s],o=uN(n,t);for(let i=0;i<a.length;i++)if(o.indexOf(i)>-1)a[i]=Number.MAX_SAFE_INTEGER;else{let u=iN(t,n,i),c=r[u];e&1<<u&&(c=Number.MAX_SAFE_INTEGER),a[i]=c}for(let i=0;i<a.length;i++){let u=s[i];a[i]<0&&(a[i]+=u),a[i]=yd(0,a[i],s[i])}return a}function dN(e,t,n){let r=e[t];return(n&1<<t||r==null)&&(r=1),r}function pN(e,t,n,r,s,a){let o=t[s],i=n[s]||1;(e&1<<s||a&1<<s||o==null)&&(i>0?o=Number.MIN_SAFE_INTEGER:o=Number.MAX_SAFE_INTEGER);let u=r[s];return o<0&&(o+=u),o=yd(0,o,u-1),o}function hN(e,t,n,r,s,a){let o=t[s],i=n[s]||1;(e&1<<s||a&1<<s||o==null)&&(i>0?o=Number.MAX_SAFE_INTEGER:o=Number.MIN_SAFE_INTEGER);let u=r[s];return o<0&&(o+=u),i>0?o=yd(0,o,u):o=yd(-1,o,u-1),o}function UW(e,t,n){let r=n.length;for(let s=0;s<n.length;s++)if(n[s]>1){r=s;break}for(let s=r+1;s<n.length;s++)if(t[s]>0||n[s]!==e[s])return!1;return!0}function GW(e,t){let n=e.length>0?e[e.length-1]:1;for(let r=0;r<e.length-1;r++)n+=e[r]*t[r];return n}function fN(e,t,n){let r,s=e.shape.length;typeof t=="number"?r=[t,...new Array(s-1).fill(0)]:t.length<s?r=t.concat(new Array(s-t.length).fill(0)):r=t.slice(),r.forEach(o=>{A(o!==-1,()=>"slice() does not support negative begin indexing.")});let a;return n==null?a=new Array(s).fill(-1):typeof n=="number"?a=[n,...new Array(s-1).fill(-1)]:n.length<s?a=n.concat(new Array(s-n.length).fill(-1)):a=n,a=a.map((o,i)=>o>=0?o:(A(o===-1,()=>`Negative size values should be exactly -1 but got ${o} for the slice() size at index ${i}.`),e.shape[i]-r[i])),[r,a]}function HW(e,t,n,r,s,a,o,i,u){let c;if(r==null?(c=new Array(t.length),c.fill(1)):c=r,o!=null&&o&o-1)throw new Error("Multiple ellipses in slice is not allowed.");let l=!1,p={dims:c.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:c.slice(),beginMask:s,endMask:a,ellipsisMask:o,newAxisMask:i,shrinkAxisMask:u};for(let y=0;y<p.dims;y++)l&&1<<y&i&&p.numAddAxisAfterEllipsis++,1<<y&o&&(l=!0);l||(p.ellipsisMask|=1<<p.dims,p.dims++);let d={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};jW(p,d);let h=!0,f=!0,g=!0,m=[],b=[];for(let y=0;y<e.length;++y){if(d.strides[y]===0)throw Error(`strides[${y}] must be non-zero`);let x=!!(d.shrinkAxisMask&1<<y),k=e[y];if(k===-1){m.push(x?1:-1);continue}let S=[d.beginMask&1<<y,d.endMask&1<<y],N=[d.strides[y]>0?0:-1,d.strides[y]>0?k:k-1];if(x&&d.strides[y]<=0)throw Error("only stride 1 allowed on non-range indexing.");g=g&&d.strides[y]===1;let E=!!(d.beginMask&1<<y&&d.endMask&1<<y);if(d.beginValid&&d.endValid){if(x){let F=d.begin[y]<0?k+d.begin[y]:d.begin[y];if(d.begin[y]=F,d.end[y]=d.begin[y]+1,F<0||F>=k)throw Error(`slice index ${d.begin[y]} of dimension ${y} out of bounds.`)}else d.begin[y]=IS(d.begin[y],0,d.strides[y],k,S,N),d.end[y]=IS(d.end[y],1,d.strides[y],k,S,N);let D=d.strides[y]===1&&d.begin[y]===0&&d.end[y]===k;h=h&&D,f=f&&(y===0&&d.strides[y]===1||D)}else h=h&&d.strides[y]===1&&E,f=f&&(y===0&&d.strides[y]===1||E);let $,R=!1;if(d.beginValid&&d.endValid?($=d.end[y]-d.begin[y],R=!0):x?($=1,R=!0):E&&k>=0&&(d.strides[y]<0?$=-k:$=k,R=!0),R){let D;$===0||$<0!=d.strides[y]<0?D=0:D=Math.trunc($/d.strides[y])+($%d.strides[y]!==0?1:0),m.push(D)}else m.push(-1)}for(let y=0;y<d.finalShapeGatherIndices.length;++y){let x=d.finalShapeGatherIndices[y];x>=0?b.push(m[x]):x===Uv&&b.push(1)}return{finalShapeSparse:b.filter((y,x)=>d.finalShapeGatherIndices[x]!==Uv),finalShape:b,isIdentity:h,sliceDim0:f,isSimpleSlice:g,begin:d.begin,end:d.end,strides:d.strides}}function jW(e,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let n=0;t.beginValid=e.begin!=null,t.endValid=e.end!=null,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let r=0;r<e.dims;r++)if(1<<r&e.ellipsisMask){let s=Math.min(t.dims-(e.dims-r)+1+e.numAddAxisAfterEllipsis,t.dims);for(;n<s;n++)t.begin[n]=0,t.end[n]=0,t.strides[n]=1,t.beginMask|=1<<n,t.endMask|=1<<n,t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[n]=r}else if(1<<r&e.newAxisMask)t.finalShapeGatherIndices.push(Uv),t.finalShapeGatherIndicesSparse.push(-1);else{if(n===t.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${t.dims} dims, ${t.begin.length}.`);e.begin!=null&&(t.begin[n]=e.begin[r]),e.end!=null&&(t.end[n]=e.end[r]),t.strides[n]=e.strides[r],e.beginMask&1<<r&&(t.beginMask|=1<<n),e.endMask&1<<r&&(t.endMask|=1<<n),e.shrinkAxisMask&1<<r?(t.finalShapeGatherIndices.push(LW),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<n):(t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(r)),t.inputShapeGatherIndicesSparse[n]=r,n++}}function IS(e,t,n,r,s,a){if(s[t])return n>0?a[t]:a[t+1&1];{let o=e<0?r+e:e;return o<a[0]?a[0]:o>a[1]?a[1]:o}}var qW="4.9.0",mN=class{static sgd(e){return new Fm(e)}static momentum(e,t,n=!1){return new Xw(e,t,n)}static rmsprop(e,t=.9,n=0,r=null,s=!1){return new Yw(e,t,n,r,s)}static adam(e=.001,t=.9,n=.999,r=null){return new qw(e,t,n,r)}static adadelta(e=.001,t=.95,n=null){return new Hw(e,t,n)}static adamax(e=.002,t=.9,n=.999,r=null,s=0){return new Kw(e,t,n,r,s)}static adagrad(e,t=.1){return new jw(e,t)}},Ya=mN,KW=(()=>typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:e=>e())();function eI(){return new Promise(e=>KW(()=>e()))}var T={};Ee(T,{ERF_A1:()=>cV,ERF_A2:()=>lV,ERF_A3:()=>dV,ERF_A4:()=>pV,ERF_A5:()=>hV,ERF_P:()=>uV,PARALLELIZE_THRESHOLD:()=>tI,RowPartitionType:()=>ss,SELU_SCALE:()=>bN,SELU_SCALEALPHA:()=>gN,applyActivation:()=>Dm,assertAndGetBroadcastShape:()=>lt,assertAxesAreInnerMostDims:()=>j3,assertParamsConsistent:()=>XW,assignToTypedArray:()=>vV,axesAreInnerMostDims:()=>pw,calculateShapes:()=>CT,checkEinsumDimSizes:()=>CV,checkPadOnDimRoundingMode:()=>An,combineLocations:()=>jC,combineRaggedTensorToTensorShapes:()=>ZW,complexWithEvenIndex:()=>gV,complexWithOddIndex:()=>bV,computeConv2DInfo:()=>dp,computeConv3DInfo:()=>MC,computeDefaultPad:()=>qx,computeDilation2DInfo:()=>GO,computeOptimalWindowSize:()=>tV,computeOutAndReduceShapes:()=>qC,computeOutShape:()=>YW,computePool2DInfo:()=>OC,computePool3DInfo:()=>HO,convertConv2DDataFormat:()=>LC,decodeEinsumEquation:()=>kV,eitherStridesOrDilationsAreOne:()=>ms,expandShapeToKeepDim:()=>yo,exponent:()=>wV,exponents:()=>xV,fromStringArrayToUint8:()=>jV,fromUint8ToStringArray:()=>HV,getAxesPermutation:()=>KC,getBroadcastDims:()=>GC,getComplexWithIndex:()=>yV,getEinsumComputePath:()=>TV,getEinsumPermutation:()=>SV,getFusedBiasGradient:()=>Am,getFusedDyActivation:()=>Em,getImageCenter:()=>nV,getInnerMostAxes:()=>q3,getPermuted:()=>sV,getRaggedRank:()=>QW,getReductionAxes:()=>Ut,getReshaped:()=>rV,getReshapedPermuted:()=>aV,getRowPartitionTypesHelper:()=>JW,getSliceBeginCoords:()=>oV,getSliceSize:()=>iV,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>AV,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>DV,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>$V,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>PV,getSparseReshapeInputOutputMismatchErrorMessage:()=>MV,getSparseReshapeInputOutputMultipleErrorMessage:()=>OV,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>FV,getSparseReshapeNegativeOutputDimErrorMessage:()=>RV,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>WV,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>LV,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>zV,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>BV,getUndoAxesPermutation:()=>hw,isIdentityPermutation:()=>NV,log:()=>tP,mergeRealAndImagArrays:()=>fV,prepareAndValidate:()=>aN,prepareSplitSize:()=>EV,segment_util:()=>yN,shouldFuse:()=>$m,slice_util:()=>Yt,splitRealAndImagArrays:()=>mV,stridesOrDilationsArePositive:()=>go,tupleValuesAreOne:()=>ma,upcastType:()=>mr,validateDefaultValueShape:()=>eV,validateInput:()=>Cm,validateUpdateShape:()=>Pw,warn:()=>sa});function XW(e,t){let n=e[0].length;e.forEach((s,a)=>{A(s.length===n,()=>`Error in concat${n}D: rank of tensors[${a}] must be the same as the rank of the rest (${n})`)}),A(t>=0&&t<n,()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`);let r=e[0];e.forEach((s,a)=>{for(let o=0;o<n;o++)A(o===t||s[o]===r[o],()=>`Error in concat${n}D: Shape of tensors[${a}] (${s}) does not match the shape of the rest (${r}) along the non-concatenated axis ${a}.`)})}function YW(e,t){let n=e[0].slice();for(let r=1;r<e.length;r++)n[t]+=e[r][t];return n}var ss;(function(e){e[e.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",e[e.VALUE_ROWIDS=1]="VALUE_ROWIDS",e[e.ROW_LENGTHS=2]="ROW_LENGTHS",e[e.ROW_SPLITS=3]="ROW_SPLITS",e[e.ROW_LIMITS=4]="ROW_LIMITS",e[e.ROW_STARTS=5]="ROW_STARTS"})(ss||(ss={}));function ZW(e,t,n){let r=new Array;if(n==null&&t==null)return r;if(t==null)for(;r.length<e+n.length;)r.push(-1);else r=t.slice();if(n==null)return r;if(e+n.length!==r.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${e+n.length}, but shape.rank = ${r.length}`);for(let s=1;s<n.length;++s){let a=n[s],o=r[r.length-n.length+s],i=r[o];if(a>=0)if(i>=0){if(i!==a)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${s+e}] = ${a} but shape[${s+e}] = ${i}`)}else r[o]=a}return r}function JW(e){let t={FIRST_DIM_SIZE:ss.FIRST_DIM_SIZE,VALUE_ROWIDS:ss.VALUE_ROWIDS,ROW_LENGTHS:ss.ROW_LENGTHS,ROW_SPLITS:ss.ROW_SPLITS,ROW_LIMITS:ss.ROW_LIMITS,ROW_STARTS:ss.ROW_STARTS},n=[];for(let r of e)if(r in t)n.push(t[r]);else break;return n}function QW(e){return e.length===0?0:e[0]===ss.FIRST_DIM_SIZE?e.length-1:e.length}function eV(e,t){if(e==null||t==null)return;let n=e.length,r=t.length;if(n>=r)throw new Error(`defaultValue.shape=${e} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${n} must be less than ragged tensor input flatValues.rank = ${r})`);for(let s=0;s<Math.min(n,r-1);++s){let a=e[s],o=t[s+1];if(a>=0&&o>=0&&a!==1&&a!==o)throw new Error(`defaultValue.shape=${e}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${s-e.length}] = ${a} but ragged tensor input.flatValues.shape[${s-e.length}] = ${o}`)}}var tI=30;function tV(e){return e<=tI?e:cf(e,Math.floor(Math.sqrt(e)))}function nV(e,t,n){let r=n*(typeof e=="number"?e:e[0]),s=t*(typeof e=="number"?e:e[1]);return[r,s]}function rV(e,t,n,r=!0){let s=[];if(r)s=s.concat(t.slice(0)),s.push(e[0]/n),s=s.concat(e.slice(1));else{s=s.concat(e[0]);let a=t.length;for(let o=0;o<a;++o)s=s.concat([e[o+1]/t[o],t[o]]);s=s.concat(e.slice(a+1))}return s}function sV(e,t,n=!0){let r=[];if(n){r.push(t);for(let s=t+1;s<e;++s)s<=2*t?(r.push(s),r.push(s-(t+1))):r.push(s)}else{let s=[],a=[];for(let o=1;o<e;++o)o>=t*2+1||o%2===1?a.push(o):s.push(o);r.push(...s),r.push(0),r.push(...a)}return r}function aV(e,t,n,r=!0){let s=[];r?s.push(e[0]/n):s.push(e[0]*n);for(let a=1;a<e.length;++a)a<=t.length?r?s.push(t[a-1]*e[a]):s.push(e[a]/t[a-1]):s.push(e[a]);return s}function oV(e,t){let n=[0];for(let r=0;r<t;++r)n.push(e[r][0]);return n}function iV(e,t,n){let r=e.slice(0,1);for(let s=0;s<n;++s)r.push(e[s+1]-t[s][0]-t[s][1]);return r}var gN=1.7580993408473768,bN=1.0507009873554805,uV=.3275911,cV=.254829592,lV=-.284496736,dV=1.421413741,pV=-1.453152027,hV=1.061405429;function fV(e,t){if(e.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);let n=new Float32Array(e.length*2);for(let r=0;r<n.length;r+=2)n[r]=e[r/2],n[r+1]=t[r/2];return n}function mV(e){let t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let r=0;r<e.length;r+=2)t[r/2]=e[r],n[r/2]=e[r+1];return{real:t,imag:n}}function gV(e){let t=Math.ceil(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let s=0;s<e.length;s+=4)n[Math.floor(s/4)]=e[s],r[Math.floor(s/4)]=e[s+1];return{real:n,imag:r}}function bV(e){let t=Math.floor(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let s=2;s<e.length;s+=4)n[Math.floor(s/4)]=e[s],r[Math.floor(s/4)]=e[s+1];return{real:n,imag:r}}function yV(e,t){let n=e[t*2],r=e[t*2+1];return{real:n,imag:r}}function vV(e,t,n,r){e[r*2]=t,e[r*2+1]=n}function xV(e,t){let n=new Float32Array(e/2),r=new Float32Array(e/2);for(let s=0;s<Math.ceil(e/2);s++){let a=(t?2:-2)*Math.PI*(s/e);n[s]=Math.cos(a),r[s]=Math.sin(a)}return{real:n,imag:r}}function wV(e,t,n){let r=(n?2:-2)*Math.PI*(e/t),s=Math.cos(r),a=Math.sin(r);return{real:s,imag:a}}var bv="->",IV=/->/g,kS=",",SS="...";function kV(e,t){e=e.replace(/\s/g,"");let n=(e.length-e.replace(IV,"").length)/bv.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error(`Equation must contain exactly one arrow ("${bv}").`);let[r,s]=e.split(bv);A(r.indexOf(SS)===-1,()=>`The ellipsis notation ("${SS}") is not supported yet.`);let a=r.split(kS),o=a.length;if(t!==o)throw new Error(`Expected ${o} input tensors, received ${t}`);if(o>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");let i=[];for(let d=0;d<s.length;++d){let h=s[d];if(!a.some(f=>f.indexOf(h)!==-1))throw new Error(`Output subscripts contain the label ${h} not present in the input subscripts.`);i.indexOf(h)===-1&&i.push(h)}for(let d=0;d<r.length;++d){let h=r[d];i.indexOf(h)===-1&&h!==kS&&i.push(h)}let u=new Array(a.length);for(let d=0;d<o;++d){if(new Set(a[d].split("")).size!==a[d].length)throw new Error(`Found duplicate axes in input component ${a[d]}. Support for duplicate axes in input is not implemented yet.`);u[d]=[];for(let h=0;h<a[d].length;++h)u[d].push(i.indexOf(a[d][h]))}let c=i.length,l=s.length,p=[];for(let d=l;d<c;++d)p.push(d);return{allDims:i,summedDims:p,idDims:u}}function SV(e,t){let n=new Array(e);n.fill(-1);for(let s=0;s<t.length;++s)n[t[s]]=s;let r=[];for(let s=0;s<e;++s)n[s]===-1&&r.push(s);return n=n.filter(s=>s!==-1),{permutationIndices:n,expandDims:r}}function CV(e,t,n){let r=new Array(e);for(let s=0;s<n.length;++s){let a=n[s].shape;for(let o=0;o<t[s].length;++o)r[t[s][o]]===void 0?r[t[s][o]]=a[o]:A(r[t[s][o]]===a[o],()=>`Expected dimension ${r[t[s][o]]} at axis ${o} of input shaped ${JSON.stringify(a)}, but got dimension ${a[o]}`)}}function TV(e,t){let n=e,r=[],s=0;e.length===0&&n.push(-1),s=e.length+1;for(let o=0;o<s;++o)r.push([]);let a=[];for(let o=0;o<n.length;++o){let i=n[o],u=_V(t,i);for(let c of u)a.indexOf(c)===-1&&(r[o].push(c),a.push(c))}return{path:n,steps:r}}function NV(e){return e.every((t,n)=>t===n)}function _V(e,t){let n=[];for(let r=0;r<e.length;++r)(e[r].length===0||e[r].indexOf(t)!==-1||t===-1)&&n.push(r);return n}function EV(e,t,n=0){let r=[];if(typeof t=="number")A(e.shape[n]%t===0,()=>"Number of splits must evenly divide the axis."),r=new Array(t).fill(e.shape[n]/t);else{let s=t.reduce((o,i)=>(i===-1&&(o+=1),o),0);A(s<=1,()=>"There should be only one negative value in split array.");let a=t.indexOf(-1);if(a!==-1){let o=t.reduce((i,u)=>u>0?i+u:i);t[a]=e.shape[n]-o}A(e.shape[n]===t.reduce((o,i)=>o+i),()=>"The sum of sizes must match the size of the axis dimension."),r=t}return r}function AV(e){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${e}`}function DV(e,t){return`indices(${e}, 0) is invalid: ${t} < 0`}function $V(e,t,n){return`indices(${e}, 0) is invalid: ${t} >= ${n}`}function FV(e,t){return`only one output dimension may be -1, not both ${e} and ${t}`}function RV(e,t){return`size ${e} must be non-negative, not ${t}`}function PV(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function OV(e,t){let n=gt(e),r=gt(t);return`Input to reshape is a SparseTensor with ${n}
  dense values, but the requested shape requires a multiple of ${r}. inputShape=${e} outputShape= ${t}`}function MV(e,t){let n=gt(e),r=gt(t);return`Input to reshape is a tensor with ${n} dense values, but the requested shape has ${r}. inputShape=${e} outputShape=${t}`}function LV(){return"segment ids must be >= 0"}function zV(){return"segment ids are not increasing"}function BV(e,t){return`Segment id ${e} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function WV(e,t,n){return`Bad: indices[${e}] == ${t} out of range [0, ${n})`}var yN={};Ee(yN,{collectGatherOpShapeInfo:()=>GV,computeOutShape:()=>UV,segOpComputeOptimalWindowSize:()=>VV});function VV(e,t){let n=!1,r;for(e<=tI?(r=e,n=!0):r=cf(e,Math.floor(Math.sqrt(e)));!n;)r>t||r===e?n=!0:r=cf(e,r+1);return r}function UV(e,t,n){let r=[],s=e.length;for(let a=0;a<s;a++)a!==t?r.push(e[a]):r.push(n);return r}function GV(e,t,n,r){let s=t.shape.length,a=e.shape.length;if(r!==0&&(r<-s||r>s))throw new Error(`Expect batchDims in the range of [-${s}, ${s}], but got ${r}`);if(r<0&&(r+=s),r>a)throw new Error(`batchDims (${r}) must be less than rank(x) (
    ${a}).`);if(n<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${n}).`);for(let p=0;p<r;++p)if(e.shape[p]!==t.shape[p])throw new Error(`x.shape[${p}]: ${e.shape[p]} should be equal to indices.shape[${p}]: ${t.shape[p]}.`);let o=e.shape[n],i=[],u=1,c=1,l=1;for(let p=0;p<r;++p)i.push(e.shape[p]),u*=e.shape[p];for(let p=r;p<n;p++)i.push(e.shape[p]),c*=e.shape[p];for(let p=r;p<s;p++)i.push(t.shape[p]);for(let p=n+1;p<a;p++)i.push(e.shape[p]),l*=e.shape[p];return{batchSize:u,sliceSize:l,outerSize:c,dimSize:o,outputShape:i}}function HV(e){try{return e.map(t=>pf(t))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function jV(e){return e.map(t=>up(t))}var bs={};Ee(bs,{nonMaxSuppressionV3Impl:()=>zT,nonMaxSuppressionV4Impl:()=>BT,nonMaxSuppressionV5Impl:()=>WT,whereImpl:()=>_T});lW();var vN={kernelName:cc,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>B(e,Xi(ae(n,"float32"),-1))}}},qV={kernelName:Eo,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let r=ct(ae(n,"float32")),s=fn(de(xe(1),r));return bt(fe(e,s))}}}},KV={kernelName:Ao,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let r=fn(de(ct(ae(n,"float32")),1));return fe(e,r)}}}},XV={kernelName:Sa,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,s=lt(n.shape,r.shape);return{a:()=>{let i=e,u=Ut(n.shape,s);return u.length>0&&(i=ge(i,u)),W(i,n.shape)},b:()=>{let i=e,u=Ut(r.shape,s);return u.length>0&&(i=ge(i,u)),W(i,r.shape)}}}},YV={kernelName:Do,saveAllInputs:!0,gradFunc:(e,t)=>{let n={};return t.forEach((r,s)=>{n[s]=()=>e.clone()}),n}},ZV={kernelName:pc,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>je(n)}}},JV={kernelName:hc,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>je(n)}}},QV={kernelName:$o,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>fe(e,fn(de(xe(1),ct(ae(n,"float32")))))}}},e4={kernelName:Fo,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let r=fn(X(xe(1),ct(ae(n,"float32"))));return fe(e,r)}}}},t4={kernelName:Oo,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,s=lt(n.shape,r.shape);return{a:()=>{let i=X(ct(n),ct(r)),u=B(e,fe(r,i)),c=Ut(n.shape,s);return c.length>0&&(u=ge(u,c)),W(u,n.shape)},b:()=>{let i=X(ct(n),ct(r)),u=bt(B(e,fe(n,i))),c=Ut(r.shape,s);return c.length>0&&(u=ge(u,c)),W(u,r.shape)}}}},n4={kernelName:Ro,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>fe(e,X(ct(ae(n,"float32")),1))}}},r4={kernelName:Po,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>fe(e,de(xe(1),ct(ae(n,"float32"))))}}};function s4(e,t,n,r,s,a){let o=_(e,"dy","avgPool3dGrad"),i=_(t,"input","avgPool3dGrad"),u=o,c=i,l=!1;i.rank===4&&(l=!0,u=W(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),c=W(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),A(u.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${u.rank}.`),A(c.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${c.rank}.`),An("avgPool3dGrad",s,a);let p={dy:u,input:c},d={filterSize:n,strides:r,pad:s,dimRoundingMode:a},h=M.runKernel(Bd,p,d);return l?W(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}var a4=z({avgPool3dGrad_:s4}),o4={kernelName:fc,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{filterSize:s,strides:a,pad:o,dimRoundingMode:i}=n;return{x:()=>a4(e,r,s,a,o,i)}}};function i4(e,t,n,r,s){let a=_(e,"dy","avgPoolGrad"),o=_(t,"input","avgPoolGrad");A(o.rank===a.rank,()=>`Rank of input (${o.rank}) does not match rank of dy (${a.rank})`);let i=o,u=a,c=!1;o.rank===3&&(c=!0,i=W(o,[1,o.shape[0],o.shape[1],o.shape[2]]),u=W(a,[1,a.shape[0],a.shape[1],a.shape[2]])),A(u.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${u.rank}.`),A(i.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${i.rank}.`);let l={dy:u,input:i},p={filterSize:n,strides:r,pad:s},d=M.runKernel(zd,l,p);return c?W(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var u4=z({avgPoolGrad_:i4}),c4={kernelName:Mo,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{filterSize:s,strides:a,pad:o}=n;return{x:()=>u4(e,r,s,a,o)}}},l4={kernelName:Lo,inputsToSave:["a","b"],gradFunc:(e,t,n)=>{let[r,s]=t,{transposeA:a,transposeB:o}=n;return!a&&!o?{a:()=>Fe(e,s,!1,!0),b:()=>Fe(r,e,!0,!1)}:!a&&o?{a:()=>Fe(e,s,!1,!1),b:()=>Fe(e,r,!0,!1)}:a&&!o?{a:()=>Fe(s,e,!1,!0),b:()=>Fe(r,e,!1,!1)}:{a:()=>Fe(s,e,!0,!0),b:()=>Fe(e,r,!0,!0)}}},d4={kernelName:mc,gradFunc:(e,t,n)=>{let{blockShape:r,crops:s}=n;return{x:()=>vp(e,r,s)}}},p4={kernelName:uC,gradFunc:(e,t,n)=>{let r=n,s=r.inputShape,a=r.shape,o=Array.from(a);for(let u=s.length-1;u>=0;u--)if(s[u]===a[u])o[u]=1;else if(s[u]!==1)throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${a}].`);let i=[];for(let u=0;u<o.length;u++)o[u]>1&&i.push(u);return{x:()=>ge(e,i,!0)}}},h4={kernelName:zo,gradFunc:e=>({x:()=>e.clone()})},f4={kernelName:Bo,gradFunc:e=>({x:()=>je(e)})},m4={kernelName:Ca,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{clipValueMin:s,clipValueMax:a}=n;return{x:()=>sn(Rr(Ms(r,s),Da(r,a)),e,je(e))}}},g4={kernelName:Vd,inputsToSave:["x"],gradFunc:vN.gradFunc},b4={kernelName:yc,saveAllInputs:!0,gradFunc:(e,t,n)=>{let r=t.map(u=>u.shape),{axis:s}=n,a=Pr(s,t[0].shape)[0],o=r.map(u=>u[a]);return zn(e,o,a).map(u=>()=>u)}},y4={kernelName:Wo,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let[r,s]=t,{dilations:a,strides:o,pad:i,dataFormat:u}=n;return A(ma(a),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`),{x:()=>sw(r.shape,e,s,o,i,u),filter:()=>Vw(r,e,s.shape,o,i,u)}}},v4={kernelName:Vo,inputsToSave:["dy","filter"],gradFunc:(e,t,n)=>{let[r,s]=t,{strides:a,pad:o,dataFormat:i,dimRoundingMode:u}=n;return{dy:()=>Pt(e,s,a,o,i,1,u),filter:()=>Vw(e,r,s.shape,a,o,i,u)}}};function x4(e,t,n,r,s){let a=e;e.rank===4&&(a=W(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]));let o=t;o.rank===4&&(o=W(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),A(a.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${a.shape}.`),A(o.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${o.shape}.`),A(n.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`),A(a.shape[4]===n[3],()=>`Error in conv3dDerFilter: depth of input ${a.shape[4]}) must match input depth in filter (${n[3]}.`),A(o.shape[4]===n[4],()=>`Error in conv3dDerFilter: depth of dy (${o.shape[4]}) must match output depth for filter (${n[4]}).`);let i={x:a,dy:o},u={strides:r,pad:s,filterShape:n};return M.runKernel(vc,i,u)}var w4=z({conv3DBackpropFilter_:x4}),I4={kernelName:Uo,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let{dilations:r,strides:s,pad:a}=n;A(ma(r),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`);let[o,i]=t;return{x:()=>VC(o.shape,e,i,s,a),filter:()=>w4(o,e,i.shape,s,a)}}},k4={kernelName:Go,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>B(bt(vm(ae(n,"float32"))),e)}}},S4={kernelName:Ho,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>B(xm(ae(n,"float32")),e)}}},C4={kernelName:jo,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{axis:s,exclusive:a,reverse:o}=n;return{x:()=>{let i=KC([s],r.rank),u=im(e,s,a,!o);return i!=null&&(u=Re(u,i)),u}}}},T4={kernelName:qo,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let{dilations:r,strides:s,pad:a,dimRoundingMode:o}=n,i=r??[1,1];A(ma(i),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${i}'`);let[u,c]=t;return A(u.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${u.rank}.`),A(c.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${c.rank}.`),A(u.shape[3]===c.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${u.shape[3]}) must match the inChannels dimension in filter ${c.shape[2]}.`),A(ms(s,i),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${s} and dilations '${i}'.`),An("depthwiseConv2d",a,o),{x:()=>OT(u.shape,e,c,s,a,i,o),filter:()=>PT(u,e,c.shape,s,a,i,o)}}},N4={kernelName:Ko,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let[r,s]=t,a={x:r,filter:s,dy:e},o={x:r,filter:s,dy:e};return{x:()=>M.runKernel(Uu,a,n),filter:()=>M.runKernel(Gu,o,n)}}},_4={kernelName:Yo,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t,r={dy:e,y:n};return{x:()=>M.runKernel(Sc,r)}}},E4={kernelName:Zo,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t,r=B(vn(bt(ct(n))),2/Math.sqrt(Math.PI));return{x:()=>B(e,r)}}},A4={kernelName:Jo,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>B(e,n)}}},D4={kernelName:Tc,inputsToSave:["input"],gradFunc:(e,t)=>{let[n]=t;return{input:()=>W(e,n.shape)}}},$4={kernelName:Qo,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>B(e,vn(n))}}},F4={kernelName:ei,gradFunc:e=>({x:()=>je(e)})},R4={kernelName:ti,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,s=lt(n.shape,r.shape);return{a:()=>{let i=fe(e,ae(r,"float32")),u=Ut(n.shape,s);return u.length>0?W(ge(i,u),n.shape):i},b:()=>{let i=B(e,ae(n,"float32")),u=Ut(r.shape,s);u.length>0&&(i=W(ge(i,u),r.shape));let c=ct(r);return bt(fe(i,ae(c,"float32")))}}}},P4={kernelName:ni,inputsToSave:["x","mean","variance","scale"],gradFunc:(e,t,n)=>{let{varianceEpsilon:r}=n,[s,a,o,i]=t,u=i??xe(1),c=Ut(a.shape,s.shape),l=[];if(a.rank===1){for(let x=0;x<s.shape.length-1;++x)l.push(s.shape[x]);l.push(1)}let p=de(s,a),d=B(e,u),h=bm(X(o,xe(r))),f=B(B(B(h,h),h),xe(-.5));return{x:()=>a.rank===1?W(B(B(e,Ln(W(h,[1,1,1,a.shape[0]]),l)),u),s.shape):W(B(B(e,h),u),s.shape),mean:()=>{let x=B(B(h,xe(-1)),d);return a.rank===1&&(x=ge(x,c)),W(x,a.shape)},variance:()=>{let x=B(B(f,p),d);return a.rank===1&&(x=ge(x,c)),W(x,a.shape)},scale:()=>{let x=B(p,h),k=B(e,x);return a.rank===1&&(k=ge(k,c)),W(k,a.shape)},offset:()=>{let x=e;return a.rank===1&&(x=ge(x,c)),W(x,a.shape)}}}},O4={kernelName:_c,inputsToSave:["x","indices"],gradFunc:(e,t,n)=>{let[r,s]=t,{axis:a}=n,o=Pr(a,r.shape)[0];return{x:()=>{let u=r.shape,c=s.size,l=u.slice(0,o),p=l.length,d=u.slice(a,u.length).slice(1),h=d.length,f=CS(0,p),g=CS(p+1,p+1+h),m=TS([l,[c],d]),b=W(e,m),v=W(s,[c]),y=TS([[p],f,g]),x=Re(b,y),k=Nm(x,v,r.shape[o]),S=hw(y);return k=Re(k,S),k},indices:()=>s}}};function CS(e,t){let n=[];for(let r=e;r<t;++r)n.push(r);return n}function TS(e){let t=[];for(let n=0;n<e.length;++n)for(let r=0;r<e[n].length;++r)t.push(e[n][r]);return t}var M4={kernelName:ri,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t;return{a:()=>je(n),b:()=>je(r)}}},L4={kernelName:si,gradFunc:e=>({x:()=>ae(e,"float32")})},z4={kernelName:ai,gradFunc:e=>({x:()=>je(e)})},B4={kernelName:oi,gradFunc:e=>({x:()=>je(e)})},W4={kernelName:ii,gradFunc:e=>({x:()=>je(e)})},V4={kernelName:ui,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{alpha:s}=n,a=Dn(r,0);return{x:()=>sn(a,e,B(e,s))}}},U4={kernelName:li,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>fe(e,X(n,1))}}},G4={kernelName:ci,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>fe(e,ae(n,"float32"))}}},H4={kernelName:lC,inputsToSave:[],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r]=t,{axis:s}=n;return{logits:()=>{let o=vn(r);return de(e,B(ge(e,s,!0),o))}}}};function j4(e,t,n,r=5,s=1,a=1,o=.5){let i={x:e,y:t,dy:n},u={depthRadius:r,bias:s,alpha:a,beta:o};return M.runKernel(Mc,i,u)}var q4=z({localResponseNormalizationBackprop_:j4}),K4={kernelName:di,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r,s]=t,{depthRadius:a,bias:o,alpha:i,beta:u}=n;return{x:()=>q4(r,s,e,a,o,i,u)}}};function xN(e,t,n,r){return t.rank<n.rank&&(t=W(t,yo(t.shape,r))),e.rank<n.rank&&(e=W(e,yo(e.shape,r))),{x:()=>B(e,ae(nr(n,t),e.dtype))}}var NS={kernelName:pi,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let r=n,{reductionIndices:s}=r,a=t[0],o=t[1],i=Pr(s,a.shape),u=xN(e,o,a,i);return{x:()=>u.x()}}},X4={kernelName:hi,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t;return{a:()=>B(e,ae(Ms(n,r),"float32")),b:()=>B(e,ae(qu(n,r),"float32"))}}};function Y4(e,t,n,r,s,a,o){let i=_(e,"dy","maxPool3dGrad"),u=_(t,"input","maxPool3dGrad"),c=_(n,"output","maxPool3dGrad"),l=i,p=u,d=c,h=!1;u.rank===4&&(h=!0,l=W(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),p=W(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]]),d=W(c,[1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]])),A(l.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),A(p.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${p.rank}.`),A(d.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${d.rank}.`),An("maxPool3dGrad",a,o);let f={dy:l,input:p,output:d},g={filterSize:r,strides:s,pad:a,dimRoundingMode:o},m=M.runKernel(qd,f,g);return h?W(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}var Z4=z({maxPool3dGrad_:Y4}),J4={kernelName:Lc,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r,s]=t,{filterSize:a,strides:o,pad:i,dimRoundingMode:u}=n;return{x:()=>Z4(e,r,s,a,o,i,u)}}};function Q4(e,t,n,r,s,a,o){let i=_(e,"dy","maxPoolGrad"),u=_(t,"input","maxPoolGrad"),c=_(n,"output","maxPoolGrad");A(u.rank===i.rank,()=>`Rank of input (${u.rank}) does not match rank of dy (${i.rank})`),A(i.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${i.rank}.`),A(u.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${u.rank}.`),An("maxPoolGrad",a,o);let l={dy:i,input:u,output:c},p={filterSize:r,strides:s,pad:a,dimRoundingMode:o};return M.runKernel(jd,l,p)}var eU=z({maxPoolGrad_:Q4}),tU={kernelName:fi,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r,s]=t,{filterSize:a,strides:o,pad:i}=n;return{x:()=>eU(e,r,s,a,o,i)}}},nU={kernelName:mi,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{axis:s}=n,a=Pr(s,r.shape),i=qC(r.shape,a)[1],u=gt(i);return{x:()=>{let l=r.shape.slice();a.forEach(h=>{l[h]=1});let p=W(e,l);return fe(B(p,er(r.shape,"float32")),u)}}}},rU={kernelName:gi,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let r=n,{axis:s}=r,[a,o]=t,i=Pr(s,a.shape),u=xN(e,o,a,i);return{x:()=>u.x()}}},sU={kernelName:bi,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t;return{a:()=>B(e,ae(Da(n,r),"float32")),b:()=>B(e,ae(Dn(n,r),"float32"))}}},aU={kernelName:yi,inputsToSave:["x"],gradFunc:(e,t,n)=>{let r=t[0],{paddings:s}=n,a=s.map(o=>o[0]);return{x:()=>Ue(e,a,r.shape)}}},oU={kernelName:vi,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,s=lt(n.shape,r.shape);return{a:()=>{let i=Ut(n.shape,s);return i.length>0?W(ge(e,i),n.shape):e},b:()=>{let i=B(e,bt(fl(fe(n,r)))),u=Ut(r.shape,s);return u.length>0?W(ge(i,u),r.shape):i}}}},iU={kernelName:xi,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,s=lt(n.shape,r.shape);return{a:()=>{let i=B(e,ae(r,"float32")),u=Ut(n.shape,s);return u.length>0?W(ge(i,u),n.shape):i},b:()=>{let i=B(e,ae(n,"float32")),u=Ut(r.shape,s);return u.length>0?W(ge(i,u),r.shape):i}}}},uU={kernelName:Bc,gradFunc:e=>({x:()=>bt(e)})},cU={kernelName:wi,inputsToSave:["indices"],gradFunc:(e,t)=>{let n=t[0];return{indices:()=>Ct(n.shape,"float32")}}},lU={kernelName:Hc,gradFunc:e=>({x:()=>je(e)})},dU={kernelName:jc,saveAllInputs:!0,gradFunc:(e,t,n)=>{let{axis:r}=n;return dt(e,r).map(a=>()=>a)}},_S={kernelName:Ii,inputsToSave:["x"],gradFunc:(e,t,n)=>{let r=t[0],{paddings:s}=n,a=s.map(o=>o[0]);return{x:()=>Ue(e,a,r.shape)}}},pU={kernelName:ki,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(e,t)=>{let[n,r,s]=t,a=n,o=r,i=lt(a.shape,o.shape);return{a:()=>{let l=ae(o,"float32"),p=B(e,B(l,Ps(a,de(l,xe(1))))),d=Ut(a.shape,i);return d.length>0&&(p=ge(p,d)),W(p,a.shape)},b:()=>{let l=Dn(a,0),p=sn(l,rr(a),je(a)),d=B(e,B(s,p)),h=Ut(o.shape,i);return h.length>0&&(d=ge(d,h)),W(d,o.shape)}}}},hU={kernelName:Si,inputsToSave:["x","alpha"],gradFunc:(e,t)=>{let[n,r]=t,s=Dn(n,0);return{x:()=>sn(s,e,B(e,r)),alpha:()=>{let a=sn(s,je(e),B(e,n)),o=Ut(r.shape,e.shape);return o.length>0&&(a=ge(a,o)),W(a,r.shape)}}}};function fU(e,t,n){let r=e.shape.slice();r[n]=1;let s=W(t,r),a=Nd(e,n,!0,!1),o=Nd(e,n,!0,!0),i=B(a,o);return B(s,i)}function mU(e,t,n){let r=e.shape.length,s=r-n.length,a=T.getAxesPermutation(n,r),o=e;a!=null&&(o=Re(e,a));let i=o.shape.slice(),c=i.splice(r-n.length,n.length).reduce((d,h)=>d*h,1);i.push(c);let l=o.reshape(i),p=fU(l,t,s);if(p=p.reshape(o.shape),a!=null){let d=T.getUndoAxesPermutation(a);p=Re(p,d)}return p}var gU={kernelName:Ci,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{axis:s}=n,a=[];return s==null?a=r.shape.map((o,i)=>i):typeof s=="number"?a=[s]:a=s,{x:()=>mU(r,e,a)}}},bU={kernelName:Xo,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,s=lt(n.shape,r.shape);return{a:()=>{let i=fe(e,ae(r,"float32")),u=Ut(n.shape,s);return u.length>0?W(ge(i,u),n.shape):i},b:()=>{let i=B(e,ae(n,"float32")),u=Ut(r.shape,s);u.length>0&&(i=W(ge(i,u),r.shape));let c=ct(r);return bt(fe(i,ae(c,"float32")))}}}},yU={kernelName:Ti,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>fe(e,bt(ct(n)))}}},vU={kernelName:Ai,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t,r=B(Da(n,6),Xi(n));return{x:()=>B(e,ae(r,"float32"))}}},xU={kernelName:Ni,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>B(e,ae(Xi(n),"float32"))}}},wU={kernelName:qc,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>W(e,n.shape)}}},IU={kernelName:Ei,inputsToSave:["images"],gradFunc:(e,t,n)=>{let[r]=t,s={dy:e,images:r};return{images:()=>M.runKernel(Xc,s,n)}}},kU={kernelName:_i,inputsToSave:["images"],gradFunc:(e,t,n)=>{let[r]=t,s={dy:e,images:r};return{images:()=>M.runKernel(Kc,s,n)}}},SU={kernelName:Di,gradFunc:(e,t,n)=>{let{dims:r}=n,s=Pr(r,e.shape);return{x:()=>gr(e,s)}}},CU={kernelName:$i,gradFunc:e=>({x:()=>je(e)})},TU={kernelName:Fi,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>bt(fe(e,B(Ps(n,1.5),2)))}}},NU={kernelName:Qc,inputsToSave:["condition"],gradFunc:(e,t)=>{let[n]=t;return{condition:()=>ae(je(n),"float32"),t:()=>B(e,ae(n,e.dtype)),e:()=>B(e,ae(bp(n),e.dtype))}}},_U={kernelName:Ri,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let r=Dn(n,xe(0)),s=xe(gN),a=xe(bN),o=B(e,a),i=B(B(e,s),vn(ae(n,"float32")));return sn(r,o,i)}}}},EU={kernelName:Li,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>B(e,B(n,de(xe(1),n)))}}},AU={kernelName:Mi,gradFunc:e=>({x:()=>je(e)})},DU={kernelName:Pi,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>B(hp(ae(n,"float32")),e)}}},$U={kernelName:Oi,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>B(om(ae(n,"float32")),e)}}},FU={kernelName:el,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{begin:s,size:a}=n,o=r.shape,[i,u]=fN(r,s,a),c=[];for(let l=0;l<e.rank;l++)c.push([i[l],o[l]-i[l]-u[l]]);return{x:()=>yr(e,c)}}},RU={kernelName:Vi,outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r]=t,{dim:s}=n,a=!0,o=B(e,r);return{logits:()=>de(o,B(ge(o,[s],a),r))}}},PU={kernelName:zi,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>B(e,hr(n))}}},ES={kernelName:tl,gradFunc:(e,t,n)=>{let{blockShape:r,paddings:s}=n;return{x:()=>pp(e,r,s)}}},AS={kernelName:nl,gradFunc:(e,t,n)=>{let{axis:r}=n;return{x:()=>tt(e,r)}}},OU={kernelName:Bi,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>fe(e,B(fn(ae(n,"float32")),2))}}},MU={kernelName:Qd,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>B(e,B(ae(n,"float32"),2))}}},LU={kernelName:Ui,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,s=xe(2);return{a:()=>B(e,B(s,de(n,r))),b:()=>B(e,B(s,de(r,n)))}}},zU={kernelName:Na,gradFunc:e=>({x:()=>je(e)})},BU={kernelName:Gi,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,s=lt(n.shape,r.shape);return{a:()=>{let i=e,u=Ut(n.shape,s);return u.length>0&&(i=ge(i,u)),W(i,n.shape)},b:()=>{let i=e,u=Ut(r.shape,s);return u.length>0&&(i=ge(i,u)),W(bt(i),r.shape)}}}},WU={kernelName:Wi,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,s=r.shape.slice(),{axis:a}=n;Pr(a,r.shape).forEach(c=>{s[c]=1});let i=W(e,s),u=B(i,er(r.shape,"float32"));return{x:()=>u}}},VU={kernelName:Hi,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>fe(e,ct(hp(n)))}}},UU={kernelName:ji,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>B(de(xe(1),ct(n)),e)}}},GU={kernelName:Ta,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{reps:s}=n;return{x:()=>{let o=je(r);if(r.rank===1)for(let i=0;i<s[0];++i)o=X(o,Ue(e,[i*r.shape[0]],[r.shape[0]]));else if(r.rank===2)for(let i=0;i<s[0];++i)for(let u=0;u<s[1];++u)o=X(o,Ue(e,[i*r.shape[0],u*r.shape[1]],[r.shape[0],r.shape[1]]));else if(r.rank===3)for(let i=0;i<s[0];++i)for(let u=0;u<s[1];++u)for(let c=0;c<s[2];++c)o=X(o,Ue(e,[i*r.shape[0],u*r.shape[1],c*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else if(r.rank===4)for(let i=0;i<s[0];++i)for(let u=0;u<s[1];++u)for(let c=0;c<s[2];++c)for(let l=0;l<s[3];++l)o=X(o,Ue(e,[i*r.shape[0],u*r.shape[1],c*r.shape[2],l*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);return o}}}},HU={kernelName:$s,gradFunc:(e,t,n)=>{let r=n,{perm:s}=r,a=hw(s);return{x:()=>Re(e,a)}}},jU={kernelName:ul,gradFunc:(e,t,n)=>{let r=n,{axis:s}=r;return{value:()=>Rt(e,s)}}},qU={kernelName:ap,inputsToSave:["segmentIds"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>KU(e,n)}}};function KU(e,t){let n=gs(t,je(t)),r=ml(e,n),s=Ms(t,xe(0,"int32")),a=r.rank-s.rank;for(let i=0;i<a;++i)s=jt(s,i+1);s=Rr(s,er(r.shape,"bool"));let o=je(r);return sn(s,r,o)}var XU={kernelName:cl,gradFunc:e=>({x:()=>je(e)})},YU=[vN,qV,KV,XV,YV,ZV,JV,QV,e4,t4,n4,r4,o4,c4,l4,d4,p4,h4,f4,m4,g4,b4,v4,y4,I4,k4,S4,C4,T4,N4,bU,_4,E4,A4,D4,$4,R4,F4,P4,O4,M4,L4,z4,B4,W4,V4,U4,G4,H4,K4,NS,NS,X4,J4,tU,nU,rU,sU,aU,oU,iU,uU,cU,lU,dU,_S,_S,pU,hU,gU,yU,vU,xU,wU,IU,kU,SU,CU,TU,NU,_U,EU,AU,DU,$U,FU,RU,PU,ES,ES,AS,AS,OU,LU,MU,zU,BU,WU,VU,UU,GU,HU,jU,qU,XU];for(let e of YU)dC(e);Q().prototype.abs=function(){return this.throwIfDisposed(),Bt(this)};Q().prototype.acos=function(){return this.throwIfDisposed(),zx(this)};Q().prototype.acosh=function(){return this.throwIfDisposed(),Bx(this)};Q().prototype.add=function(e){return this.throwIfDisposed(),X(this,e)};Q().prototype.all=function(e,t){return this.throwIfDisposed(),rm(this,e,t)};Q().prototype.any=function(e,t){return this.throwIfDisposed(),Sd(this,e,t)};Q().prototype.argMax=function(e){return this.throwIfDisposed(),mo(this,e)};Q().prototype.argMin=function(e){return this.throwIfDisposed(),Wx(this,e)};Q().prototype.asScalar=function(){return this.throwIfDisposed(),A(this.size===1,()=>"The array must have only 1 element."),W(this,[])};Q().prototype.asType=function(e){return this.throwIfDisposed(),ae(this,e)};Q().prototype.as1D=function(){return this.throwIfDisposed(),W(this,[this.size])};Q().prototype.as2D=function(e,t){return this.throwIfDisposed(),W(this,[e,t])};Q().prototype.as3D=function(e,t,n){return this.throwIfDisposed(),W(this,[e,t,n])};Q().prototype.as4D=function(e,t,n,r){return this.throwIfDisposed(),W(this,[e,t,n,r])};Q().prototype.as5D=function(e,t,n,r,s){return this.throwIfDisposed(),W(this,[e,t,n,r,s])};Q().prototype.asin=function(){return this.throwIfDisposed(),Vx(this)};Q().prototype.asinh=function(){return this.throwIfDisposed(),Ux(this)};Q().prototype.atan=function(){return this.throwIfDisposed(),Gx(this)};Q().prototype.atan2=function(e){return this.throwIfDisposed(),Hx(this,e)};Q().prototype.atanh=function(){return this.throwIfDisposed(),jx(this)};Q().prototype.avgPool=function(e,t,n,r){return this.throwIfDisposed(),br(this,e,t,n,r)};Q().prototype.batchToSpaceND=function(e,t){return this.throwIfDisposed(),pp(this,e,t)};Q().prototype.batchNorm=function(e,t,n,r,s){return this.throwIfDisposed(),Ea(this,e,t,n,r,s)};Q().prototype.broadcastTo=function(e){return this.throwIfDisposed(),oo(this,e)};Q().prototype.cast=function(e){return this.throwIfDisposed(),ae(this,e)};Q().prototype.ceil=function(){return this.throwIfDisposed(),Qx(this)};Q().prototype.clipByValue=function(e,t){return this.throwIfDisposed(),an(this,e,t)};Q().prototype.concat=function(e,t){return this.throwIfDisposed(),e instanceof Te&&(e=[e]),tt([this,...e],t)};Q().prototype.conv1d=function(e,t,n,r,s,a){return this.throwIfDisposed(),sm(this,e,t,n,r,s,a)};Q().prototype.conv2dTranspose=function(e,t,n,r,s){return this.throwIfDisposed(),am(this,e,t,n,r,s)};Q().prototype.conv2d=function(e,t,n,r,s,a){return this.throwIfDisposed(),Pt(this,e,t,n,r,s,a)};Q().prototype.cos=function(){return this.throwIfDisposed(),hp(this)};Q().prototype.cosh=function(){return this.throwIfDisposed(),om(this)};Q().prototype.cumprod=function(e,t,n){return this.throwIfDisposed(),Nd(this,e,t,n)};Q().prototype.cumsum=function(e,t,n){return this.throwIfDisposed(),im(this,e,t,n)};Q().prototype.depthToSpace=function(e,t){return this.throwIfDisposed(),iw(this,e,t)};Q().prototype.depthwiseConv2d=function(e,t,n,r,s,a){return this.throwIfDisposed(),Aa(this,e,t,n,r,s,a)};Q().prototype.dilation2d=function(e,t,n,r,s){return this.throwIfDisposed(),uw(this,e,t,n,r,s)};Q().prototype.divNoNan=function(e){return this.throwIfDisposed(),cw(this,e)};Q().prototype.div=function(e){return this.throwIfDisposed(),fe(this,e)};Q().prototype.dot=function(e){return this.throwIfDisposed(),lw(this,e)};Q().prototype.elu=function(){return this.throwIfDisposed(),pl(this)};Q().prototype.equal=function(e){return this.throwIfDisposed(),nr(this,e)};Q().prototype.erf=function(){return this.throwIfDisposed(),dw(this)};Q().prototype.euclideanNorm=function(e,t){return this.throwIfDisposed(),fw(this,e,t)};Q().prototype.exp=function(){return this.throwIfDisposed(),vn(this)};Q().prototype.expandDims=function(e){return this.throwIfDisposed(),jt(this,e)};Q().prototype.expm1=function(){return this.throwIfDisposed(),mw(this)};Q().prototype.fft=function(){return this.throwIfDisposed(),Ip(this)};Q().prototype.flatten=function(){return this.throwIfDisposed(),W(this,[this.size])};Q().prototype.floor=function(){return this.throwIfDisposed(),fl(this)};Q().prototype.floorDiv=function(e){return this.throwIfDisposed(),nm(this,e)};Q().prototype.gather=function(e,t,n){return this.throwIfDisposed(),ml(this,e,t,n)};Q().prototype.greaterEqual=function(e){return this.throwIfDisposed(),Ms(this,e)};Q().prototype.greater=function(e){return this.throwIfDisposed(),Dn(this,e)};Q().prototype.ifft=function(){return this.throwIfDisposed(),Zu(this)};Q().prototype.irfft=function(){return this.throwIfDisposed(),Im(this)};Q().prototype.isFinite=function(){return this.throwIfDisposed(),gw(this)};Q().prototype.isInf=function(){return this.throwIfDisposed(),bw(this)};Q().prototype.isNaN=function(){return this.throwIfDisposed(),yw(this)};Q().prototype.leakyRelu=function(e){return this.throwIfDisposed(),mp(this,e)};Q().prototype.lessEqual=function(e){return this.throwIfDisposed(),Da(this,e)};Q().prototype.less=function(e){return this.throwIfDisposed(),qu(this,e)};Q().prototype.localResponseNormalization=function(e,t,n,r){return this.throwIfDisposed(),vw(this,e,t,n,r)};Q().prototype.logSigmoid=function(){return this.throwIfDisposed(),xw(this)};Q().prototype.logSoftmax=function(e){return this.throwIfDisposed(),lm(this,e)};Q().prototype.logSumExp=function(e,t){return this.throwIfDisposed(),dm(this,e,t)};Q().prototype.log=function(){return this.throwIfDisposed(),rr(this)};Q().prototype.log1p=function(){return this.throwIfDisposed(),gp(this)};Q().prototype.logicalAnd=function(e){return this.throwIfDisposed(),Rr(this,e)};Q().prototype.logicalNot=function(){return this.throwIfDisposed(),bp(this)};Q().prototype.logicalOr=function(e){return this.throwIfDisposed(),pm(this,e)};Q().prototype.logicalXor=function(e){return this.throwIfDisposed(),ww(this,e)};Q().prototype.matMul=function(e,t,n){return this.throwIfDisposed(),Fe(this,e,t,n)};Q().prototype.maxPool=function(e,t,n,r){return this.throwIfDisposed(),Ot(this,e,t,n,r)};Q().prototype.max=function(e,t){return this.throwIfDisposed(),fr(this,e,t)};Q().prototype.maximum=function(e){return this.throwIfDisposed(),gs(this,e)};Q().prototype.mean=function(e,t){return this.throwIfDisposed(),Et(this,e,t)};Q().prototype.min=function(e,t){return this.throwIfDisposed(),ju(this,e,t)};Q().prototype.minimum=function(e){return this.throwIfDisposed(),ga(this,e)};Q().prototype.mirrorPad=function(e,t){return this.throwIfDisposed(),kw(this,e,t)};Q().prototype.mod=function(e){return this.throwIfDisposed(),Sw(this,e)};Q().prototype.mul=function(e){return this.throwIfDisposed(),B(this,e)};Q().prototype.neg=function(){return this.throwIfDisposed(),bt(this)};Q().prototype.norm=function(e,t,n){return this.throwIfDisposed(),hl(this,e,t,n)};Q().prototype.notEqual=function(e){return this.throwIfDisposed(),vo(this,e)};Q().prototype.oneHot=function(e,t=1,n=0){return this.throwIfDisposed(),Ku(this,e,t,n)};Q().prototype.onesLike=function(){return this.throwIfDisposed(),sr(this)};Q().prototype.pad=function(e,t){return this.throwIfDisposed(),yr(this,e,t)};Q().prototype.pool=function(e,t,n,r,s,a){return this.throwIfDisposed(),Cw(this,e,t,n,r,s,a)};Q().prototype.pow=function(e){return this.throwIfDisposed(),Ps(this,e)};Q().prototype.prelu=function(e){return this.throwIfDisposed(),xp(this,e)};Q().prototype.prod=function(e,t){return this.throwIfDisposed(),Tw(this,e,t)};Q().prototype.reciprocal=function(){return this.throwIfDisposed(),Dw(this)};Q().prototype.relu=function(){return this.throwIfDisposed(),Ke(this)};Q().prototype.relu6=function(){return this.throwIfDisposed(),mm(this)};Q().prototype.reshapeAs=function(e){return this.throwIfDisposed(),W(this,e.shape)};Q().prototype.reshape=function(e){return this.throwIfDisposed(),W(this,e)};Q().prototype.resizeBilinear=function(e,t,n){return this.throwIfDisposed(),VT(this,e,t,n)};Q().prototype.resizeNearestNeighbor=function(e,t,n){return this.throwIfDisposed(),UT(this,e,t,n)};Q().prototype.reverse=function(e){return this.throwIfDisposed(),gr(this,e)};Q().prototype.rfft=function(){return this.throwIfDisposed(),kp(this)};Q().prototype.round=function(){return this.throwIfDisposed(),gm(this)};Q().prototype.rsqrt=function(){return this.throwIfDisposed(),bm(this)};Q().prototype.selu=function(){return this.throwIfDisposed(),ym(this)};Q().prototype.separableConv2d=function(e,t,n,r,s,a){return this.throwIfDisposed(),Fa(this,e,t,n,r,s,a)};Q().prototype.sigmoid=function(){return this.throwIfDisposed(),hr(this)};Q().prototype.sign=function(){return this.throwIfDisposed(),$w(this)};Q().prototype.sin=function(){return this.throwIfDisposed(),vm(this)};Q().prototype.sinh=function(){return this.throwIfDisposed(),xm(this)};Q().prototype.slice=function(e,t){return this.throwIfDisposed(),Ue(this,e,t)};Q().prototype.softmax=function(e){return this.throwIfDisposed(),Yr(this,e)};Q().prototype.softplus=function(){return this.throwIfDisposed(),qi(this)};Q().prototype.spaceToBatchND=function(e,t){return this.throwIfDisposed(),vp(this,e,t)};Q().prototype.split=function(e,t){return this.throwIfDisposed(),zn(this,e,t)};Q().prototype.sqrt=function(){return this.throwIfDisposed(),fn(this)};Q().prototype.square=function(){return this.throwIfDisposed(),ct(this)};Q().prototype.squaredDifference=function(e){return this.throwIfDisposed(),km(this,e)};Q().prototype.squeeze=function(e){return this.throwIfDisposed(),Ra(this,e)};Q().prototype.stack=function(e,t){this.throwIfDisposed();let n=e instanceof Te?[this,e]:[this,...e];return Rt(n,t)};Q().prototype.step=function(e){return this.throwIfDisposed(),Xi(this,e)};Q().prototype.stridedSlice=function(e,t,n,r,s,a,o,i){return this.throwIfDisposed(),Fw(this,e,t,n,r,s,a,o,i)};Q().prototype.sub=function(e){return this.throwIfDisposed(),de(this,e)};Q().prototype.sum=function(e,t){return this.throwIfDisposed(),ge(this,e,t)};Q().prototype.tan=function(){return this.throwIfDisposed(),Rw(this)};Q().prototype.tanh=function(){return this.throwIfDisposed(),bo(this)};Q().prototype.tile=function(e){return this.throwIfDisposed(),Ln(this,e)};Q().prototype.toBool=function(){return this.throwIfDisposed(),ae(this,"bool")};Q().prototype.toFloat=function(){return this.throwIfDisposed(),ae(this,"float32")};Q().prototype.toInt=function(){return this.throwIfDisposed(),ae(this,"int32")};Q().prototype.topk=function(e,t){return this.throwIfDisposed(),Ow(this,e,t)};Q().prototype.transpose=function(e){return this.throwIfDisposed(),Re(this,e)};Q().prototype.unique=function(e){return this.throwIfDisposed(),Mw(this,e)};Q().prototype.unsortedSegmentSum=function(e,t){return this.throwIfDisposed(),Nm(this,e,t)};Q().prototype.unstack=function(e){return this.throwIfDisposed(),dt(this,e)};Q().prototype.where=function(e,t){return this.throwIfDisposed(),sn(e,this,t)};Q().prototype.zerosLike=function(){return this.throwIfDisposed(),je(this)};var Ns=class extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Ns.prototype)}},Vr=class extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Vr.prototype)}},V=class extends Error{constructor(e){super(e),Object.setPrototypeOf(this,V.prototype)}},Le=class extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Le.prototype)}},wN=class extends Error{constructor(e){super(e),Object.setPrototypeOf(this,wN.prototype)}},IN=class{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){let n=this.cache.keys().next().value;this.cache.delete(n)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){let n=this.cache.keys().next().value;this.cache.delete(n)}this.maxEntries=e}};function wo(e,t){if(Array.isArray(e)){let n=[];for(let r=0;r<t;r++)n=n.concat(e);return n}else{let n=new Array(t);return n.fill(e),n}}function as(e,t){if(!e)throw new wN(t)}function DS(e,t){let n=0;for(let r of e)r===t&&n++;return n}function Mn(e){return e.length===1?e[0]:e}function It(e){return Array.isArray(e)?e:[e]}function _s(e){let n=e.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return n[0]!=="_"?n:"private"+n}function eo(e){return e.length<=1||e.indexOf("_")===-1?e:e.replace(/[_]+(\w|$)/g,(t,n)=>n.toUpperCase())}var Nr={};function nI(e){if(e==null)return null;let t={};return t.className=e.getClassName(),t.config=e.getConfig(),t}function Gv(e){if(!(e==null||typeof e!="object"))if(Array.isArray(e))e.forEach(t=>Gv(t));else{let t=Object.keys(e);for(let n of t){let r=e[n];r!=null&&typeof r=="object"&&(!Array.isArray(r)&&r.type==="ndarray"&&typeof r.value=="number"?e[n]=r.value:Gv(r))}}}function Cp(e,t={},n={},r="object",s=!1){if(typeof e=="string"){let a=e,o;if(a in n)o=n[a];else if(a in Nr)o=Nr[a];else if(o=t[a],o==null)throw new V(`Unknown ${r}: ${e}. This may be due to one of the following reasons:
1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return o}else{let a=e;if(a.className==null||a.config==null)throw new V(`${r}: Improper config format: ${JSON.stringify(a)}.
'className' and 'config' must set.`);let o=a.className,i,u;if(o in n?[i,u]=n[o]:o in Nr?[i,u]=Nr.className:o in t&&([i,u]=t[o]),i==null)throw new V(`Unknown ${r}: ${o}. This may be due to one of the following reasons:
1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(u!=null){let c={};for(let h of Object.keys(Nr))c[h]=Nr[h];for(let h of Object.keys(n))c[h]=n[h];let l=a.config;l.customObjects=c;let p=Object.assign({},Nr);for(let h of Object.keys(n))Nr[h]=n[h];Gv(a.config);let d=u(i,a.config,n,s);return Nr=Object.assign({},p),d}else{let c=Object.assign({},Nr);for(let p of Object.keys(n))Nr[p]=n[p];let l=new i(a.config);return Nr=Object.assign({},c),l}}}function ZU(e,t){return e<t?-1:e>t?1:0}function Lh(e,t){return-1*ZU(e,t)}function la(e){if(e==null)return e;let t=[];for(let n of e)t.indexOf(n)===-1&&t.push(n);return t}function JU(e){if(e==null)throw new V(`Invalid value in obj: ${JSON.stringify(e)}`);for(let t in e)if(e.hasOwnProperty(t))return!1;return!0}function Zi(e,t,n){if(n!=null&&e.indexOf(n)<0)throw new V(`${n} is not a valid ${t}.  Valid values are ${e} or null/undefined.`)}function rI(e,t,n=0,r=1/0){return as(n>=0),as(r>=n),Array.isArray(e)&&e.length>=n&&e.length<=r&&e.every(s=>typeof s===t)}function rn(e,t){Array.isArray(e)?(w.assert(e.length>0,()=>`${t} is unexpectedly an empty array.`),e.forEach((n,r)=>rn(n,`element ${r+1} of ${t}`))):w.assert(Number.isInteger(e)&&e>0,()=>`Expected ${t} to be a positive integer, but got ${kN(e)}.`)}function kN(e){return e===null?"null":Array.isArray(e)?"["+e.map(t=>kN(t)).join(",")+"]":typeof e=="string"?`"${e}"`:`${e}`}function QU(e,t,n){let r=n!=null?n():w.now(),s;return(...o)=>{let i=n!=null?n():w.now();return i-r<t||(r=i,s=e(...o)),s}}function SN(e){return e==="relu"?"relu":e==="linear"?"linear":e==="elu"?"elu":null}var eG=0;function CN(){return eG++}var zh={};function Rm(e=""){return e in zh||(zh[e]=0),zh[e]+=1,e+zh[e].toString()}var tG=["channelsFirst","channelsLast"],nG=["nearest","bilinear"],rG=["valid","same","causal"],sG=["max","avg"],aG=["sum","mul","concat","ave"],Ru=new Map;function Mt(e){Zi(tG,"DataFormat",e)}function oG(e){Zi(nG,"InterpolationFormat",e)}function vr(e){Zi(rG,"PaddingMode",e)}function TN(e){Zi(sG,"PoolMode",e)}var md=[],$S="/";function io(e,t){md.push(e);try{let n=t();return md.pop(),n}catch(n){throw md.pop(),n}}function iG(){return md.length===0?"":md.join($S)+$S}function NN(e){if(!EN(e))throw new Error("Not a valid tensor name: '"+e+"'");return iG()+e}function _N(e){if(!EN(e))throw new Error("Not a valid tensor name: '"+e+"'");Ru.has(e)||Ru.set(e,0);let t=Ru.get(e);if(Ru.set(e,Ru.get(e)+1),t>0){let n=`${e}_${t}`;return Ru.set(n,1),n}else return e}var uG=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function EN(e){return!!e.match(uG)}function cG(e){return e===parseInt(e.toString(),10)}function da(e,t,n){t==null&&(t=0),n==null&&(n=e.length);let r=1;for(let s=t;s<n;++s)r*=e[s];return r}function ec(e){if(e.length===0)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let n=0;n<e.length;n++){let r=e[n];r<t&&(t=r)}return t}function ba(e){if(e.length===0)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let n=0;n<e.length;n++){let r=e[n];r>t&&(t=r)}return t}function qr(e,t){if(t<e)throw new V(`end (${t}) < begin (${e}) is forbidden.`);let n=[];for(let r=e;r<t;++r)n.push(r);return n}var yv;function Xt(){return yv==null&&(yv=RC().epsilon()),yv}function Kr(){return"channelsLast"}function cs(e,t){return ae(e,t)}function Tp(e,t=-1){let n=e.shape.slice();return t<0&&(t=n.length+t+1),n.splice(t,0,1),W(e,n)}function lG(e,t){return O(()=>{if(e.shape.length!==2)throw new V(`repeat() expects a rank-2 tensor, but received a rank-${e.shape.length} tensor.`);let n=Tp(e,1);return Hv(n,[1,t,1])})}function dG(e){let t=[da(e.shape)];return W(e,t)}function pG(e){if(e.rank<=1)throw new V(`batchFlatten requires a minimum rank of 2. Got rank: ${e.rank}.`);let t=[e.shape[0],da(e.shape,1)];return W(e,t)}function uo(e,t,n){return O(()=>{switch(e.rank){case 1:return wp(e,t,n);case 2:return wm(e,[t,0],[n,e.shape[1]]);case 3:return Ki(e,[t,0,0],[n,e.shape[1],e.shape[2]]);case 4:return Yu(e,[t,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3]]);case 5:return Ue(e,[t,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4]]);case 6:return Ue(e,[t,0,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4],e.shape[5]]);default:throw new V(`sliceAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}})}function vv(e,t,n){return O(()=>{switch(e.rank){case 1:return wp(e,t,n);case 2:return wm(e,[0,t],[e.shape[0],n]);case 3:return Ki(e,[0,0,t],[e.shape[0],e.shape[1],n]);case 4:return Yu(e,[0,0,0,t],[e.shape[0],e.shape[1],e.shape[2],n]);default:throw new V(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}})}function Bh(e,t,n,r){return O(()=>{switch(e.rank){case 1:return wp(e,t,n);case 2:switch(r){case 1:return uo(e,t,n);case 2:return vv(e,t,n);default:throw new V(`The axis is not within the rank of the tensor ${r}`)}case 3:switch(r){case 1:return uo(e,t,n);case 2:return Ki(e,[0,t,0],[e.shape[0],n,e.shape[2]]);case 3:return vv(e,t,n);default:throw new V(`The axis is not within the rank of the tensor ${r}`)}case 4:switch(r){case 1:return uo(e,t,n);case 2:return Yu(e,[0,t,0,0],[e.shape[0],n,e.shape[2],e.shape[3]]);case 3:return Yu(e,[0,0,t,0],[e.shape[0],e.shape[1],n,e.shape[3]]);case 4:return vv(e,t,n);default:throw new V(`The axis is not within the rank of the tensor ${r}`)}default:throw new V(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}})}function sI(e,t=-1){let n;return t<0&&(n=e[0].rank,n!==0?t=n:t=0),t===e[0].rank&&(t=-1),tt(e,t)}function FS(e,t){switch(e.rank){case 1:return ew([e,t]);case 2:return tw([e,t],0);case 3:return nw([e,t],0);case 4:return rw([e,t],0);default:throw new V(`concatAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}function Hv(e,t){if(Array.isArray(t)||(t=[t]),e.rank!==t.length)throw new V(`The length of input n (${t.length}) does not match the number of dimensions in input x (${e.rank})`);return Ln(e,t)}function Pm(e,t=0,n=1,r,s){return fm(e,t,n,r,s)}function ls(e,t,n,r){if(e.rank<2||t.rank<2)throw new Le(`dot requires both inputs to be rank >= 2 but got x shape = ${e.shape} and y shape = ${t.shape}`);if(t.rank>=3){let s=e.shape.slice(-1)[0],a=t.shape.slice(-2)[0];if(s!==a)throw new Le(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${e.shape} and  y shape = ${t.shape}`)}if(e.rank===2&&t.rank===2)return Ju.matMul({a:e,b:t,transposeA:!1,transposeB:!1,bias:r?jv(e.rank,r,Kr()):null,activation:n});{let s=e.shape.slice(),a=s.pop();e=W(e,[-1,a]);let o=t.shape.slice(),i=o.pop(),u=o.pop(),c=[...o,i],l=Array.from({length:t.rank},(f,g)=>g===0?t.rank-2:g<=t.rank-2?g-1:g);t=W(Re(t,l),[u,-1]);let p=[...s,...c],d=!1,h=!1;return W(Ju.matMul({a:e,b:t,transposeA:d,transposeB:h,bias:r?jv(e.rank,r,Kr()):null,activation:n}),p)}}function AN(e,t,n){return O(()=>(Array.isArray(t)?t=He(t,"int32"):t=ae(t,"int32"),ml(e,t,n)))}function Np(e){return B(e,e)}function jv(e,t,n){let r=t.shape;if(t.rank!==1&&t.rank!==e)throw new V(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${e}`);if(e===5){if(n==="channelsFirst")return r.length===1?W(t,[1,r[0],1,1,1]):W(t,[1,r[3],r[0],r[1],r[2]]);if(n==="channelsLast")return r.length===1?W(t,[1,1,1,1,r[0]]):W(t,[1].concat(r))}else if(e===4){if(n==="channelsFirst")return r.length===1?W(t,[1,r[0],1,1]):W(t,[1,r[2],r[0],r[1]]);if(n==="channelsLast")return r.length===1?W(t,[1,1,1,r[0]]):W(t,[1].concat(r))}else if(e===3){if(n==="channelsFirst")return r.length===1?W(t,[1,r[0],1]):W(t,[1,r[1],r[0]]);if(n==="channelsLast")return r.length===1?W(t,[1,1,r[0]]):W(t,[1].concat(r))}else if(e<3)return t;throw new V(`Unsupported input rank by biasAdd: ${t.rank}`)}function Zr(e,t,n){return O(()=>(n==null&&(n=Kr()),Mt(n),X(e,jv(e.rank,t,n))))}function hG(e,t=1){if(t!==1)throw new Le(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return pl(e)}function fG(e){return O(()=>fe(e,X(Bt(e),1)))}function DN(e,t,n,r){return O(()=>Bw(e,t,n,r))}function mG(e){return O(()=>{let t=X(.5,B(.2,e));return an(t,0,1)})}function _p(e,t,n=!1){return n?e():t()}var gG=["fanIn","fanOut","fanAvg"],bG=["normal","uniform","truncatedNormal"];function yG(e){Zi(gG,"FanMode",e)}function vG(e){Zi(bG,"Distribution",e)}var Mr=class extends re.Serializable{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}},aI=class extends Mr{apply(e,t){return Ct(e,t)}};aI.className="Zeros";re.registerClass(aI);var Om=class extends Mr{apply(e,t){return er(e,t)}};Om.className="Ones";re.registerClass(Om);var oI=class extends Mr{constructor(e){if(super(),typeof e!="object")throw new V(`Expected argument of type ConstantConfig but got ${e}`);if(e.value===void 0)throw new V(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return O(()=>B(xe(this.value),er(e,t)))}getConfig(){return{value:this.value}}};oI.className="Constant";re.registerClass(oI);var iI=class extends Mr{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return $a(e,this.minval,this.maxval,t,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}};iI.className="RandomUniform";re.registerClass(iI);var uI=class extends Mr{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Le(`randomNormal does not support dType ${t}.`);return Pm(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};uI.className="RandomNormal";re.registerClass(uI);var cI=class extends Mr{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Le(`truncatedNormal does not support dType ${t}.`);return Tm(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};cI.className="TruncatedNormal";re.registerClass(cI);var lI=class extends Mr{constructor(e){super(),this.gain=e.gain!=null?e.gain:1}apply(e,t){return O(()=>{if(e.length!==2||e[0]!==e[1])throw new V("Identity matrix initializer can only be used for 2D square matrices.");return B(this.gain,um(e[0]))})}getConfig(){return{gain:this.gain}}};lI.className="Identity";re.registerClass(lI);function xG(e,t="channelsLast"){let n,r;if(Mt(t),e.length===2)n=e[0],r=e[1];else if([3,4,5].indexOf(e.length)!==-1){if(t==="channelsFirst"){let s=da(e,2);n=e[1]*s,r=e[0]*s}else if(t==="channelsLast"){let s=da(e,0,e.length-2);n=e[e.length-2]*s,r=e[e.length-1]*s}}else{let s=da(e);n=Math.sqrt(s),r=Math.sqrt(s)}return[n,r]}var Vn=class extends Mr{constructor(e){if(super(),e.scale<0)throw new V(`scale must be a positive float. Got: ${e.scale}`);this.scale=e.scale==null?1:e.scale,this.mode=e.mode==null?"fanIn":e.mode,yG(this.mode),this.distribution=e.distribution==null?"normal":e.distribution,vG(this.distribution),this.seed=e.seed}apply(e,t){let n=xG(e),r=n[0],s=n[1],a=this.scale;if(this.mode==="fanIn"?a/=Math.max(1,r):this.mode==="fanOut"?a/=Math.max(1,s):a/=Math.max(1,(r+s)/2),this.distribution==="normal"){let o=Math.sqrt(a);if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Le(`${this.getClassName()} does not support dType ${t}.`);return Tm(e,0,o,t,this.seed)}else{let o=Math.sqrt(3*a);return $a(e,-o,o,t,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}};Vn.className="VarianceScaling";re.registerClass(Vn);var Mm=class extends Vn{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Vn.className}};Mm.className="GlorotUniform";re.registerClass(Mm);var Lm=class extends Vn{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Vn.className}};Lm.className="GlorotNormal";re.registerClass(Lm);var zm=class extends Vn{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Vn.className}};zm.className="HeNormal";re.registerClass(zm);var Bm=class extends Vn{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Vn.className}};Bm.className="HeUniform";re.registerClass(Bm);var Wm=class extends Vn{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Vn.className}};Wm.className="LeCunNormal";re.registerClass(Wm);var Vm=class extends Vn{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Vn.className}};Vm.className="LeCunUniform";re.registerClass(Vm);var dI=class extends Mr{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=e.gain==null?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,t){return O(()=>{if(e.length<2)throw new Le("Shape must be at least 2D.");if(t!=="int32"&&t!=="float32"&&t!==void 0)throw new TypeError(`Unsupported data type ${t}.`);t=t;let n=w.sizeFromShape(e.slice(0,-1)),r=e[e.length-1],s=n*r;s>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${s}) elements: Slowness may result.`);let a=[Math.max(r,n),Math.min(r,n)],o=Pm(a,0,1,t,this.seed),i=Gw.qr(o,!1),u=i[0],l=i[1].flatten().stridedSlice([0],[Math.min(r,n)*Math.min(r,n)],[Math.min(r,n)+1]);return u=B(u,l.sign()),n<r&&(u=u.transpose()),B(xe(this.gain),u.reshape(e))})}getConfig(){return{gain:this.gain,seed:this.seed}}};dI.className="Orthogonal";re.registerClass(dI);var RS={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function PS(e,t={}){return Cp(e,re.SerializationMap.getMap().classNameMap,t,"initializer")}function At(e){return nI(e)}function Tt(e){if(typeof e=="string"){let t=e in RS?RS[e]:e;if(t==="GlorotNormal")return new Lm;if(t==="GlorotUniform")return new Mm;if(t==="HeNormal")return new zm;if(t==="HeUniform")return new Bm;if(t==="LeCunNormal")return new Wm;if(t==="LeCunUniform")return new Vm;{let n={};return n.className=t,n.config={},PS(n)}}else return e instanceof Mr?e:PS(e)}function qv(e){return Array.isArray(e)&&Array.isArray(e[0])}function gf(e){return e.length===0?[]:Array.isArray(e[0])?e:[e]}function Ne(e){let t;if(Array.isArray(e)){if(e.length!==1)throw new V(`Expected Tensor length to be 1; got ${e.length}`);t=e[0]}else t=e;return t}function Qe(e){if(Array.isArray(e)&&Array.isArray(e[0])){if(e.length===1)return e=e,e[0];throw new V(`Expected exactly 1 Shape; got ${e.length}`)}else return e}function bf(e){let t=0;for(let n of e)n.shape.length===0?t+=1:t+=n.shape.reduce((r,s)=>r*s);return t}var OS="Variable",$N=class{constructor(e,t="float32",n=OS,r=!0,s=null){this.dtype=t??"float32",this.shape=e.shape,this.id=CN(),n=n??OS,this.originalName=NN(n),this.name=_N(this.originalName),this.trainable_=r,this.constraint=s,this.val=Lw(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),wG(this.val,e),this.val.id!==e.id&&(this.val.assign(e),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}};function wG(e,t){if(e.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(e.shape)+" vs. "+JSON.stringify(t.shape))}function Kv(e){return e.map(t=>t.read())}function pI(e){e.forEach(t=>{t[0].write(t[1])})}var Wt=class{constructor(e){this.dtype=e.dtype,this.shape=e.shape,e.shape!=null?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}},Ur=class{constructor(e,t,n,r,s,a,o){this.dtype=e,this.shape=t,this.sourceLayer=n,this.inputs=r,this.callArgs=s,this.outputTensorIndex=o,this.id=CN(),a!=null&&(this.originalName=NN(a),this.name=_N(this.originalName)),this.rank=t.length}},IG=0,Um=class{constructor(e,t){this.callArgs=t,this.id=IG++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(let n of e.inboundLayers)n?.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){let e=[];for(let t of this.inboundLayers)t!=null?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}},kG=0,We=class extends re.Serializable{constructor(e={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=kG++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){let n=this.getClassName();t=_s(n)+"_"+Rm(n)}if(this.name=t,this.trainable_=e.trainable==null?!0:e.trainable,e.inputShape!=null||e.batchInputShape!=null){let n;if(e.batchInputShape!=null)n=e.batchInputShape;else if(e.inputShape!=null){let s=null;e.batchSize!=null&&(s=e.batchSize),n=[s].concat(e.inputShape)}this.batchInputShape=n;let r=e.dtype;r==null&&(r=e.inputDType),r==null&&(r="float32"),this.dtype=r}e.weights!=null?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(this.inboundNodes.length===0)throw new Vr(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new V(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return Mn(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return Mn(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new Ns(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new Ns(`Layer ${this.name} is not connected, no input to return.`);return Mn(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new Ns(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new Ns(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return Mn(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(e=>e())}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach(t=>t.trainable=e),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(e=>e.trainable):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(e=>!e.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){if(e=It(e),this.inputSpec==null||this.inputSpec.length===0)return;let t=It(this.inputSpec);if(e.length!==t.length)throw new V(`Layer ${this.name} expects ${t.length} inputs, but it received ${e.length} input tensors. Input received: ${e}`);for(let n=0;n<e.length;n++){let r=e[n],s=t[n];if(s==null)continue;let a=r.rank;if(s.ndim!=null&&a!==s.ndim)throw new V(`Input ${n} is incompatible with layer ${this.name}: expected ndim=${s.ndim}, found ndim=${a}`);if(s.maxNDim!=null&&a>s.maxNDim)throw new V(`Input ${n} is incompatible with layer ${this.name}: expected max_ndim=${s.maxNDim}, found ndim=${a}`);if(s.minNDim!=null&&a<s.minNDim)throw new V(`Input ${n} is incompatible with layer ${this.name}: expected min_ndim=${s.minNDim}, found ndim=${a}.`);if(s.dtype!=null&&r.dtype!==s.dtype)throw new V(`Input ${n} is incompatible with layer ${this.name} : expected dtype=${s.dtype}, found dtype=${r.dtype}.`);if(s.axes){let o=r.shape;for(let i in s.axes){let u=Number(i),c=s.axes[i],l=u>=0?o[u]:o[o.length+u];if(c!=null&&[c,null].indexOf(l)===-1)throw new V(`Input ${n} is incompatible with layer ${this.name}: expected axis ${u} of input shape to have value ${c} but got shape ${o}.`)}}if(s.shape!=null)for(let o=0;o<s.shape.length;++o){let i=s.shape[o],u=r.shape[o];if(i!=null&&u!=null&&i!==u)throw new V(`Input ${n} is incompatible with layer ${this.name}: expected shape=${s.shape}, found shape=${r.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){this._callHook!=null&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();let n=It(e),r=!0;for(let a of n)if(!(a instanceof Ur)){r=!1;break}let s=!0;for(let a of n)if(a instanceof Ur){s=!1;break}if(r===s)throw new V("Arguments to apply() must be all SymbolicTensors or all Tensors");return io(this.name,()=>{if(!this.built){this.assertInputCompatibility(e);let a=[];for(let o of It(e))a.push(o.shape);this.build(Mn(a)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&s&&(this._refCount=1)}if(this.assertInputCompatibility(e),s){let a=this.call(e,t),o=It(a),i=[];for(let u of o)n.indexOf(u)!==-1&&(u=u.clone()),i.push(u);if(a=Mn(i),this.activityRegularizer!=null)throw new Le("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return a}else{let a=SG(e),o=this.computeOutputShape(a),i,u=CG(e);if(this.warnOnIncompatibleInputShape(Array.isArray(e)?a[0]:a),o!=null&&o.length>0&&Array.isArray(o[0])?i=o.map((c,l)=>new Ur(u,c,this,It(e),t,this.name,l)):i=new Ur(u,o,this,It(e),t,this.name),this.addInboundNode(e,i,null,null,a,o,t),this._refCount++,this.activityRegularizer!=null)throw new Le("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return i}})}warnOnIncompatibleInputShape(e){if(this.batchInputShape!=null)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach((n,r)=>{n!=null&&e[r]!=null&&e[r]!==n&&(t=!0)}),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new Ns(`The layer ${this.name} has never been called and thus has no defined output shape.`);let e=[];for(let t of this.inboundNodes){let n=JSON.stringify(t.outputShapes);e.indexOf(n)===-1&&e.push(n)}if(e.length===1){let t=this.inboundNodes[0].outputShapes;return Array.isArray(t)&&Array.isArray(t[0])&&t.length===1?t[0]:t}else throw new Ns(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new Vr(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return bf(this.weights)}build(e){this.built=!0}getWeights(e=!1){return Kv(e?this.trainableWeights:this.weights)}setWeights(e){O(()=>{let t=this.weights;if(t.length!==e.length)throw new V(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(t.length===0)return;let n=[],r=Kv(t);for(let s=0;s<r.length;++s){let a=r[s],o=t[s],i=e[s];if(!w.arraysEqual(a.shape,i.shape))throw new V(`Layer weight shape ${a.shape} not compatible with provided weight shape ${i.shape}`);n.push([o,i])}pI(n)})}addWeight(e,t,n,r,s,a,o,i){if(this._addedWeightNames.indexOf(e)!==-1)throw new V(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),n==null&&(n="float32"),this.fastWeightInitDuringBuild&&(r=i!=null?i():Tt("zeros"));let u=r.apply(t,n),c=new $N(u,n,e,a,o);return u.dispose(),s!=null&&this.addLoss(()=>s.apply(c.read())),a==null&&(a=!0),a?this._trainableWeights.push(c):this._nonTrainableWeights.push(c),c}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){e==null||Array.isArray(e)&&e.length===0||(e=It(e),this._losses!==void 0&&this._losses!==null&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(t!=null)if(Array.isArray(t))t.forEach(n=>{if(n!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return t}addInboundNode(e,t,n,r,s,a,o=null){let i=It(e);t=It(t),n=It(n),r=It(r),s=gf(s),a=gf(a);let u=[],c=[],l=[];for(let p of i)u.push(p.sourceLayer),c.push(p.nodeIndex),l.push(p.tensorIndex);new Um({outboundLayer:this,inboundLayers:u,nodeIndices:c,tensorIndices:l,inputTensors:i,outputTensors:t,inputMasks:n,outputMasks:r,inputShapes:s,outputShapes:a},o);for(let p=0;p<t.length;p++)t[p].sourceLayer=this,t[p].nodeIndex=this.inboundNodes.length-1,t[p].tensorIndex=p}getConfig(){let e={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(e.batchInputShape=this.batchInputShape),this.dtype!=null&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach(e=>e.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return--this._refCount===0&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}};function SG(e){e=It(e);let t=[];for(let n of e)t.push(n.shape);return Mn(t)}function CG(e){return"float32"}function FN(e,t,n){if((t==null||n!=null&&n>0)&&(t=e.sourceLayer,n=e.nodeIndex),t.inboundNodes.length===0)return[e];{let r=t.inboundNodes[n];if(r.inboundLayers.length===0)return r.inputTensors;{let s=[];for(let a=0;a<r.inboundLayers.length;a++){let o=r.inputTensors[a],i=r.inboundLayers[a],u=r.nodeIndices[a],c=FN(o,i,u);for(let l of c)s.indexOf(l)===-1&&s.push(l)}return s}}}var bl=class extends We{constructor(e){if(super({dtype:e.dtype,name:e.name!=null?e.name:Rm("input").toString()}),e.batchSize==null&&(e.batchSize=null),e.sparse==null&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,e.inputShape!=null&&e.batchInputShape!=null)throw new V("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(t==null){if(e.inputShape==null)throw new V("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(e.batchSize!=null)throw new V("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");let n=e.dtype||"float32";this.batchInputShape=t,this.dtype=n,this.inputSpec=[{shape:t}];let r=new Ur(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new Um({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new V(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}};bl.className="InputLayer";re.registerClass(bl);function RN(e){if(e.batchShape==null&&e.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(e.batchShape!=null&&e.shape!=null)throw new V("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=e.batchShape;e.shape!=null&&t==null&&(t=[null].concat(e.shape));let n=e.dtype;return n==null&&(n="float32"),new bl({batchInputShape:t,name:e.name,dtype:n,sparse:e.sparse}).inboundNodes[0].outputTensors[0]}function TG(e,t){if(e.dtype==null||e.dtype===t.dtype)return t;try{return ae(t,e.dtype)}catch{throw new V(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${e.name}' (${e.dtype}).`)}}var so=class{constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof so)for(let t in e.id2Value)this.id2Value[t]=e.id2Value[t],t in e.id2Mask&&(this.id2Mask[t]=e.id2Mask[t]);else{if(e==null)return;for(let t of e)this.add(t.key,t.value)}}add(e,t,n){if(this.id2Value[e.id]==null)this.id2Value[e.id]=TG(e,t),this.name2Id[e.name]=e.id,n!=null&&(this.id2Mask[e.id]=n);else throw new V(`Duplicate key: name=${e.name}, id=${e.id}`);return this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return this.id2Value[e.id]!=null}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof Ur){if(this.id2Value[e.id]==null)throw new V(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}else{let t=this.name2Id[e];if(t==null)throw new V(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[t]}}getMask(e){if(e instanceof Ur){if(this.id2Value[e.id]==null)throw new V(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}else{let t=this.name2Id[e];if(t==null)throw new V(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[t]}}disposeMasks(){this.id2Mask!=null&&_e(this.id2Mask)}},yf=new IN,vf=new IN;function NG(e){yf?.setMaxEntries(e),vf?.setMaxEntries(e)}function od(e,t,n,r){let s=n==null?!1:n.training,a=Array.isArray(e),o=a?e:[e],i=o.map(f=>f.name),u=[],c=t.names();for(let f of i)c.indexOf(f)!==-1?u.push(t.getValue(f)):u.push(null);r!=null&&(r.maxNumTensors=-1/0,r.minNumTensors=1/0);let l=i.join(",")+"|"+t.names().sort().join(","),p=yf.get(l),d;if(p==null){let f=_G(o,t);p=f.sorted,d=f.recipientCounts,yf.put(l,p),vf.put(l,d)}d={},s||Object.assign(d,vf.get(l));let h=new so(t);for(let f=0;f<p.length;++f){if(r!=null){let $=ff().numTensors;$>r.maxNumTensors&&(r.maxNumTensors=$),$<r.minNumTensors&&(r.minNumTensors=$)}let g=p[f],m=g.sourceLayer;if(m instanceof bl)continue;let b=[],v=[],y=[],x=!1;for(let $ of g.inputs){let R=h.getValue($),D=h.getMask($);b.push(R),v.push(D),D!=null&&(x=!0),s||(d[$.name]--,d[$.name]===0&&!t.hasKey($)&&i.indexOf($.name)===-1&&!R.isDisposed&&$.sourceLayer.stateful!==!0&&y.push(R))}x&&(n=n||{},n.mask=v[0]);let k=It(m.apply(b,n)),S=null;m.supportsMasking&&(S=m.computeMask(b,v));let N=AG(g),E=Array.isArray(N)?N:[N];for(let $=0;$<E.length;++$){h.hasKey(E[$])||h.add(E[$],k[$],Array.isArray(S)?S[0]:S);let R=i.indexOf(E[$].name);R!==-1&&(u[R]=k[$])}s||_e(y)}return h.disposeMasks(),a?u:u[0]}function _G(e,t){w.assert(e!=null&&e.length>0,()=>"Expected at least one fetch, got none");let n=[],r={};if(e.length===1){let s=MS(e[0],t);n=s.sorted,r=s.recipientMap}else{let s=new Set;for(let a of e){let{sorted:o,recipientMap:i}=MS(a,t);for(let u of o)s.has(u.name)||(n.push(u),s.add(u.name));for(let u in i)r[u]==null&&(r[u]=new Set),i[u].forEach(c=>r[u].add(c))}}return{sorted:n,recipientCounts:EG(r)}}function EG(e){let t={};for(let n in e)t[n]=e[n].size;return t}function MS(e,t){let n=new Set,r=[],s={};for(let i of t.names())n.add(i);let a=[],o=[];for(a.push(e);a.length>0;){let i=a[a.length-1];if(n.has(i.name)){a.pop();continue}let u=o[o.length-1]===a.length-1;if(i.inputs.length===0||u)a.pop(),r.push(i),n.add(i.name),u&&o.pop();else{o.push(a.length-1);for(let c of i.inputs)s[c.name]==null&&(s[c.name]=new Set),s[c.name].add(i.name),!n.has(c.name)&&a.push(c)}}return{sorted:r,recipientMap:s}}function AG(e){let t;if(e.sourceLayer.inboundNodes.length===1)t=e.sourceLayer.output;else{let n=null;for(let r=0;r<e.sourceLayer.inboundNodes.length;++r)for(let s of e.sourceLayer.inboundNodes[r].outputTensors)if(s.id===e.id){n=r;break}t=e.sourceLayer.getOutputAt(n)}return t}var DG=G();DG.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,NG);var PN={};Ee(PN,{maxNorm:()=>$G,minMaxNorm:()=>PG,nonNeg:()=>RG,unitNorm:()=>FG});function hI(e,t){return O(()=>fn(ge(B(e,e),t,!0)))}var Ep=class extends re.Serializable{getConfig(){return{}}},fI=class extends Ep{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return O(()=>{let t=hI(e,this.axis),n=an(t,0,this.maxValue);return B(e,fe(n,X(Xt(),t)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}};fI.className="MaxNorm";re.registerClass(fI);var mI=class extends Ep{constructor(e){super(),this.defaultAxis=0,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return O(()=>fe(e,X(Xt(),hI(e,this.axis))))}getConfig(){return{axis:this.axis}}};mI.className="UnitNorm";re.registerClass(mI);var gI=class extends Ep{apply(e){return Ke(e)}};gI.className="NonNeg";re.registerClass(gI);var bI=class extends Ep{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=e.minValue!=null?e.minValue:this.defaultMinValue,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.rate=e.rate!=null?e.rate:this.defaultRate,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return O(()=>{let t=hI(e,this.axis),n=X(B(this.rate,an(t,this.minValue,this.maxValue)),B(1-this.rate,t));return B(e,fe(n,X(Xt(),t)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}};bI.className="MinMaxNorm";re.registerClass(bI);var LS={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function Zt(e){return nI(e)}function zS(e,t={}){return Cp(e,re.SerializationMap.getMap().classNameMap,t,"constraint")}function Jt(e){if(e==null)return null;if(typeof e=="string"){let n={className:e in LS?LS[e]:e,config:{}};return zS(n)}else return e instanceof Ep?e:zS(e)}function $G(e){return new fI(e)}function FG(e){return new mI(e)}function RG(){return new gI}function PG(e){return new bI(e)}var ON={};Ee(ON,{constant:()=>LG,glorotNormal:()=>HG,glorotUniform:()=>GG,heNormal:()=>jG,heUniform:()=>qG,identity:()=>VG,leCunNormal:()=>KG,leCunUniform:()=>XG,ones:()=>MG,orthogonal:()=>YG,randomNormal:()=>BG,randomUniform:()=>zG,truncatedNormal:()=>WG,varianceScaling:()=>UG,zeros:()=>OG});function OG(){return new aI}function MG(){return new Om}function LG(e){return new oI(e)}function zG(e){return new iI(e)}function BG(e){return new uI(e)}function WG(e){return new cI(e)}function VG(e){return new lI(e)}function UG(e){return new Vn(e)}function GG(e){return new Mm(e)}function HG(e){return new Lm(e)}function jG(e){return new zm(e)}function qG(e){return new Bm(e)}function KG(e){return new Wm(e)}function XG(e){return new Vm(e)}function YG(e){return new dI(e)}var MN={};Ee(MN,{Layer:()=>We,RNN:()=>ys,RNNCell:()=>Rp,activation:()=>S6,add:()=>F6,alphaDropout:()=>g5,average:()=>R6,averagePooling1d:()=>_k,averagePooling2d:()=>Ek,averagePooling3d:()=>Ak,avgPool1d:()=>U6,avgPool2d:()=>H6,avgPool3d:()=>q6,avgPooling1d:()=>G6,avgPooling2d:()=>j6,avgPooling3d:()=>K6,batchNormalization:()=>B6,bidirectional:()=>u5,categoryEncoding:()=>w5,centerCrop:()=>v5,concatenate:()=>P6,conv1d:()=>m6,conv2d:()=>g6,conv2dTranspose:()=>b6,conv3d:()=>y6,conv3dTranspose:()=>v6,convLstm2d:()=>s5,convLstm2dCell:()=>a5,cropping2D:()=>w6,dense:()=>C6,depthwiseConv2d:()=>k6,dot:()=>z6,dropout:()=>T6,elu:()=>c6,embedding:()=>$6,flatten:()=>_6,gaussianDropout:()=>m5,gaussianNoise:()=>f5,globalAveragePooling1d:()=>X6,globalAveragePooling2d:()=>Y6,globalMaxPool1d:()=>l5,globalMaxPool2d:()=>d5,globalMaxPooling1d:()=>A_,globalMaxPooling2d:()=>D_,gru:()=>J6,gruCell:()=>Q6,input:()=>t_,inputLayer:()=>u6,layerNormalization:()=>W6,leakyReLU:()=>d6,lstm:()=>e5,lstmCell:()=>t5,masking:()=>b5,maxPool1d:()=>p5,maxPool2d:()=>h5,maxPooling1d:()=>$_,maxPooling2d:()=>F_,maxPooling3d:()=>Z6,maximum:()=>O6,minimum:()=>M6,multiply:()=>L6,permute:()=>D6,prelu:()=>p6,randomWidth:()=>I5,reLU:()=>l6,repeatVector:()=>E6,rescaling:()=>y5,reshape:()=>A6,resizing:()=>x5,rnn:()=>o5,separableConv2d:()=>x6,simpleRNN:()=>n5,simpleRNNCell:()=>r5,softmax:()=>h6,spatialDropout1d:()=>N6,stackedRNNCells:()=>i5,thresholdedReLU:()=>f6,timeDistributed:()=>c5,upSampling2d:()=>I6,zeroPadding2d:()=>V6});async function na(e){if(e==null)return;let t=[],n=[],r=[];for(let s in e){let a=e[s];if(typeof a!="number"){let o=a;t.push(o.data()),n.push(s),r.push(o)}}if(t.length>0){let s=await Promise.all(t);for(let a=0;a<s.length;++a)e[n[a]]=s[a][0];_e(r)}}function LN(e){if(e!=null)for(let t in e){let n=e[t];typeof n!="number"&&n.dispose()}}var BS;(function(e){e[e.SILENT=0]="SILENT",e[e.VERBOSE=1]="VERBOSE"})(BS||(BS={}));var ZG=125,tc=class{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}},zN=class{constructor(e,t=10){e==null&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(let t of this.callbacks)t.setParams(e)}setModel(e){for(let t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onEpochBegin(e,t)}async onEpochEnd(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onEpochEnd(e,t)}async onBatchBegin(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onBatchBegin(e,t)}async onBatchEnd(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onBatchEnd(e,t)}async onTrainBegin(e){e==null&&(e={});for(let t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){e==null&&(e={});for(let t of this.callbacks)await t.onTrainEnd(e)}},JG=class extends tc{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){t==null&&(t={});let n=t.size==null?0:t.size;this.seen+=n;for(let r in t){let s=t[r];if(typeof s=="number")this.totals.hasOwnProperty(r)||(this.totals[r]=0),this.totals[r]=this.totals[r]+s*n;else{let a;r in this.totals?a=this.totals[r]:this.totals[r]=0;let o=O(()=>X(this.totals[r],B(s,n)));this.totals[r]=o,a?.dispose()}}}async onEpochEnd(e,t){if(t!=null)for(let n of this.params.metrics)this.totals[n]!=null&&(typeof this.totals[n]=="number"?t[n]=this.totals[n]/this.seen:O(()=>{let r=B(fe(1,this.seen),this.totals[n]);t[n]=r,this.totals[n].dispose(),qt(t[n])}))}},BN=class extends tc{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){t==null&&(t={}),this.epoch.push(e);for(let n in t)this.history[n]==null&&(this.history[n]=[]),this.history[n].push(t[n])}async syncData(){let e=[],t=[],n=[];for(let s in this.history){let a=this.history[s];for(let o=0;o<a.length;++o)if(typeof a[o]!="number"){let i=a[o];e.push(i.data()),t.push(s),n.push(o)}}let r=await Promise.all(e);for(let s=0;s<r.length;++s)this.history[t[s]][n[s]].dispose(),this.history[t[s]][n[s]]=r[s][0]}},WN=class extends tc{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||eI,this.yieldEvery=t||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=ZG),this.yieldEvery==="never"&&e.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");w.isNumber(this.yieldEvery)&&(this.maybeWait=QU(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,n){let r=[];this.yield!=null&&(await na(n),r.push(this.yield(e,t,n))),r.push(this.nextFrameFunc()),await Promise.all(r)}async onEpochBegin(e,t){this.currentEpoch=e,this.epochBegin!=null&&(await na(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){let n=[];this.epochEnd!=null&&(await na(t),n.push(this.epochEnd(e,t))),this.yieldEvery==="epoch"&&n.push(this.nextFrameFunc()),await Promise.all(n)}async onBatchBegin(e,t){this.batchBegin!=null&&(await na(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){let n=[];this.batchEnd!=null&&(await na(t),n.push(this.batchEnd(e,t))),this.yieldEvery==="batch"?n.push(this.nextFrameFunc()):w.isNumber(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(n)}async onTrainBegin(e){this.trainBegin!=null&&(await na(e),await this.trainBegin(e))}async onTrainEnd(e){this.trainEnd!=null&&(await na(e),await this.trainEnd(e))}};function VN(e,t){return e==null&&(e={}),e instanceof tc?[e]:Array.isArray(e)&&e[0]instanceof tc?e:It(e).map(r=>new WN(r,t))}var Ar=class{constructor(){}static registerCallbackConstructor(e,t){w.assert(e>=0&&Number.isInteger(e),()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`),Ar.checkForDuplicate(t),Ar.constructors[e]==null&&(Ar.constructors[e]=[]),Ar.constructors[e].push(t)}static checkForDuplicate(e){for(let t in Ar.constructors)Ar.constructors[+t].forEach(r=>{if(r===e)throw new V("Duplicate callback constructor.")})}static clear(){Ar.constructors={}}static createCallbacks(e){let t=[];for(let n in Ar.constructors){let r=+n;e>=r&&t.push(...Ar.constructors[r])}return t.map(n=>new n)}};Ar.constructors={};function UN(e,t,n,r,s,a,o,i,u){let c=new BN,l=[new JG,...Ar.createCallbacks(t)];e!=null&&l.push(...e),l.push(c);let p=new zN(l);return p.setParams({epochs:n,initialEpoch:r,samples:s,steps:a,batchSize:o,verbose:t,doValidation:i,metrics:u}),{callbackList:p,history:c}}function Hr(e,t={},n=!1){return Cp(e,re.SerializationMap.getMap().classNameMap,t,"layer",n)}function xf(e,t){return O(()=>{e.dtype!=="float32"&&(e=ae(e,"float32"));let n=ge(Np(e),t,!0),r=xn(n.shape,Xt()),s=fn(gs(n,r));return fe(e,s)})}function Ji(e,t){return O(()=>Et(Np(de(t,e)),-1))}function Gm(e,t){return O(()=>Et(Bt(de(t,e)),-1))}function yl(e,t){return O(()=>{let n=de(e,t),r=an(Bt(e),Xt(),Number.MAX_VALUE),s=Bt(fe(n,r));return B(100,Et(s,-1))})}function QG(e,t){return O(()=>{let n=an(t,Xt(),Number.MAX_VALUE),r=rr(X(1,n)),s=an(e,Xt(),Number.MAX_VALUE),a=rr(X(1,s));return Et(Np(de(r,a)),-1)})}function eH(e,t){return O(()=>{let n=gs(0,de(1,B(e,t)));return Et(Np(n),-1)})}function tH(e,t){return O(()=>{let n=gs(0,de(1,B(e,t)));return Et(n,-1)})}function nH(e,t){return O(()=>{let n=ge(B(e,t),-1),r=fr(B(de(1,e),t),-1);return gs(0,X(1,de(r,n)))})}function rH(e,t){return O(()=>{let n=Math.log(2),r=de(t,e),s=de(X(r,qi(B(-2,r))),n);return Et(s,-1)})}function _d(e,t,n=!1){return O(()=>{if(n)t=Yr(t);else{let r=ge(t,t.shape.length-1,!0);t=fe(t,r)}return t=an(t,Xt(),1-Xt()),bt(ge(B(ae(e,"float32"),rr(t)),t.shape.length-1))})}function wf(e,t,n=!1){return O(()=>{let r=ae(fl(dG(e)),"int32");t=an(t,Xt(),1-Xt());let s=t.shape,a=W(Ku(r,s[s.length-1]),s);return _d(a,t,n)})}function sH(e,t){if(!w.arraysEqual(e.shape,t.shape))throw new V(`logits and labels must have the same shape, but got shapes ${JSON.stringify(e.shape)} and ${JSON.stringify(t.shape)}`);return O(()=>{let n=Ke(t),r=bt(Bt(t));return X(de(n,B(t,e)),gp(vn(r)))})}function Hm(e,t){return O(()=>{let n;return n=an(t,Xt(),1-Xt()),n=rr(fe(n,de(1,n))),Et(sH(e,n),-1)})}function aH(e,t){return O(()=>{let n=an(e,Xt(),1),r=an(t,Xt(),1);return ge(B(e,rr(fe(n,r))),-1)})}function oH(e,t){return O(()=>{let n=rr(X(Xt(),t));return Et(de(t,B(e,n)),-1)})}function yI(e,t){return O(()=>{let n=xf(e,-1),r=xf(t,-1),s=B(n,r);return bt(ge(s,-1))})}var If={meanSquaredError:Ji,meanAbsoluteError:Gm,meanAbsolutePercentageError:yl,meanSquaredLogarithmicError:QG,squaredHinge:eH,hinge:tH,categoricalHinge:nH,logcosh:rH,categoricalCrossentropy:_d,sparseCategoricalCrossentropy:wf,binaryCrossentropy:Hm,kullbackLeiblerDivergence:aH,poisson:oH,cosineProximity:yI};function xv(e){if(typeof e=="string"){if(e in If)return If[e];let t=`Unknown loss ${e}`;throw e.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${e}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new V(t)}else return e}function vI(e,t){return O(()=>{let n=B(.5,sr(t)),r=cs(Dn(t,n),e.dtype);return Et(nr(e,r),-1)})}function xI(e,t){return O(()=>cs(nr(mo(e,-1),mo(t,-1)),"float32"))}function GN(e,t){return O(()=>ae(ge(Rr(nr(e,1),nr(t,1))),"float32"))}function iH(e,t){return O(()=>ae(ge(Rr(nr(e,1),nr(t,0))),"float32"))}function uH(e,t){return O(()=>ae(ge(Rr(nr(e,0),nr(t,1))),"float32"))}function HN(e,t){return O(()=>{let n=GN(e,t),r=uH(e,t),s=X(n,r);return ae(sn(Dn(s,0),fe(n,s),0),"float32")})}function cH(e,t){return O(()=>{let n=GN(e,t),r=iH(e,t),s=X(n,r);return ae(sn(Dn(s,0),fe(n,s),0),"float32")})}function jN(e,t){return Hm(e,t)}function qN(e,t){return e.rank===t.rank&&(e=Ra(e,[e.rank-1])),t=mo(t,-1),t.dtype!==e.dtype&&(t=ae(t,e.dtype)),ae(nr(e,t),"float32")}var lH=Ji,dH=Ji,pH=Gm,hH=Gm,fH=yl,mH=yl,wI=_d,gH=yI,KN=wf,kf={binaryAccuracy:vI,categoricalAccuracy:xI,precision:HN,categoricalCrossentropy:wI,sparseCategoricalCrossentropy:KN,mse:lH,MSE:dH,mae:pH,MAE:hH,mape:fH,MAPE:mH,cosine:gH};function bH(e){if(typeof e=="string"&&e in kf)return kf[e];if(typeof e!="string"&&e!=null)return e;throw new V(`Unknown metric ${e}`)}function Wh(e){if(as(e!==null,`Unknown LossOrMetricFn ${e}`),typeof e=="string")return e;{let t;for(let n of Object.keys(If))if(If[n]===e){t=n;break}if(t!==void 0)return t;for(let n of Object.keys(kf))if(kf[n]===e){t=n;break}return t!==void 0?t:e.name}}function yH(e){let t={Adagrad:()=>Ya.adagrad(.01),Adadelta:()=>Ya.adadelta(1,.95,Xt()),Adam:()=>Ya.adam(.001,.9,.999,Xt()),Adamax:()=>Ya.adamax(.002,.9,.999,Xt(),0),RMSProp:()=>Ya.rmsprop(.001,.9,0,Xt()),SGD:()=>Ya.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,e in t)return t[e]();throw new V(`Unknown Optimizer ${e}`)}var WS=1*1024*1024;function VS(e,t,n=!1){if(e==null||typeof e!="object"||Object.getPrototypeOf(e)!==Object.prototype||!Xv(e))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){let r=JSON.stringify(e);r.length>WS&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${r.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${WS}.`)}}function Xv(e){if(e===null)return!0;if(typeof e=="object")if(Object.getPrototypeOf(e)===Object.prototype){let t=Object.keys(e);for(let n of t)if(typeof n!="string"||!Xv(e[n]))return!1;return!0}else if(Array.isArray(e)){for(let t of e)if(!Xv(t))return!1;return!0}else return!1;else{let t=typeof e;return t==="string"||t==="number"||t==="boolean"}}function vH(e,t,n,r=console.log){let s=wH(e),a=["Layer (type)","Input Shape","Output shape","Param #"];s?(t=t||90,n=n||[.32,.61,.89,1]):(t=t||115,n=n||[.24,.48,.7,.8,1]),n[n.length-1]<=1&&(n=n.map(l=>Math.floor(t*l)));let o;if(!s){a.push("Receives inputs"),o=[];for(let l in e.nodesByDepth)o.push(...e.nodesByDepth[l])}r("_".repeat(t)),Sf(a,n,r),r("=".repeat(t));let i=e.layers;for(let l=0;l<i.length;++l)s?IH(i[l],n,r):kH(i[l],n,o,r),r((l===i.length-1?"=":"_").repeat(t));e.checkTrainableWeightsConsistency();let u=xH(e),c=bf(e.nonTrainableWeights);r(`Total params: ${u+c}`),r(`Trainable params: ${u}`),r(`Non-trainable params: ${c}`),r("_".repeat(t))}function xH(e){let t;return e.collectedTrainableWeights!=null?t=bf(e.collectedTrainableWeights):t=bf(e.trainableWeights),t}function wH(e){let t=!0,n=[],r=[];for(let s in e.nodesByDepth)n.push(e.nodesByDepth[s]);for(let s of n){if(s.length>1||s.length===1&&s[0].inboundLayers.length>1){t=!1;break}r.push(...s)}if(t)for(let s of e.layers){let a=!1;for(let o of s.inboundNodes)if(r.indexOf(o)!==-1)if(a){t=!1;break}else a=!0;if(!t)break}return t}function Sf(e,t,n=console.log){let r="";for(let s=0;s<e.length;++s)s>0&&(r=r.slice(0,r.length-1)+" "),r+=e[s],r=r.slice(0,t[s]),r+=" ".repeat(t[s]-r.length);n(r)}function IH(e,t,n){let r,s;try{s=e.inboundNodes.map(u=>JSON.stringify(u.inputShapes)).join(",")}catch{s="multiple"}try{r=JSON.stringify(e.outputShape)}catch{r="multiple"}let a=e.name,o=e.getClassName(),i=[`${a} (${o})`,s,r,e.countParams().toString()];Sf(i,t,n)}function kH(e,t,n,r){let s,a;try{a=e.inboundNodes.map(p=>JSON.stringify(p.inputShapes)).join(",")}catch{a="multiple"}try{s=JSON.stringify(e.outputShape)}catch{s="multiple"}let o=[];for(let p of e.inboundNodes)if(!(n!=null&&n.length>0&&n.indexOf(p)===-1))for(let d=0;d<p.inboundLayers.length;++d){let h=p.inboundLayers[d].name,f=p.nodeIndices[d],g=p.tensorIndices[d];o.push(`${h}[${f}][${g}]`)}let i=e.name,u=e.getClassName(),c=o.length===0?"":o[0],l=[`${i} (${u})`,a,s,e.countParams().toString(),c];Sf(l,t,r);for(let p=1;p<o.length;++p)Sf(["","","","",o[p]],t,r)}function XN(e,t,n){return(e==="inboundNodes"||e==="outputLayers"||e==="inputLayers")&&t===0&&typeof n=="string"}function Ed(e,t){if(e===null)return null;if(typeof e=="string")return eo(e);if(typeof e=="number"||typeof e=="boolean")return e;if(e instanceof Array){let n=[],r=e.length;for(let s=0;s<r;++s){let a=e[s];XN(t,s,a)?n.push(a):n.push(Ed(a,t))}return n}else{let n={};for(let r of Object.keys(e)){let s=e[r];if(r==="name"&&typeof s=="string")n[r]=s;else{let a=eo(r);n[a]=Ed(s,a)}}return n}}function Yv(e,t){if(e==null)return null;if(typeof e=="string")return _s(e);if(typeof e=="number"||typeof e=="boolean")return e;if(e instanceof Array){let n=[],r=e.length;for(let s=0;s<r;++s){let a=e[s];XN(t,s,a)?n.push(a):n.push(Yv(a,t))}return n}else{let n={};for(let r of Object.keys(e)){let s=e[r],a=_s(r);(r==="name"||r==="className")&&typeof s=="string"?n[a]=s:n[a]=Yv(s,r)}return n}}var II="4.9.0",rs=class extends We{constructor(e){if(super({}),this.containerNodes=new Set,this.name=e.name,this.name==null){let b=this.getClassName().toLowerCase();this.name=Rm(b)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],la(this.inputs).length!==this.inputs.length)throw new V(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(b=>b.name)}`);la(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(b=>b.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(let b of this.outputs){let v=b.sourceLayer,y=b.nodeIndex,x=b.tensorIndex;this.outputLayers.push(v),this.outputLayersNodeIndices.push(y),this.outputLayersTensorIndices.push(x)}for(let b of this.inputs){let v=b.sourceLayer,y=b.nodeIndex,x=b.tensorIndex;as(y===0,"input layer has >1 nodes"),as(x===0,"input layer has >1 tensors"),this.inputLayers.push(v),this.inputLayersNodeIndices.push(y),this.inputLayersTensorIndices.push(x)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let b=0;b<this.inputLayers.length;b++){let v=this.inputLayers[b];if(!(v instanceof bl))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${b} (0-based) originates from layer type ${v.getClassName()}.`);this.inputNames.push(v.name),this.feedInputShapes.push(v.batchInputShape),this.feedInputNames.push(v.name)}for(let b of this.outputLayers)this.outputNames.push(b.name);this.internalInputShapes=this.inputs.map(b=>b.shape),this.internalOutputShapes=this.outputs.map(b=>b.shape);let t={},n={},r={},s={},a={},o=[],i=(b,v,y,x,k,S)=>{(x==null||k==null||S==null)&&(x=b.sourceLayer,k=b.nodeIndex,S=b.tensorIndex);let N=x.inboundNodes[k];if(y.indexOf(N)!==-1)throw new Vr(`The tensor ${b.name} at layer "${x.name}" is part of a cycle.`);if(v.indexOf(N)!==-1)return;this.containerNodes.add(rs.nodeKey(x,k)),x.id in a||(a[x.id]=Object.keys(a).length),y.indexOf(N)===-1&&y.push(N);let E=N.inboundLayers.length;for(let $=0;$<E;$++){let R=N.inputTensors[$],D=N.inboundLayers[$],F=N.nodeIndices[$],C=N.tensorIndices[$];i(R,v,y,D,F,C)}for(v.push(N);y.indexOf(N)>=0;)y.splice(y.indexOf(N),1);o.push(N)},u=[],c=[];for(let b of this.outputs)i(b,u,c);let l=o.slice().reverse();for(let b of l){n[b.id]=b,b.id in t||(t[b.id]=0);let v=t[b.id],y=r[b.outboundLayer.id]==null?0:r[b.outboundLayer.id];v=Math.max(v,y),r[b.outboundLayer.id]=v,s[b.outboundLayer.id]=b.outboundLayer,t[b.id]=v;for(let x=0;x<b.inboundLayers.length;x++){let k=b.inboundLayers[x],S=b.nodeIndices[x],N=k.inboundNodes[S],E=t[N.id]==null?0:t[N.id];t[N.id]=Math.max(v+1,E),n[N.id]=N}}let p={};for(let b in t){let v=t[b];v in p||(p[v]=[]),p[v].push(n[b])}let d={};for(let b in r){let v=r[b];v in d||(d[v]=[]),d[v].push(s[b])}let h=Object.keys(d).map(b=>parseInt(b,10)).sort(Lh);this.layers=[];for(let b of h){let v=d[b];v.sort((y,x)=>{let k=a[y.id],S=a[x.id];return k<S?-1:k>S?1:0});for(let y of v)y instanceof rs&&this.internalContainerRefs.push(y),this.layers.push(y)}this.layersByDepth=d,h=Object.keys(p).map(b=>parseInt(b,10)).sort(Lh);let f=this.inputs.slice(),g=[];for(let b of h)for(let v of p[b]){let y=v.outboundLayer;if(y!=null){for(let x of v.inputTensors)if(f.indexOf(x)===-1)throw new Vr(`Graph disconnected: cannot obtain value for tensor ${x} at layer "${y.name}". The following previous layers were accessed without issue: ${g}`);for(let x of v.outputTensors)f.push(x);g.push(y.name)}}this.nodesByDepth=p;let m=this.layers.map(b=>b.name);for(let b of m){let v=m.filter(y=>y===b).length;if(v!==1)throw new Vr(`The name "${b}" is used ${v} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(m))}this.outboundNodes=[],this.inboundNodes=[],new Um({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(b=>null),outputMasks:this.outputs.map(b=>null),inputShapes:this.inputs.map(b=>b.shape),outputShapes:this.outputs.map(b=>b.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();let e={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(let t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(let t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach(t=>{t._trainableWeights.forEach(n=>n.trainable=e)}),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new V("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(let t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){let e=[];for(let t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){let t=[];for(let n of this.layers)t.push(...n.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e,t=!0){let n={},r=0,s=Object.keys(e)[0].split("/"),a=!isNaN(parseInt(s[s.length-1],10));for(let i of this.layers)for(let[u,c]of i.weights.entries()){let l=a?`${c.name.split("/").slice(0,-1).join("/")+"/"}${u}`:c.originalName;if(n[l]!=null)throw new V(`Duplicate weight name: ${l}`);n[l]=c,r++}let o=[];for(let i in e){let u=i;if(n[i]==null){let c=i.split("/");u=c.slice(0,-2).concat([c[c.length-1]]).join("/")}if(n[u]!=null)o.push([n[u],e[i]]);else if(t)throw new V(`Provided weight data has no target variable: ${i}`);delete n[u]}if(t){let i=[];for(let u in n)i.push(u);if(i.length>0)throw new V(`${i.length} of ${r} weights are not set: ${i}`)}pI(o)}updatedConfig(){let e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion=`tfjs-layers ${II}`,t.backend="TensorFlow.js",t}toJSON(e,t=!0){let n=Yv(this.updatedConfig());return t?JSON.stringify(n):n}call(e,t){return O(()=>{e=It(e);let n=new so;for(let r=0;r<this.inputs.length;++r)n.add(this.inputs[r],e[r]);return od(this.outputs,n,t)})}computeMask(e,t){return O(()=>{e=It(e);let n;return t==null?n=wo(null,e.length):n=It(t),this.runInternalGraph(e,n)[1]})}computeOutputShape(e){let t=gf(e);if(t.length!==this.inputLayers.length)throw new V(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);let n={};for(let o=0;o<t.length;o++){let i=this.inputLayers[o],u=t[o],c=i.name+"_0_0";n[c]=u}let r=Object.keys(this.nodesByDepth).map(o=>parseInt(o,10)).sort(Lh);if(r.length>1)for(let o of r){let i=this.nodesByDepth[o];for(let u of i){let c=u.outboundLayer;if(this.inputLayers.map(f=>f.id).indexOf(c.id)!==-1)continue;let l=[];for(let f=0;f<u.inboundLayers.length;f++){let g=u.inboundLayers[f],m=u.nodeIndices[f],b=u.tensorIndices[f],v=`${g.name}_${m}_${b}`,y=n[v];l.push(y)}let p=c.computeOutputShape(Mn(l)),d=gf(p),h=c.inboundNodes.indexOf(u);for(let f=0;f<d.length;f++){let g=`${c.name}_${h}_${f}`;n[g]=d[f]}}}let s=[],a=[];for(let o=0;o<this.outputLayers.length;o++){let i=this.outputLayers[o],u=this.outputLayersNodeIndices[o],c=this.outputLayersTensorIndices[o],l=`${i.name}_${u}_${c}`;a.push(l)}for(let o=0;o<a.length;o++){let i=a[o];as(i in n),s.push(n[i])}return Mn(s)}runInternalGraph(e,t){t==null&&(t=wo(null,e.length));let n={};for(let i=0;i<this.inputs.length;++i){let u=this.inputs[i],c=e[i],l=t[i];n[u.id]=[c,l]}let r=Object.keys(this.nodesByDepth).map(i=>parseInt(i,10)).sort(Lh);for(let i of r){let u=this.nodesByDepth[i];for(let c of u){let l=c.outboundLayer,p=c.inputTensors,d=c.outputTensors,h=new Array;for(let f of p)f.id in n&&h.push(n[f.id]);if(h.length===p.length){let f={},g,m,b,v;if(c.callArgs!=null&&(f=c.callArgs),h.length===1){let[y,x]=h[0];f.mask==null&&(f.mask=x),b=It(l.call(y,f)),v=It(l.computeMask(y,x)),g=[y],m=[x]}else g=h.map(y=>y[0]),m=h.map(y=>y[1]),f.mask==null&&(f.mask=m),b=It(l.call(g,f)),v=It(l.computeMask(g,m));if(l.activityRegularizer)throw new Le("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let y=0;y<d.length;++y){let x=d[y],k=b[y],S=v[y];n[x.id]=[k,S]}}}}let s=[],a=[],o=[];for(let i of this.outputs){as(i.id in n,`Could not compute output ${i.name} : ${i.id}`);let[u,c]=n[i.id];o.push(u.shape),s.push(u),a.push(c)}return[s,a,o]}buildNodeConversionMap(e){let t={},n;for(let r of this.layers){n=r instanceof rs?1:0;for(let s=0;s<r.inboundNodes.length;s++){let a=rs.nodeKey(r,s);this.containerNodes.has(a)&&(t[a]=n,n+=1)}}return t}getLayer(e,t){if(t!=null)return this.findLayer(t);if(e==null)throw new V("Provide either a layer name or layer index");if(typeof e=="number")return this.findLayer(e);for(let n of this.layers)if(n.name===e)return n;throw new V(`No such layer: ${e}`)}findLayer(e){if(this.layers.length<=e)throw new V(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}calculateLosses(){return O(()=>{let e=[];for(let t of this.layers)for(let n=0;n<t.inboundNodes.length;++n){let r=rs.nodeKey(t,n);this.containerNodes.has(r)&&e.push(...t.calculateLosses())}return e})}getConfig(){let e={name:this.name},t=this.buildNodeConversionMap(this.layers),n=[];for(let a of this.layers){let o=a.getClassName(),i=a.getConfig(),u=[];for(let l=0;l<a.inboundNodes.length;l++){let p=a.inboundNodes[l],d=rs.nodeKey(a,l),h={};if(this.containerNodes.has(d)){if(p.callArgs)try{JSON.stringify(p.callArgs),h=p.callArgs}catch{console.warn(`Layer ${a.name} was passed non-serializable keyword arguments: ${p.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),h={}}if(p.inboundLayers.length>0){let f=[];for(let g=0;g<p.inboundLayers.length;g++){let m=p.inboundLayers[g],b=p.nodeIndices[g],v=p.tensorIndices[g],y=rs.nodeKey(m,b),x=t[y];x==null&&(x=0),f.push([m.name,x,v,h])}u.push(f)}}}let c={};c.name=a.name,c.className=o,c.config=i,c.inboundNodes=u,n.push(c)}e.layers=n;let r=[];for(let a=0;a<this.inputLayers.length;a++){let o=this.inputLayers[a],i=this.inputLayersNodeIndices[a],u=rs.nodeKey(o,i);if(!this.containerNodes.has(u))continue;let c=t[u];c==null&&(c=0);let l=this.inputLayersTensorIndices[a];r.push([o.name,c,l])}e.inputLayers=r;let s=[];for(let a=0;a<this.outputLayers.length;a++){let o=this.outputLayers[a],i=this.outputLayersNodeIndices[a],u=rs.nodeKey(o,i);if(!this.containerNodes.has(u))continue;let c=t[u];c==null&&(c=0);let l=this.outputLayersTensorIndices[a];s.push([o.name,c,l])}return e.outputLayers=s,e}static fromConfig(e,t,n={},r=!1){let s={},a={};function o(g,m){g.name in a?a[g.name].push(m):a[g.name]=[m]}function i(g,m){let b=[],v;for(let y of m){let x=y[0],k=y[1],S=y[2];if(v=y[3]==null?{}:y[3],!(x in s)){o(g,m);return}let N=s[x];if(N.inboundNodes.length<=k){o(g,m);return}let E=N.inboundNodes[k];b.push(E.outputTensors[S])}b.length>0&&g.apply(Mn(b),v)}function u(g){let m=g.name,b=Hr(g,t.customObjects!=null?t.customObjects:{});b.setFastWeightInitDuringBuild(r),s[m]=b,g.inboundNodes.forEach(y=>{if(!(y instanceof Array))throw new V(`Corrupted configuration, expected array for nodeData: ${y}`);o(b,y)})}let c=t.name,l=t.layers;for(let g of l)u(g);for(;!JU(a);)for(let g of l){let m=s[g.name];if(m.name in a){let b=a[m.name];delete a[m.name];for(let v of b)i(m,v)}}let p=[],d=[],h=t.inputLayers;for(let g of h){let m=g[0],b=g[1],v=g[2];as(m in s);let x=s[m].inboundNodes[b].outputTensors;p.push(x[v])}let f=t.outputLayers;for(let g of f){let m=g[0],b=g[1],v=g[2];as(m in s);let x=s[m].inboundNodes[b].outputTensors;d.push(x[v])}return new e({inputs:p,outputs:d,name:c})}get stateful(){if(this._stateful)throw new V("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(let e of this.layers)if(e.stateful)return!0;return!1}resetStates(){O(()=>{this.layers.forEach(e=>{e.stateful&&e.resetStates()})})}};function SH(e,t,n){let r=t.length;if(e==null||Array.isArray(e)&&e.length===0)return t.map(s=>null);if(r===1)return Array.isArray(e)&&e.length===1?e:typeof e=="object"&&t[0]in e?[e[t[0]]]:[e];if(Array.isArray(e)){if(e.length!==r)throw new Error(`Provided ${n} is an array of ${e.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return e}else if(typeof e=="object"&&Object.keys(e).length>0&&typeof e[Object.keys(e)[0]]=="object"){let s=[];return t.forEach(a=>{a in e?s.push(e[a]):s.push(null)}),s}else throw new Error(`The model has multiple (${r}) outputs, so ${n} must be either an array with ${r} elements or an object with ${t} keys. Provided ${n} not understood: ${JSON.stringify(e)}`)}function YN(e,t){return SH(e,t,"classWeight")}async function ZN(e,t,n,r){if(t!=null||r!=null)throw new Error("Support sampleWeight is not implemented yet");if(n!=null){let s=O(()=>{if(e.shape.length===1)return us(e);if(e.shape.length===2){if(e.shape[1]>1)return mo(e,1);if(e.shape[1]===1)return W(e,[e.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${e.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${e.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),a=Array.from(await s.data());_e(s);let o=[];return a.forEach(i=>{if(n[i]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${i} exists in the data but not in classWeight`);o.push(n[i])}),He(o,"float32")}else return null}function CH(e,t){return B(e,t)}var TH=32;function JN(e,t){let n,r,s=t;n=s.xs,r=s.ys,w.assert(n!=null&&r!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`);let a=US("input",e.inputNames,n),o=US("output",e.outputNames,r),i=a[0].shape[0];w.assert(a.length===e.inputs.length,()=>`LayersModel has ${e.inputs.length} inputs, but the dataset provides ${a.length} inputs.  (Expected input keys: ${JSON.stringify(e.inputNames)})`),w.assert(o.length===e.outputs.length,()=>`LayersModel has ${e.outputs.length} outputs, but the dataset provides ${o.length} outputs.  (Expected output keys: ${JSON.stringify(e.outputNames)})`);for(let u=0;u<a.length;u++)w.assert(a[u].shape[0]===i,()=>`Batch size mismatch: input ${e.inputNames[u]} has ${a[u].shape[0]}; expected  ${i} based on input ${e.inputNames[0]}.`);for(let u=0;u<o.length;u++)w.assert(o[u].shape[0]===i,()=>`Batch size mismatch: output ${e.outputNames[u]} has ${o[u].shape[0]}; expected  ${i} based on input ${e.inputNames[0]}.`);return{xs:a,ys:o}}function US(e,t,n){if(n instanceof Te)return[n];if(Array.isArray(n))return w.assert(n.length===t.length,()=>`Received an array of ${n.length} Tensors, but expected ${t.length} to match the ${e} keys ${t}.`),n;{let r=[];for(let s of t){if(n[s]==null)throw new V(`The feature data generated by the dataset lacks the required ${e} key '${s}'.`);r.push(n[s])}return r}}function NH(e){if(e.length===3)throw new Le("Validation with sample weights is not implemented yet.");return{xs:e[0],ys:e[1]}}async function _H(e,t,n){let r=n.batchesPerEpoch!=null;if(w.assert(e.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),w.assert(n!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),w.assert(n.epochs!=null&&n.epochs>0&&Number.isInteger(n.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${n.epochs}`),w.assert(!r||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${n.batchesPerEpoch}`),w.assert(n.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0;try{let s=n.validationData!=null,a,o;if(s)if(GS(n.validationData))w.assert(n.validationBatches==null||n.validationBatches>0&&Number.isInteger(n.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${n.validationBatches}`);else{let m=NH(n.validationData);a=m.xs,o=m.ys}let i=e.makeTrainFunction(),u=e.getDedupedMetricsNames(),c;s?c=u.slice().concat(u.map(m=>"val_"+m)):c=u.slice();let l=VN(n.callbacks,n.yieldEvery),p=n.verbose==null?1:n.verbose,{callbackList:d,history:h}=UN(l,p,n.epochs,null,null,EH(t,n),null,s,c);d.setModel(e),e.history=h,await d.onTrainBegin(),e.stopTraining_=!1;let f=n.initialEpoch==null?0:n.initialEpoch,g=await t.iterator();for(;f<n.epochs;){let m={};await d.onEpochBegin(f);let b=0,v=0;for(r||(g=await t.iterator());!r||b<n.batchesPerEpoch;){let y=await g.next();if(r&&y.done){console.warn(`You provided \`batchesPerEpoch\` as ${n.batchesPerEpoch}, but your dataset iterator ran out of data after ${b} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${n.batchesPerEpoch*n.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(y.value!=null){let{xs:x,ys:k}=JN(e,y.value),S={};S.batch=v,S.size=x[0].shape[0],await d.onBatchBegin(v,S);let N=[];if(n.classWeight!=null){let R=YN(n.classWeight,e.outputNames);for(let D=0;D<R.length;++D)N.push(await ZN(k[D],null,R[D]))}let E=x.concat(k).concat(N),$=i(E);_e(E);for(let R=0;R<u.length;++R){let D=u[R],F=$[R];S[D]=F,qt(F)}await d.onBatchEnd(v,S),LN(S),v++,b++}if(r?b>=n.batchesPerEpoch:y.done){if(s){let x;GS(n.validationData)?x=It(await e.evaluateDataset(n.validationData,{batches:n.validationBatches})):x=It(e.evaluate(a,o,{batchSize:n.validationBatchSize==null?TH:n.validationBatchSize,verbose:0}));for(let k=0;k<e.metricsNames.length;++k)m[`val_${e.metricsNames[k]}`]=x[k]}break}if(e.stopTraining_)break}if(await d.onEpochEnd(f,m),f++,e.stopTraining_)break}return await d.onTrainEnd(),await e.history.syncData(),e.history}finally{e.isTraining=!1}}function EH(e,t){let n=null;return t.batchesPerEpoch!=null?n=t.batchesPerEpoch:Number.isFinite(e.size)&&(n=e.size),n}function GS(e){return typeof e.iterator=="function"}function AH(e){return typeof e.next=="function"}async function DH(e,t,n){n=n||{};let r=n.batches!=null,s=e.testFunction,a=[];if(n.verbose>0)throw new Le("Verbose mode is not implemented yet.");w.assert(!r||n.batches>0&&Number.isInteger(n.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(n.batches)}`);let o=AH(t)?t:await t.iterator(),i=0,u=0;for(;!r||u<n.batches;){let c=await o.next();if(a=O(()=>{if(c.value){let{xs:l,ys:p}=JN(e,c.value),d=l.concat(p),h=O(()=>s(d));if(_e(d),u===0)for(let g=0;g<h.length;++g)a.push(xe(0));let f=d[0].shape[0];for(let g=0;g<h.length;++g){let m=h[g],b=a[g];a[g]=O(()=>X(a[g],B(f,m))),u>0&&_e(b)}_e(h),i+=f,++u}return a}),c.done){r&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${n.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let c=0;c<a.length;++c){let l=a[c];a[c]=fe(a[c],i),_e(l)}return Mn(a)}function wv(e){w.assert(e>0&&Number.isInteger(e),()=>`batchSize is required to be a positive integer, but got ${e}`)}function ed(e,t,n){return e==null?[null]:Array.isArray(e)?e.map(r=>uo(r,t,n-t)):uo(e,t,n-t)}function Zv(e,t){return O(()=>e==null?null:Array.isArray(e)?e.map(n=>Zv(n,t)):AN(e,t.dtype==="int32"?t:ae(t,"int32")))}function Iv(e,t){let n=[],r=0,s=null;for(;r<e;)s=r+t,s>=e&&(s=e),n.push([r,s]),r=s;return n}function QN(e){let t=[];e instanceof Te&&(e=[e]);for(let n=0;n<e.length;++n){let r=e[n];if(r.rank===1)t.push(Tp(r,1));else{if(r.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(r)}}return t}function Br(e,t){if(e==null)return;let n=[];if(t instanceof Te)n.push(t.id);else if(Array.isArray(t))t.forEach(s=>n.push(s.id));else if(t!=null)for(let s in t){let a=t[s];n.push(a.id)}let r=[];if(e instanceof Te)n.indexOf(e.id)===-1&&r.push(e);else if(Array.isArray(e))e.forEach(s=>{n.indexOf(s.id)===-1&&r.push(s)});else if(e!=null)for(let s in e){let a=e[s];n.indexOf(a.id)===-1&&r.push(a)}r.forEach(s=>{s.isDisposed||s.dispose()})}function $H(e){return e instanceof Te}function Jv(e){return Array.isArray(e)}function HS(e){return!$H(e)&&!Jv(e)}function jS(e,t,n,r=!0,s=""){if(t==null||t.length===0){if(e!=null){let o=!1;if(Jv(e)&&e.length>0)o=!0;else if(HS(e)){for(let i in e)if(e.hasOwnProperty(i)){o=!0;break}}else o=!0;if(o)throw new V(`Error when checking model ${s} expected no data, but got ${e}`)}return[]}if(e==null)return t.map(o=>null);let a;if(HS(e)){e=e,a=[];for(let o of t){if(e[o]==null)throw new V(`No data provided for "${o}". Need data for each key in: ${t}`);a.push(e[o])}}else if(Jv(e)){if(e=e,e.length!==t.length)throw new V(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${e}`);a=e}else{if(e=e,t.length>1)throw new V(`The model ${s} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${e.shape}`);a=[e]}if(a=QN(a),n!=null)for(let o=0;o<t.length;++o){if(n[o]==null)continue;let i=a[o];if(i.shape.length!==n[o].length)throw new V(`Error when checking ${s}: expected ${t[o]} to have ${n[o].length} dimension(s). but got array with shape ${i.shape}`);for(let u=0;u<n[o].length;++u){if(u===0&&!r)continue;let c=i.shape[u],l=n[o][u];if(l!=null&&l>=0&&c!==l)throw new V(`${s} expected a batch of elements where each example has shape [${n[o].slice(1,n[o].length)}] (i.e.,tensor shape [*,${n[o].slice(1,n[o].length)}]) but the ${s} received an input with ${i.shape[0]} examples, each with shape [${i.shape.slice(1,i.shape.length)}] (tensor shape [${i.shape}])`)}}return a}function FH(e,t,n){let r=la(e.map(a=>a.shape[0]));r.sort();let s=la(t.map(a=>a.shape[0]));if(s.sort(),r.length>1)throw new V(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(a=>a.shape))}`);if(s.length>1)throw new V(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(a=>a.shape))}`);if(r.length>0&&s.length>0&&!w.arraysEqual(r,s))throw new V(`Input Tensors should have the same number of samples as target Tensors. Found ${r[0]} input sample(s) and ${s[0]} target sample(s).`)}function RH(e,t,n){let r=[Ji,Hm,_d];for(let s=0;s<e.length;++s){let a=e[s],o=t[s],i=n[s];if(o!=null){if(o===_d&&a.shape[a.shape.length-1]===1)throw new V(`You are passing a target array of shape ${a.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(r.indexOf(o)!==-1){let u=a.shape.slice(1),c=i.slice(1);for(let l=0;l<u.length;++l){let p=u[l],d=c[l];if(d!=null&&p!==d)throw new V(`A target Tensor with shape ${a.shape} was passed for an output of shape ${i}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function qS(e,t,n,r=!0,s=""){let a;if(Array.isArray(e)){if(e.length!==t.length)throw new V(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${e.length} Tensors(s).`);a=e}else{if(t.length>1)throw new V(`The model expects ${t.length} ${s} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(e.shape)}.`);a=[e]}if(n!=null)for(let o=0;o<t.length;++o){if(n[o]==null)continue;let i=a[o];if(i.shape.length!==n[o].length)throw new V(`Error when checking ${s}: expected ${t[o]} to have ${n[o].length} dimension(s), but got array with shape ${JSON.stringify(i.shape)}`);for(let u=0;u<n[o].length;++u){if(u===0&&!r)continue;let c=i.shape[u],l=n[o][u];if(l!=null&&l!==c)throw new V(`Error when checking ${s}: expected ${t[o]} to have shape ${JSON.stringify(n[o])} but got array with shape ${JSON.stringify(i.shape)}.`)}}}function PH(e,t){if(e==null||Array.isArray(e)&&e.length===0)return t.map(r=>[]);let n;if(typeof e=="string"||typeof e=="function")n=[e];else if(Array.isArray(e)||typeof e=="object")n=e;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${e}`);if(Array.isArray(n))return t.map(r=>n);{let r=[];for(let s of t){let a=n.hasOwnProperty(s)?n[s]:[];Array.isArray(a)||(a=[a]),r.push(a)}return r}}var OH="layers-model",Fs=class extends rs{constructor(e){super(e),this.isTraining=!1}summary(e,t,n=console.log){if(!this.built)throw new V("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");vH(this,e,t,n)}compile(e){if(e.loss==null&&(e.loss=[]),this.loss=e.loss,typeof e.optimizer=="string")this.optimizer_=yH(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof zs))throw new V("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(!Array.isArray(e.loss)&&typeof e.loss!="string"&&typeof e.loss!="function"){e.loss=e.loss;for(let a in e.loss)if(this.outputNames.indexOf(a)===-1)throw new V(`Unknown entry in loss dictionary: "${a}". Only expected the following keys: ${this.outputNames}`);for(let a of this.outputNames)e.loss[a]==null&&console.warn(`Output "${a}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${a} during training`),t.push(xv(e.loss[a]))}else if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new V(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);t=e.loss.map(o=>xv(o))}else{let a=xv(e.loss);this.outputs.forEach(o=>{t.push(a)})}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let a=0;a<this.outputs.length;++a){let o=this.internalOutputShapes[a],i=this.outputNames[a];this.feedOutputNames.push(i),this.feedOutputShapes.push(o),this.feedLossFns.push(this.lossFunctions[a])}let n=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],io("loss",()=>{for(let a=0;a<this.outputs.length;++a){if(n.indexOf(a)!==-1)continue;let o=this.lossFunctions[a];this.outputs.length>1&&(this.metricsTensors.push([o,a]),this.metricsNames.push(this.outputNames[a]+"_loss"))}});let r=PH(e.metrics,this.outputNames),s=(a,o,i)=>{this.outputNames.length>1&&(o=this.outputNames[a]+"_"+o),this.metricsNames.push(o),this.metricsTensors.push([i,a])};io("metric",()=>{for(let a=0;a<this.outputs.length;++a){if(n.indexOf(a)!==-1)continue;let o=r[a];(u=>{let c="",l,p,d;for(let h of u){if(typeof h=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(h)!==-1){let g=this.internalOutputShapes[a];g[g.length-1]===1||this.lossFunctions[a]===Hm?["accuracy","acc"].indexOf(h)!==-1?p=vI:["crossentropy","ce"].indexOf(h)!==-1&&(p=jN):this.lossFunctions[a]===wf?["accuracy","acc"].indexOf(h)!==-1?p=qN:["crossentropy","ce"].indexOf(h)!==-1&&(p=KN):["accuracy","acc"].indexOf(h)!==-1?p=xI:["crossentropy","ce"].indexOf(h)!==-1&&(p=wI);let m;["accuracy","acc"].indexOf(h)!==-1?m="acc":["crossentropy","ce"].indexOf(h)!==-1&&(m="ce"),d=p,l=c+m}else d=bH(h),l=c+Wh(h);let f;io(l,()=>{f=d}),s(a,l,f)}})(o)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t,n={}){let r=n.batchSize==null?32:n.batchSize;wv(r);let s=!0,a=this.standardizeUserDataXY(e,t,s,r);try{let o=a[0].concat(a[1]);this.makeTestFunction();let i=this.testFunction,u=this.testLoop(i,o,r,n.verbose,n.steps);return Mn(u)}finally{Br(a[0],e),Br(a[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),DH(this,e,t)}checkNumSamples(e,t,n,r="steps"){let s;if(n!=null){if(s=null,t!=null)throw new V(`If ${r} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else if(e!=null)Array.isArray(e)?s=e[0].shape[0]:s=e.shape[0];else throw new V(`Either the input data should have a defined shape, or ${r} shoud be specified.`);return s}execute(e,t){if(Array.isArray(t)&&t.length===0)throw new V("`outputs` is an empty Array, which is not allowed.");let n=Array.isArray(t),r=n?t:[t],s=this.retrieveSymbolicTensors(r),a=new so;if(e instanceof Te&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new V(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let i=0;i<this.inputs.length;++i)a.add(this.inputs[i],e[i])}else for(let i of this.inputs){let u=e[i.name];if(u==null)throw new V(`No value is provided for the model's input ${i.name}`);a.add(i,u)}let o=od(s,a);return n?o:o[0]}retrieveSymbolicTensors(e){let t=wo(null,e.length),n=e.length;for(let r of this.layers){let s=Array.isArray(r.output)?r.output:[r.output],a=s.map(o=>o.name);for(let o=0;o<e.length;++o){let i=a.indexOf(e[o]);if(i!==-1&&(t[o]=s[i],n--),n===0)break}if(n===0)break}if(n>0){let r=[];throw t.forEach((s,a)=>{s==null&&r.push(e[a])}),new V(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(r)}`)}return t}predictLoop(e,t=32,n=!1){return O(()=>{let r=this.checkNumSamples(e);if(n)throw new Le("Verbose predictLoop() is not implemented yet.");let s=Iv(r,t),a=this.outputs.map(o=>[]);for(let o=0;o<s.length;++o)O(()=>{let u=s[o][0],c=s[o][1],l=ed(e,u,c),p=[];if(Array.isArray(l))for(let h=0;h<l.length;++h)p.push({key:this.inputs[h],value:l[h]});else p.push({key:this.inputs[0],value:l});let d=new so(p);return od(this.outputs,d)}).forEach((u,c)=>a[c].push(u));return Mn(a.map(o=>tt(o,0)))})}predict(e,t={}){let n=QN(e);qS(n,this.inputNames,this.feedInputShapes,!1);try{let r=t.batchSize==null?32:t.batchSize;return wv(r),this.predictLoop(n,r)}finally{Br(n,e)}}predictOnBatch(e){qS(e,this.inputNames,this.feedInputShapes,!0);let t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t,n=!0,r){if(this.optimizer_==null)throw new Vr("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");let s=[];for(let a=0;a<this.feedOutputShapes.length;++a){let o=this.feedOutputShapes[a];this.feedLossFns[a]===wf?s.push(o.slice(0,o.length-1).concat([1])):s.push(o)}if(e=jS(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=jS(t,this.feedOutputNames,s,!1,"target"),FH(e,t,null),RH(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&r!=null&&r>0&&e[0].shape[0]%r!==0)throw new V(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${r}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,n,r,s=!0,a){let[o,i]=this.standardizeUserDataXY(e,t,s,a);if(n!=null)throw new Error("sample weight is not supported yet.");let u=null;if(r!=null){let c=YN(r,this.outputNames);u=[];for(let l=0;l<c.length;++l)u.push(await ZN(i[l],null,c[l]))}return[o,i,u]}testLoop(e,t,n,r=0,s){return O(()=>{let a=this.checkNumSamples(t,n,s,"steps"),o=[];if(r>0)throw new Le("Verbose mode is not implemented yet.");if(s!=null)throw new Le("steps mode in testLoop() is not implemented yet");{let i=Iv(a,n),u=He(qr(0,a));for(let c=0;c<i.length;++c){let l=i[c][0],p=i[c][1],d=uo(u,l,p-l),h=Zv(t,d),f=e(h);if(c===0)for(let g=0;g<f.length;++g)o.push(xe(0));for(let g=0;g<f.length;++g){let m=f[g];o[g]=X(o[g],B(p-l,m))}}for(let c=0;c<o.length;++c)o[c]=fe(o[c],a)}return o})}getDedupedMetricsNames(){let e=this.metricsNames,t=[];for(let n=0;n<e.length;++n){let r=e[n],s=r;if(DS(e,r)>1){let a=DS(e.slice(0,n),r);s+=`_${a}`}t.push(s)}return t}makeTrainFunction(){return e=>{let t=[],n=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),s=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),a=[],o=()=>{let l=[];for(let f=0;f<this.inputs.length;++f)l.push({key:this.inputs[f],value:n[f]});let p=new so(l),d=od(this.outputs,p,{training:!0}),h;for(let f=0;f<this.lossFunctions.length;++f){let g=this.lossFunctions[f],m=g(r[f],d[f]);s[f]!=null&&(m=CH(m,s[f]));let b=Et(m);t.push(b),f===0?h=m:h=X(h,m)}for(let f=0;f<this.metricsTensors.length;++f){let g;if(this.outputs.length>1&&f<this.outputs.length)g=t[f];else{let m=this.metricsTensors[f][0],b=this.metricsTensors[f][1];g=Et(m(r[b],d[b]))}qt(g),a.push(g)}return h=Et(h),this.calculateLosses().forEach(f=>{h=X(h,f)}),h},i=this.collectedTrainableWeights.map(l=>l.read()),u=!0;return[this.optimizer_.minimize(o,u,i)].concat(a)}}makeTestFunction(){this.testFunction=e=>O(()=>{let t=[],n,r=e.slice(0,this.inputs.length),s=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=[];for(let u=0;u<this.inputs.length;++u)a.push({key:this.inputs[u],value:r[u]});let o=new so(a),i=od(this.outputs,o);for(let u=0;u<this.lossFunctions.length;++u){let c=this.lossFunctions[u],l=Et(c(s[u],i[u]));u===0?n=l:n=X(n,l),t.push(n)}for(let u=0;u<this.metricsTensors.length;++u){let c=this.metricsTensors[u][0],l=this.metricsTensors[u][1],p=Et(c(s[l],i[l]));t.push(p)}return t})}async fit(e,t,n={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;let r,s,a,o,i,u,c,l,p;try{let d=n.batchSize==null?32:n.batchSize;wv(d);let h=!1,f=await this.standardizeUserData(e,t,n.sampleWeight,n.classWeight,h,d);r=f[0],s=f[1],p=f[2];let g=!1,m;if(n.validationData!=null&&n.validationData.length>0){if(g=!0,n.validationData.length===2)i=n.validationData[0],u=n.validationData[1];else throw n.validationData.length===3?new Le("validationData including sample weights is not supported yet."):new V(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${n.validationData} is invalid.`);let E=!0,$=await this.standardizeUserData(i,u,null,null,E,d);c=$[0],l=$[1],m=c.concat(l)}else if(n.validationSplit!=null&&n.validationSplit>0&&n.validationSplit<1){g=!0;let E=Math.floor(r[0].shape[0]*(1-n.validationSplit)),$=r[0].shape[0];c=ed(r,E,$),a=r,r=ed(r,0,E),l=ed(s,E,$),o=s,s=ed(s,0,E),m=c.concat(l)}else n.validationSteps!=null&&(g=!0);let b=r.concat(s).concat(p);this.checkTrainableWeightsConsistency();let v=this.makeTrainFunction(),y=this.getDedupedMetricsNames(),x,k;g?(this.makeTestFunction(),x=this.testFunction,k=y.slice().concat(y.map(E=>"val_"+E))):(x=null,m=[],k=y.slice());let S=VN(n.callbacks,n.yieldEvery);return await this.fitLoop(v,b,y,d,n.epochs,n.verbose,S,x,m,n.shuffle,k,n.initialEpoch,null,null)}finally{this.isTraining=!1,Br(r,e),Br(s,t),Br(a,e),Br(o,t),Br(c,i),Br(l,u),p!=null&&_e(p)}}async fitLoop(e,t,n,r,s,a,o,i,u,c,l,p,d,h){r==null&&(r=32),s==null&&(s=1),c==null&&(c=!0),p==null&&(p=0);let f=!1;if(i!=null&&u!=null&&(f=!0),h!=null&&(f=!0,d==null))throw new V("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");let g=this.checkNumSamples(t,r,d,"steps_per_epoch"),m;g!=null&&(m=qr(0,g)),a==null&&(a=1);let{callbackList:b,history:v}=UN(o,a,s,p,g,d,r,f,l);b.setModel(this),this.history=v,await b.onTrainBegin(),this.stopTraining_=!1;for(let y=p;y<s;++y){await b.onEpochBegin(y);let x={};if(d!=null)throw new Le("stepsPerEpoch mode is not implemented yet.");{if(c==="batch")throw new Le("batch shuffling is not implemneted yet");c&&w.shuffle(m);let k=He(m),S=Iv(g,r);for(let N=0;N<S.length;++N){let E={};if(await b.onBatchBegin(N,E),O(()=>{let $=S[N][0],R=S[N][1],D=uo(k,$,R-$);E.batch=N,E.size=R-$;let F=Zv(t,D),C=e(F);for(let L=0;L<n.length;++L){let U=n[L],H=C[L];E[U]=H,qt(H)}if(N===S.length-1&&f){let L=this.testLoop(i,u,r);for(let U=0;U<n.length;++U){let H=n[U],K=L[U];qt(K),x["val_"+H]=K}}}),await b.onBatchEnd(N,E),LN(E),this.stopTraining_)break}k.dispose()}if(await b.onEpochEnd(y,x),this.stopTraining_)break}return await b.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,t){return _H(this,e,t)}async trainOnBatch(e,t){let n=await this.standardizeUserData(e,t),r=n[0],s=n[1],o=this.makeTrainFunction()(r.concat(s)),i=[];for(let u of o){let c=await u.data();i.push(c[0])}return _e(o),Br(n[0],e),Br(n[1],t),Mn(i)}getNamedWeights(e){let t=[],n=e!=null&&e.trainableOnly,r=n?this.trainableWeights:this.weights,s=this.getWeights(n);for(let a=0;a<r.length;++a)n&&!r[a].trainable||t.push({name:r[a].originalName,tensor:s[a]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){let e=super.dispose();if(e.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){let t=ff().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-ff().numTensors}return e}getLossIdentifiers(){let e;if(typeof this.loss=="string")e=_s(this.loss);else if(Array.isArray(this.loss)){for(let t of this.loss)if(typeof t!="string")throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(t=>_s(t))}else{let t=Object.keys(this.loss);e={};let n=this.loss;for(let r of t)if(typeof n[r]=="string")e[r]=_s(n[r]);else throw new Error("Serialization of non-string loss is not supported.")}return e}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[_s(Wh(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>_s(Wh(e)));{let e={};for(let t in this.metrics)e[t]=_s(Wh(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(e.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(e.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(e.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");let t=Ed(e.optimizer_config),n=Hr(t),r;if(typeof e.loss=="string")r=eo(e.loss);else if(Array.isArray(e.loss))r=e.loss.map(a=>eo(a));else if(e.loss!=null){r={};for(let a in e.loss)r[a]=eo(e.loss[a])}let s;if(Array.isArray(e.metrics))s=e.metrics.map(a=>eo(a));else if(e.metrics!=null){s={};for(let a in e.metrics)s[a]=eo(e.metrics[a])}this.compile({loss:r,metrics:s,optimizer:n})}async save(e,t){if(typeof e=="string"){let u=Kt.getSaveHandlers(e);if(u.length===0)throw new V(`Cannot find any save handlers for URL '${e}'`);if(u.length>1)throw new V(`Found more than one (${u.length}) save handlers for URL '${e}'`);e=u[0]}if(e.save==null)throw new V("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");let n=await Kt.encodeWeights(this.getNamedWeights(t)),r=!1,s=null,o={modelTopology:this.toJSON(s,r),format:OH,generatedBy:`TensorFlow.js tfjs-layers v${II}`,convertedBy:null};if((t==null?!1:t.includeOptimizer)&&this.optimizer!=null){o.trainingConfig=this.getTrainingConfig();let u="optimizer",{data:c,specs:l}=await Kt.encodeWeights(await this.optimizer.getWeights(),u);n.specs.push(...l),n.data=Kt.concatenateArrayBuffers([n.data,c])}return this.userDefinedMetadata!=null&&(VS(this.userDefinedMetadata,this.name,!0),o.userDefinedMetadata=this.userDefinedMetadata),o.weightData=n.data,o.weightSpecs=n.specs,e.save(o)}setUserDefinedMetadata(e){VS(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}};Fs.className="Model";re.registerClass(Fs);var e_=class extends Fs{};e_.className="Functional";re.registerClass(e_);async function MH(e,t){"modelTopology"in e||(e={modelTopology:e}),e=e;let n=e.modelTopology;n.model_config!=null&&(n=n.model_config);let r=Ed(n),s=Hr(r,t);if(e.weightsManifest!=null){let a=await Kt.loadWeights(e.weightsManifest,e.pathPrefix,s.weights.map(i=>i.originalName)),o={};for(let i of s.weights)o[i.originalName]=a[i.originalName];s.loadWeights(o),_e(a)}return s}async function LH(e,t){if(t==null&&(t={}),typeof e=="string"){let n=Kt.getLoadHandlers(e,t);if(n.length===0)n.push(Kt.browserHTTPRequest(e,t));else if(n.length>1)throw new V(`Found more than one (${n.length}) load handlers for URL '${e}'`);e=n[0]}return zH(e,void 0,t)}async function zH(e,t,n){if(n==null&&(n={}),e.load==null)throw new V("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let r=await e.load(),s=r.modelTopology;s.model_config!=null&&(s=s.model_config);let a=n.strict==null?!0:n.strict,o=r.weightData!=null&&r.weightSpecs!=null&&a,i=Hr(Ed(s),t,o),u=r.trainingConfig;if(u!=null&&i.loadTrainingConfig(u),r.userDefinedMetadata!=null&&i.setUserDefinedMetadata(r.userDefinedMetadata),r.weightData!=null){if(r.weightSpecs==null)throw new V("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");let{modelWeights:c,optimizerWeights:l}=BH(r.weightData,r.weightSpecs);i.loadWeights(c,a),i.optimizer!=null&&l.length>0&&await i.optimizer.setWeights(l),_e(c),_e(l.map(p=>p.tensor))}return i}function BH(e,t){let n=Kt.decodeWeights(e,t),r={},s=[];return t.forEach(a=>{a.group==="optimizer"?s.push({name:a.name,tensor:n[a.name]}):r[a.name]=n[a.name]}),{modelWeights:r,optimizerWeights:s}}var nc=class extends Fs{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=e.name!=null?e.name:Rm("sequential_"),e.layers!=null)for(let t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(n=>n<0))throw new V(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){let t=e instanceof nc||e instanceof Fs,n;if(t){if(n=e,n.outputs.length!==1)throw new V("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(n.inputs.length!==1)throw new V("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(e.inboundNodes.length===0){if(e.batchInputShape==null)throw new V("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");let r=RN({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(r)}if(t)this.outputs=n.outputs,this.inputs=n.inputs;else{if(e.inboundNodes.length!==1)throw new V(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(e.inboundNodes[0].outputTensors.length!==1)throw new V("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=FN(this.outputs[0])}this.inboundNodes=[],new Um({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:wo(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(r=>r.shape),outputShapes:this.outputs[0].shape})}else{let r=e.apply(this.outputs[0]);if(Array.isArray(r))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[r],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{let e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return this.model==null&&this.build(),this.model.call(e,t)}build(e){if(Qe(e),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Fs({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t,n=console.log){this.built||this.build(),super.summary(e,t,n)}setWeights(e){this.model==null&&this.build(),this.model.setWeights(e)}evaluate(e,t,n={}){if(!this.built)throw new Vr("The model needs to be compiled before being used.");return this.model.evaluate(e,t,n)}async evaluateDataset(e,t){if(!this.built)throw new Vr("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e,t={}){return this.model==null&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return this.model==null&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t,n={}){if(!this.built)throw new Vr("The model needs to be compiled before being used.");return this.model.fit(e,t,n)}async fitDataset(e,t){if(!this.built)throw new Vr("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(e,t,n={},r=!1){let s,a={};if(t instanceof Array){if(t[0].className==null||t[0].className==="Merge")throw new V("Legacy serialization format not supported yet.");s=t}else w.assert(t.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),s=t.layers,delete t.layers,a=t;let o=new e(a);if(!(o instanceof nc))throw new Le(`Sequential.fromConfig called on non-Sequential input: ${o}`);for(let i of s){let c=Hr(i,void 0,r);r&&c.setFastWeightInitDuringBuild(!0),o.add(c)}return o}set stopTraining(e){if(this.model==null)throw new V("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(this.model==null)throw new V("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){let e=[];for(let t of this.layers){let n={};n.className=t.getClassName(),n.config=t.getConfig(),e.push(n)}return{name:this.name,layers:e}}};nc.className="Sequential";re.registerClass(nc);function WH(e){return new Fs(e)}function VH(e){return new nc(e)}function t_(e){return RN(e)}function UH(e,t){Ar.registerCallbackConstructor(e,t)}var Gn=class extends re.Serializable{getConfig(){return{}}},n_=class extends Gn{apply(e,t=1){return hG(e,t)}};n_.className="elu";re.registerClass(n_);var r_=class extends Gn{apply(e){return ym(e)}};r_.className="selu";re.registerClass(r_);var s_=class extends Gn{apply(e){return Ke(e)}};s_.className="relu";re.registerClass(s_);var a_=class extends Gn{apply(e){return O(()=>ga(6,Ke(e)))}};a_.className="relu6";re.registerClass(a_);var o_=class extends Gn{apply(e){return e}};o_.className="linear";re.registerClass(o_);var i_=class extends Gn{apply(e){return hr(e)}};i_.className="sigmoid";re.registerClass(i_);var u_=class extends Gn{apply(e){return mG(e)}};u_.className="hardSigmoid";re.registerClass(u_);var c_=class extends Gn{apply(e){return qi(e)}};c_.className="softplus";re.registerClass(c_);var l_=class extends Gn{apply(e){return fG(e)}};l_.className="softsign";re.registerClass(l_);var d_=class extends Gn{apply(e){return bo(e)}};d_.className="tanh";re.registerClass(d_);var kI=class extends Gn{apply(e,t=-1){return Yr(e,t)}};kI.className="softmax";re.registerClass(kI);var p_=class extends Gn{apply(e,t=-1){return lm(e,t)}};p_.className="logSoftmax";re.registerClass(p_);var h_=class extends Gn{apply(e,t=1){return O(()=>B(hr(B(e,t)),e))}};h_.className="swish";re.registerClass(h_);var f_=class extends Gn{apply(e){return O(()=>B(e,bo(qi(e))))}};f_.className="mish";re.registerClass(f_);function ya(e){return e.getClassName()}function kv(e,t={}){return Cp(e,re.SerializationMap.getMap().classNameMap,t,"activation")}function va(e){if(e==null){let t={};return t.className="linear",t.config={},kv(t)}if(typeof e=="string"){let t={};return t.className=e,t.config={},kv(t)}else return e instanceof Gn?e:kv(e)}function SI(e){if(e!=null&&typeof e!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${e}`)}var m_=class extends re.Serializable{},Ap=class extends m_{constructor(e){super(),SI(e),this.l1=e==null||e.l1==null?.01:e.l1,this.l2=e==null||e.l2==null?.01:e.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(e){return O(()=>{let t=Ct([1]);return this.hasL1&&(t=X(t,ge(B(this.l1,Bt(e))))),this.hasL2&&(t=X(t,ge(B(this.l2,Np(e))))),W(t,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}};Ap.className="L1L2";re.registerClass(Ap);function GH(e){return SI(e),new Ap({l1:e!=null?e.l1:null,l2:0})}function HH(e){return SI(e),new Ap({l2:e!=null?e.l2:null,l1:0})}var KS={l1l2:"L1L2"};function ft(e){return nI(e)}function XS(e,t={}){return Cp(e,re.SerializationMap.getMap().classNameMap,t,"regularizer")}function Nt(e){if(e==null)return null;if(typeof e=="string"){let n={className:e in KS?KS[e]:e,config:{}};return XS(n)}else return e instanceof m_?e:XS(e)}var CI=class extends We{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null&&(this.maxValue=e.maxValue)}call(e,t){e=Ne(e);let n=Ke(e);return this.maxValue!=null&&(n=an(n,0,this.maxValue)),n}computeOutputShape(e){return e}getConfig(){let e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}};CI.className="ReLU";re.registerClass(CI);var TI=class extends We{constructor(e){super(e??{}),this.DEFAULT_ALPHA=.3,e==null&&(e={}),this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){let n=Ne(e);return mp(n,this.alpha)}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};TI.className="LeakyReLU";re.registerClass(TI);var NI=class extends We{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",e==null&&(e={}),this.supportsMasking=!0,this.alphaInitializer=Tt(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=Nt(e.alphaRegularizer),this.alphaConstraint=Jt(e.alphaConstraint),e.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else if(typeof e.sharedAxes=="number")this.sharedAxes=[e.sharedAxes];else throw new V(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`)}build(e){e=Qe(e);let t=e.slice(1);if(this.sharedAxes!=null)for(let r of this.sharedAxes)t[r-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);let n={};if(this.sharedAxes!=null)for(let r=1;r<e.length;++r)n[r]=e[r];this.inputSpec=[new Wt({ndim:e.length,axes:n})],this.built=!0}call(e,t){return e=Ne(e),xp(e,this.alpha.read())}getConfig(){let e={alphaInitializer:At(this.alphaInitializer),alphaRegularizer:ft(this.alphaRegularizer),alphaConstraint:Zt(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}};NI.className="PReLU";re.registerClass(NI);var _I=class extends We{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA=1,e==null&&(e={}),e.alpha!=null&&e.alpha!==this.DEFAULT_ALPHA)throw new Le(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){let n=Ne(e);return pl(n)}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};_I.className="ELU";re.registerClass(_I);var EI=class extends We{constructor(e){super(e??{}),this.DEFAULT_THETA=1,e==null&&(e={}),this.theta=e.theta==null?this.DEFAULT_THETA:e.theta}call(e,t){let n=Ne(e);return B(n,ae(Dn(n,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){let e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}};EI.className="ThresholdedReLU";re.registerClass(EI);var AI=class extends We{constructor(e){super(e??{}),this.DEFAULT_AXIS=1,e==null&&(e={}),this.softmax=new kI().apply,this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis}call(e,t){let n=Ne(e);return this.softmax(n,this.axis)}computeOutputShape(e){return e}getConfig(){let e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}};AI.className="Softmax";re.registerClass(AI);function Wu(e,t,n){if(typeof e=="number")return wo(e,t);if(e.length!==t)throw new V(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${e.length} elements.`);for(let r=0;r<t;++r){let s=e[r];if(!cG(s))throw new V(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(e)} including a non-integer number ${s}`)}return e}function jr(e,t,n,r,s=1){if(e==null)return e;let a=t+(t-1)*(s-1),o;return n==="same"?o=e:o=e-a+1,Math.floor((o+r-1)/r)}function os(e,t,n,r){if(e==null)return null;if(r==="valid")e=e*t+ba([n-t,0]);else if(r==="same")e=e*t;else throw new V(`Unsupport padding mode: ${r}.`);return e}function DI(e,t){return O(()=>(Mt(t),t==="channelsFirst"?Re(e,[0,2,3,1]):e))}function g_(e,t){return O(()=>(Mt(t),t==="channelsFirst"?Re(e,[0,2,3,4,1]):e))}function jH(e,t,n,r=1,s="valid",a,o=1){return O(()=>{if(a==null&&(a=Kr()),Mt(a),e.shape.length!==3)throw new V(`The input of a conv1dWithBias operation should be 3, but is ${e.shape.length} instead.`);if(t.shape.length!==3)throw new V(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(n!=null&&n.shape.length!==1)throw new V(`The bias for a conv1dWithBias operation should be 1, but is ${t.shape.length} instead`);if(a==="channelsFirst"&&(e=Re(e,[0,2,1])),s==="causal")throw new Le("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let i=sm(e,t,r,s==="same"?"same":"valid","NWC",o);return n!=null&&(i=Zr(i,n)),i})}function YS(e,t,n,r=[1,1],s="valid",a,o,i=null){return O(()=>{if(a==null&&(a=Kr()),Mt(a),e.rank!==3&&e.rank!==4)throw new V(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${e.rank}.`);if(t.rank!==3&&t.rank!==4)throw new V(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${e.rank}.`);let u=DI(e,a);if(s==="causal")throw new Le("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return u=Ju.conv2d({x:u,filter:t,strides:r,pad:s==="same"?"same":"valid",dilations:o,dataFormat:"NHWC",bias:n,activation:i}),a==="channelsFirst"&&(u=Re(u,[0,3,1,2])),u})}function qH(e,t,n,r=[1,1,1],s="valid",a,o){return O(()=>{if(a==null&&(a=Kr()),Mt(a),e.rank!==4&&e.rank!==5)throw new V(`conv3dWithBias expects input to be of rank 4 or 5, but received ${e.rank}.`);if(t.rank!==4&&t.rank!==5)throw new V(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${e.rank}.`);let i=g_(e,a);if(s==="causal")throw new Le("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return i=aw(i,t,r,s==="same"?"same":"valid","NDHWC",o),n!=null&&(i=Zr(i,n)),a==="channelsFirst"&&(i=Re(i,[0,4,1,2,3])),i})}var $I=class extends We{constructor(e,t){if(super(t),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",$I.verifyArgs(t),this.rank=e,rn(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new Le(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=Wu(t.kernelSize,e,"kernelSize"),this.strides=Wu(t.strides==null?1:t.strides,e,"strides"),this.padding=t.padding==null?"valid":t.padding,vr(this.padding),this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,Mt(this.dataFormat),this.activation=va(t.activation),this.useBias=t.useBias==null?!0:t.useBias,this.biasInitializer=Tt(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=Jt(t.biasConstraint),this.biasRegularizer=Nt(t.biasRegularizer),this.activityRegularizer=Nt(t.activityRegularizer),this.dilationRate=Wu(t.dilationRate==null?1:t.dilationRate,e,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new V(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new V(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new V(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(e){if(as("kernelSize"in e,"required key 'kernelSize' not in config"),typeof e.kernelSize!="number"&&!rI(e.kernelSize,"number",1,3))throw new V(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){let e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:ya(this.activation),useBias:this.useBias,biasInitializer:At(this.biasInitializer),biasRegularizer:ft(this.biasRegularizer),activityRegularizer:ft(this.activityRegularizer),biasConstraint:Zt(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}},Dp=class extends $I{constructor(e,t){super(e,t),this.kernel=null,Dp.verifyArgs(t),this.filters=t.filters,rn(this.filters,"filters"),this.kernelInitializer=Tt(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=Jt(t.kernelConstraint),this.kernelRegularizer=Nt(t.kernelRegularizer)}build(e){e=Qe(e);let t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new V(`The channel dimension of the input should be defined. Found ${e[t]}`);let n=e[t],r=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:n}}],this.built=!0}call(e,t){return O(()=>{e=Ne(e);let n,r=this.bias==null?null:this.bias.read(),s=SN(this.activation.getClassName());if(s!=null&&this.rank===2)n=YS(e,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate,s);else{if(this.rank===1)n=jH(e,this.kernel.read(),r,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)n=YS(e,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)n=qH(e,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new Le("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(n=this.activation.apply(n))}return n})}computeOutputShape(e){e=Qe(e);let t=[],n=this.dataFormat==="channelsLast"?e.slice(1,e.length-1):e.slice(2);for(let s=0;s<n.length;++s){let a=jr(n[s],this.kernelSize[s],this.padding,this.strides[s],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[s]);t.push(a)}let r=[e[0]];return this.dataFormat==="channelsLast"?(r=r.concat(t),r.push(this.filters)):(r.push(this.filters),r=r.concat(t)),r}getConfig(){let e={filters:this.filters,kernelInitializer:At(this.kernelInitializer),kernelRegularizer:ft(this.kernelRegularizer),kernelConstraint:Zt(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||typeof e.filters!="number"||e.filters<1)throw new V(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}},$p=class extends Dp{constructor(e){super(2,e),$p.verifyArgs(e)}getConfig(){let e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!rI(e.kernelSize,"number",1,2))throw new V(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}};$p.className="Conv2D";re.registerClass($p);var Fp=class extends Dp{constructor(e){super(3,e),Fp.verifyArgs(e)}getConfig(){let e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!(Array.isArray(e.kernelSize)&&(e.kernelSize.length===1||e.kernelSize.length===3)))throw new V(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}};Fp.className="Conv3D";re.registerClass(Fp);var FI=class extends $p{constructor(e){if(super(e),this.inputSpec=[new Wt({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new V(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=Qe(e),e.length!==4)throw new V("Input should have rank 4; Received input shape: "+JSON.stringify(e));let t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new V("The channel dimension of the inputs should be defined. Found `None`.");let n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Wt({ndim:4,axes:{[t]:n}})],this.built=!0}call(e,t){return O(()=>{let n=Ne(e);if(n.shape.length!==4)throw new V(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${n.shape.length}`);let r=n.shape,s=r[0],a,o;this.dataFormat==="channelsFirst"?(a=2,o=3):(a=1,o=2);let i=r[a],u=r[o],c=this.kernelSize[0],l=this.kernelSize[1],p=this.strides[0],d=this.strides[1],h=os(i,p,c,this.padding),f=os(u,d,l,this.padding),g=[s,h,f,this.filters];this.dataFormat!=="channelsLast"&&(n=Re(n,[0,2,3,1]));let m=am(n,this.kernel.read(),g,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(m=Re(m,[0,3,1,2])),this.bias!=null&&(m=Zr(m,this.bias.read(),this.dataFormat)),this.activation!=null&&(m=this.activation.apply(m)),m})}computeOutputShape(e){e=Qe(e);let t=e.slice(),n,r,s;this.dataFormat==="channelsFirst"?(n=1,r=2,s=3):(n=3,r=1,s=2);let a=this.kernelSize[0],o=this.kernelSize[1],i=this.strides[0],u=this.strides[1];return t[n]=this.filters,t[r]=os(t[r],i,a,this.padding),t[s]=os(t[s],u,o,this.padding),t}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}};FI.className="Conv2DTranspose";re.registerClass(FI);var RI=class extends Fp{constructor(e){if(super(e),this.inputSpec=[new Wt({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new V(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=Qe(e),e.length!==5)throw new V("Input should have rank 5; Received input shape: "+JSON.stringify(e));let t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new V("The channel dimension of the inputs should be defined. Found `None`.");let n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Wt({ndim:5,axes:{[t]:n}})],this.built=!0}call(e,t){return O(()=>{let n=Ne(e);if(n.shape.length!==5)throw new V(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${n.shape.length}`);let r=n.shape,s=r[0],a,o,i;this.dataFormat==="channelsFirst"?(i=2,a=3,o=4):(i=1,a=2,o=3);let u=r[i],c=r[a],l=r[o],p=this.kernelSize[0],d=this.kernelSize[1],h=this.kernelSize[2],f=this.strides[0],g=this.strides[1],m=this.strides[2],b=os(u,f,p,this.padding),v=os(c,g,d,this.padding),y=os(l,m,h,this.padding),x=[s,b,v,y,this.filters];this.dataFormat!=="channelsLast"&&(n=Re(n,[0,2,3,4,1]));let k=ow(n,this.kernel.read(),x,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(k=Re(k,[0,4,1,2,3])),this.bias!==null&&(k=Zr(k,this.bias.read(),this.dataFormat)),this.activation!==null&&(k=this.activation.apply(k)),k})}computeOutputShape(e){e=Qe(e);let t=e.slice(),n,r,s,a;this.dataFormat==="channelsFirst"?(n=1,r=2,s=3,a=4):(n=4,r=1,s=2,a=3);let o=this.kernelSize[0],i=this.kernelSize[1],u=this.kernelSize[2],c=this.strides[0],l=this.strides[1],p=this.strides[2];return t[n]=this.filters,t[r]=os(t[r],c,o,this.padding),t[s]=os(t[s],l,i,this.padding),t[a]=os(t[a],p,u,this.padding),t}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}};RI.className="Conv3DTranspose";re.registerClass(RI);var b_=class extends Dp{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,t.filters==null)throw new V("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(t.kernelInitializer!=null||t.kernelRegularizer!=null||t.kernelConstraint!=null)throw new V("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(t.padding!=null&&t.padding!=="same"&&t.padding!=="valid")throw new V(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=Tt(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=Nt(t.depthwiseRegularizer),this.depthwiseConstraint=Jt(t.depthwiseConstraint),this.pointwiseInitializer=Tt(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=Nt(t.pointwiseRegularizer),this.pointwiseConstraint=Jt(t.pointwiseConstraint)}build(e){if(e=Qe(e),e.length<this.rank+2)throw new V(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);let t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null||e[t]<0)throw new V(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);let n=e[t],r=this.kernelSize.concat([n,this.depthMultiplier]),s=[];for(let o=0;o<this.rank;++o)s.push(1);s.push(n*this.depthMultiplier,this.filters);let a=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,a,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",s,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,a,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,a,this.biasConstraint):this.bias=null,this.inputSpec=[new Wt({ndim:this.rank+2,axes:{[t]:n}})],this.built=!0}call(e,t){return O(()=>{e=Ne(e);let n;if(this.rank===1)throw new Le("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(e=Re(e,[0,2,3,1])),n=Fa(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(n=Zr(n,this.bias.read(),this.dataFormat)),this.activation!=null&&(n=this.activation.apply(n)),this.dataFormat==="channelsFirst"&&(n=Re(n,[0,3,1,2])),n})}getConfig(){let e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=At(this.depthwiseInitializer),e.pointwiseInitializer=At(this.pointwiseInitializer),e.depthwiseRegularizer=ft(this.depthwiseRegularizer),e.pointwiseRegularizer=ft(this.pointwiseRegularizer),e.depthwiseConstraint=Zt(this.depthwiseConstraint),e.pointwiseConstraint=Zt(this.pointwiseConstraint),e}};b_.className="SeparableConv";var PI=class extends b_{constructor(e){super(2,e)}};PI.className="SeparableConv2D";re.registerClass(PI);var jm=class extends Dp{constructor(e){super(1,e),jm.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){let e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!rI(e.kernelSize,"number",1,1))throw new V(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}};jm.className="Conv1D";re.registerClass(jm);var OI=class extends We{constructor(e){super(e),typeof e.cropping=="number"?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:typeof e.cropping[0]=="number"?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=e.dataFormat===void 0?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return this.dataFormat==="channelsFirst"?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return O(()=>{if(e=Ne(e),this.dataFormat==="channelsLast"){let n=Bh(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return Bh(n,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{let n=Bh(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return Bh(n,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){let e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}};OI.className="Cropping2D";re.registerClass(OI);var MI=class extends We{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=e.size==null?this.DEFAULT_SIZE:e.size,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Mt(this.dataFormat),this.interpolation=e.interpolation==null?"nearest":e.interpolation,oG(this.interpolation)}computeOutputShape(e){if(this.dataFormat==="channelsFirst"){let t=e[2]==null?null:this.size[0]*e[2],n=e[3]==null?null:this.size[1]*e[3];return[e[0],e[1],t,n]}else{let t=e[1]==null?null:this.size[0]*e[1],n=e[2]==null?null:this.size[1]*e[2];return[e[0],t,n,e[3]]}}call(e,t){return O(()=>{let n=Ne(e),r=n.shape;if(this.dataFormat==="channelsFirst"){n=Re(n,[0,2,3,1]);let s=this.size[0]*r[2],a=this.size[1]*r[3],o=this.interpolation==="nearest"?tr.resizeNearestNeighbor(n,[s,a]):tr.resizeBilinear(n,[s,a]);return Re(o,[0,3,1,2])}else{let s=this.size[0]*r[1],a=this.size[1]*r[2];return this.interpolation==="nearest"?tr.resizeNearestNeighbor(n,[s,a]):tr.resizeBilinear(n,[s,a])}})}getConfig(){let e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}};MI.className="UpSampling2D";re.registerClass(MI);function KH(e,t,n=[1,1],r="valid",s,a){return O(()=>{s==null&&(s=Kr()),Mt(s);let o=DI(e,s);if(e.rank!==4)throw new V(`Input for depthwiseConv2d is required to be 4-D, but is instead ${e.rank}-D`);if(t.rank!==4)throw new V(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return o=Aa(o,t,n,r==="same"?"same":"valid","NHWC",a),s==="channelsFirst"&&(o=Re(o,[0,3,1,2])),o})}var LI=class extends $I{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=Tt(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=Jt(e.depthwiseConstraint),this.depthwiseRegularizer=Nt(e.depthwiseRegularizer)}build(e){if(e=Qe(e),e.length<4)throw new V(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);let t=this.dataFormat==="channelsFirst"?1:3;if(e[t]==null||e[t]<0)throw new V(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);let n=e[t],r=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return O(()=>{e=Ne(e);let n=KH(e,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(n=Zr(n,this.bias.read(),this.dataFormat)),this.activation!=null&&(n=this.activation.apply(n)),n})}computeOutputShape(e){e=Qe(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],n=this.dataFormat==="channelsFirst"?e[3]:e[2],r=this.dataFormat==="channelsFirst"?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,s=jr(t,this.kernelSize[0],this.padding,this.strides[0]),a=jr(n,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[e[0],r,s,a]:[e[0],s,a,r]}getConfig(){let e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=At(this.depthwiseInitializer),e.depthwiseRegularizer=ft(this.depthwiseRegularizer),e.depthwiseConstraint=Zt(this.depthwiseRegularizer),e}};LI.className="DepthwiseConv2D";re.registerClass(LI);function y_(e,t,n,r){if(Array.isArray(e)){if(t!=null||n!=null)throw new V("When inputs is an array, neither initialState or constants should be provided");r!=null&&(n=e.slice(e.length-r,e.length),e=e.slice(0,e.length-r)),e.length>1&&(t=e.slice(1,e.length)),e=e[0]}function s(a){return a==null||Array.isArray(a)?a:[a]}return t=s(t),n=s(n),{inputs:e,initialState:t,constants:n}}function v_(e,t,n,r=!1,s,a,o=!1,i=!1){return O(()=>{let u=t.shape.length;if(u<3)throw new V(`Input should be at least 3D, but is ${u}D.`);let c=[1,0].concat(qr(2,u));if(t=Re(t,c),a!=null)throw new Le("The rnn() functoin of the deeplearn.js backend does not support constants yet.");o&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),s!=null&&(s=ae(ae(s,"bool"),"float32"),s.rank===u-1&&(s=jt(s,-1)),s=Re(s,c)),r&&(t=gr(t,0),s!=null&&(s=gr(s,0)));let l=[],p,d=n,h=t.shape[0],f=dt(t),g;s!=null&&(g=dt(s));for(let b=0;b<h;++b){let v=f[b],y=O(()=>e(v,d));if(s==null)p=y[0],d=y[1];else{let x=O(()=>{let k=g[b],S=de(sr(k),k),N=X(B(y[0],k),B(d[0],S)),E=d.map(($,R)=>X(B(y[1][R],k),B($,S)));return{output:N,newStates:E}});p=x.output,d=x.newStates}i&&l.push(p)}let m;return i&&(m=Rt(l,1)),[p,m,d]})}var ys=class extends We{constructor(e){super(e);let t;if(e.cell==null)throw new V("cell property is missing for the constructor of RNN.");if(Array.isArray(e.cell)?t=new Xm({cells:e.cell}):t=e.cell,t.stateSize==null)throw new V("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=e.returnSequences==null?!1:e.returnSequences,this.returnState=e.returnState==null?!1:e.returnState,this.goBackwards=e.goBackwards==null?!1:e.goBackwards,this._stateful=e.stateful==null?!1:e.stateful,this.unroll=e.unroll==null?!1:e.unroll,this.supportsMasking=!0,this.inputSpec=[new Wt({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){let e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return qr(0,e).map(t=>null)}else return this.states_}setStates(e){this.states_=e}computeOutputShape(e){qv(e)&&(e=e[0]),e=e;let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);let n=t[0],r;if(this.returnSequences?r=[e[0],e[1],n]:r=[e[0],n],this.returnState){let s=[];for(let a of t)s.push([e[0],a]);return[r].concat(s)}else return r}computeMask(e,t){return O(()=>{Array.isArray(t)&&(t=t[0]);let n=this.returnSequences?t:null;if(this.returnState){let r=this.states.map(s=>null);return[n].concat(r)}else return n})}get states(){if(this.states_==null){let e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let n=0;n<e;++n)t.push(null);return t}else return this.states_}set states(e){this.states_=e}build(e){if(this.numConstants!=null)throw new Le("Constants support is not implemented in RNN yet.");qv(e)&&(e=e[0]),e=e;let n=this.stateful?e[0]:null,r=e.slice(2);this.inputSpec[0]=new Wt({shape:[n,null,...r]});let s=[e[0]].concat(e.slice(2));this.cell.build(s);let a;if(Array.isArray(this.cell.stateSize)?a=this.cell.stateSize:a=[this.cell.stateSize],this.stateSpec!=null){if(!w.arraysEqual(this.stateSpec.map(o=>o.shape[o.shape.length-1]),a))throw new V(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=a.map(o=>new Wt({shape:[null,o]}));this.stateful&&this.resetStates()}resetStates(e,t=!1){O(()=>{if(!this.stateful)throw new Ns("Cannot call resetStates() on an RNN Layer that is not stateful.");let n=this.inputSpec[0].shape[0];if(n==null)throw new V("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(r=>Ct([n,r])):this.states_=[Ct([n,this.cell.stateSize])];else if(e==null)_e(this.states_),this.keptStates!=null&&(_e(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(r=>Ct([n,r])):this.states_[0]=Ct([n,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new V(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t===!0?this.keptStates.push(this.states_.slice()):_e(this.states_);for(let r=0;r<this.states_.length;++r){let s=e[r],a=Array.isArray(this.cell.stateSize)?this.cell.stateSize[r]:this.cell.stateSize,o=[n,a];if(!w.arraysEqual(s.shape,o))throw new V(`State ${r} is incompatible with layer ${this.name}: expected shape=${o}, received shape=${s.shape}`);this.states_[r]=s}}this.states_=this.states_.map(r=>qt(r.clone()))})}apply(e,t){let n=t==null?null:t.initialState,r=t==null?null:t.constants;t==null&&(t={});let s=y_(e,n,r,this.numConstants);e=s.inputs,n=s.initialState,r=s.constants;let a=[],o=[];if(n!=null){t.initialState=n,a=a.concat(n),this.stateSpec=[];for(let u of n)this.stateSpec.push(new Wt({shape:u.shape}));o=o.concat(this.stateSpec)}if(r!=null&&(t.constants=r,a=a.concat(r),this.numConstants=r.length),a[0]instanceof Ur){let u=[e].concat(a),c=this.inputSpec.concat(o),l=this.inputSpec;this.inputSpec=c;let p=super.apply(u,t);return this.inputSpec=l,p}else return super.apply(e,t)}call(e,t){return O(()=>{let n=t==null?null:t.mask,r=t==null?null:t.training,s=t==null?null:t.initialState;e=Ne(e),s==null&&(this.stateful?s=this.states_:s=this.getInitialState(e));let a=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(s.length!==a)throw new V(`RNN Layer has ${a} state(s) but was passed ${s.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");let o={training:r},u=v_((h,f)=>{let g=this.cell.call([h].concat(f),o);return[g[0],g.slice(1)]},e,s,this.goBackwards,n,null,this.unroll,this.returnSequences),c=u[0],l=u[1],p=u[2];this.stateful&&this.resetStates(p,r);let d=this.returnSequences?l:c;return this.returnState?[d].concat(p):d})}getInitialState(e){return O(()=>{let t=Ct(e.shape);return t=ge(t,[1,2]),t=Tp(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(n=>n>1?Hv(t,[1,n]):t):this.cell.stateSize>1?[Hv(t,[1,this.cell.stateSize])]:[t]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){let e=super.getConfig(),t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(t.numConstants=this.numConstants);let n=this.cell.getConfig();return this.getClassName()===ys.className&&(t.cell={className:this.cell.getClassName(),config:n}),Object.assign(Object.assign(Object.assign({},n),e),t)}static fromConfig(e,t,n={}){let r=t.cell,s=Hr(r,n);return new e(Object.assign(t,{cell:s}))}};ys.className="RNN";re.registerClass(ys);var Rp=class extends We{},qm=class extends Rp{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,rn(this.units,"units"),this.activation=va(e.activation==null?this.DEFAULT_ACTIVATION:e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=Tt(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Tt(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Tt(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Nt(e.kernelRegularizer),this.recurrentRegularizer=Nt(e.recurrentRegularizer),this.biasRegularizer=Nt(e.biasRegularizer),this.kernelConstraint=Jt(e.kernelConstraint),this.recurrentConstraint=Jt(e.recurrentConstraint),this.biasConstraint=Jt(e.biasConstraint),this.dropout=ec([1,ba([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=ec([1,ba([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Qe(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return O(()=>{if(e=e,e.length!==2)throw new V(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let n=e[1];e=e[0];let r=t.training==null?!1:t.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=xa({ones:()=>sr(e),rate:this.dropout,training:r,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=xa({ones:()=>sr(n),rate:this.recurrentDropout,training:r,dropoutFunc:this.dropoutFunc}));let s,a=this.dropoutMask,o=this.recurrentDropoutMask;a!=null?s=ls(B(e,a),this.kernel.read()):s=ls(e,this.kernel.read()),this.bias!=null&&(s=Zr(s,this.bias.read())),o!=null&&(n=B(n,o));let i=X(s,ls(n,this.recurrentKernel.read()));return this.activation!=null&&(i=this.activation.apply(i)),[i,i]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:ya(this.activation),useBias:this.useBias,kernelInitializer:At(this.kernelInitializer),recurrentInitializer:At(this.recurrentInitializer),biasInitializer:At(this.biasInitializer),kernelRegularizer:ft(this.kernelRegularizer),recurrentRegularizer:ft(this.recurrentRegularizer),biasRegularizer:ft(this.biasRegularizer),activityRegularizer:ft(this.activityRegularizer),kernelConstraint:Zt(this.kernelConstraint),recurrentConstraint:Zt(this.recurrentConstraint),biasConstraint:Zt(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),t)}};qm.className="SimpleRNNCell";re.registerClass(qm);var zI=class extends ys{constructor(e){e.cell=new qm(e),super(e)}call(e,t){return O(()=>{this.cell.dropoutMask!=null&&(_e(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(_e(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=t==null?null:t.mask,r=t==null?null:t.training,s=t==null?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:s})})}static fromConfig(e,t){return new e(t)}};zI.className="SimpleRNN";re.registerClass(zI);var Km=class extends Rp{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new V("GRUCell does not support reset_after parameter set to true.");this.units=e.units,rn(this.units,"units"),this.activation=va(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=va(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=Tt(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Tt(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Tt(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Nt(e.kernelRegularizer),this.recurrentRegularizer=Nt(e.recurrentRegularizer),this.biasRegularizer=Nt(e.biasRegularizer),this.kernelConstraint=Jt(e.kernelConstraint),this.recurrentConstraint=Jt(e.recurrentConstraint),this.biasConstraint=Jt(e.biasConstraint),this.dropout=ec([1,ba([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=ec([1,ba([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Qe(e);let t=e[e.length-1];this.kernel=this.addWeight("kernel",[t,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return O(()=>{if(e=e,e.length!==2)throw new V(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);let n=t.training==null?!1:t.training,r=e[1];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=xa({ones:()=>sr(e),rate:this.dropout,training:n,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=xa({ones:()=>sr(r),rate:this.recurrentDropout,training:n,count:3,dropoutFunc:this.dropoutFunc}));let s=this.dropoutMask,a=this.recurrentDropoutMask,o,i,u;0<this.dropout&&this.dropout<1&&(e=B(e,s[0]));let c=ls(e,this.kernel.read());this.useBias&&(c=Zr(c,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=B(r,a[0]));let l=this.recurrentKernel.read(),[p,d]=zn(l,[2*this.units,this.units],l.rank-1),h=ls(r,p),[f,g,m]=zn(c,3,c.rank-1),[b,v]=zn(h,2,h.rank-1);o=this.recurrentActivation.apply(X(f,b)),i=this.recurrentActivation.apply(X(g,v));let y=ls(B(i,r),d);u=this.activation.apply(X(m,y));let x=X(B(o,r),B(X(1,bt(o)),u));return[x,x]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:ya(this.activation),recurrentActivation:ya(this.recurrentActivation),useBias:this.useBias,kernelInitializer:At(this.kernelInitializer),recurrentInitializer:At(this.recurrentInitializer),biasInitializer:At(this.biasInitializer),kernelRegularizer:ft(this.kernelRegularizer),recurrentRegularizer:ft(this.recurrentRegularizer),biasRegularizer:ft(this.biasRegularizer),activityRegularizer:ft(this.activityRegularizer),kernelConstraint:Zt(this.kernelConstraint),recurrentConstraint:Zt(this.recurrentConstraint),biasConstraint:Zt(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),t)}};Km.className="GRUCell";re.registerClass(Km);var BI=class extends ys{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new Km(e),super(e)}call(e,t){return O(()=>{this.cell.dropoutMask!=null&&(_e(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(_e(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=t==null?null:t.mask,r=t==null?null:t.training,s=t==null?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:s})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}};BI.className="GRU";re.registerClass(BI);var Pp=class extends Rp{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,rn(this.units,"units"),this.activation=va(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=va(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=Tt(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Tt(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Tt(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=Nt(e.kernelRegularizer),this.recurrentRegularizer=Nt(e.recurrentRegularizer),this.biasRegularizer=Nt(e.biasRegularizer),this.kernelConstraint=Jt(e.kernelConstraint),this.recurrentConstraint=Jt(e.recurrentConstraint),this.biasConstraint=Jt(e.biasConstraint),this.dropout=ec([1,ba([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=ec([1,ba([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;e=Qe(e);let n=e[e.length-1];this.kernel=this.addWeight("kernel",[n,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let r;if(this.useBias){if(this.unitForgetBias){let s=this.biasInitializer,a=this.units;r=new(t=class extends Mr{apply(i,u){let c=s.apply([a]),l=new Om().apply([a]),p=s.apply([a*2]);return FS(FS(c,l),p)}},t.className="CustomInit",t)}else r=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,r,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return O(()=>{let n=t.training==null?!1:t.training;if(e=e,e.length!==3)throw new V(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let r=e[1],s=e[2];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=xa({ones:()=>sr(e),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=xa({ones:()=>sr(r),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));let a=this.dropoutMask,o=this.recurrentDropoutMask,i,u,c,l;0<this.dropout&&this.dropout<1&&(e=B(e,a[0]));let p=ls(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=B(r,o[0])),p=X(p,ls(r,this.recurrentKernel.read())),this.useBias&&(p=Zr(p,this.bias.read()));let[d,h,f,g]=zn(p,4,p.rank-1);i=this.recurrentActivation.apply(d),u=this.recurrentActivation.apply(h),c=X(B(u,s),B(i,this.activation.apply(f))),l=this.recurrentActivation.apply(g);let m=B(l,this.activation.apply(c));return[m,m,c]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:ya(this.activation),recurrentActivation:ya(this.recurrentActivation),useBias:this.useBias,kernelInitializer:At(this.kernelInitializer),recurrentInitializer:At(this.recurrentInitializer),biasInitializer:At(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:ft(this.kernelRegularizer),recurrentRegularizer:ft(this.recurrentRegularizer),biasRegularizer:ft(this.biasRegularizer),activityRegularizer:ft(this.activityRegularizer),kernelConstraint:Zt(this.kernelConstraint),recurrentConstraint:Zt(this.recurrentConstraint),biasConstraint:Zt(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),t)}};Pp.className="LSTMCell";re.registerClass(Pp);var WI=class extends ys{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new Pp(e),super(e)}call(e,t){return O(()=>{this.cell.dropoutMask!=null&&(_e(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(_e(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=t==null?null:t.mask,r=t==null?null:t.training,s=t==null?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:s})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}};WI.className="LSTM";re.registerClass(WI);var Xm=class extends Rp{constructor(e){super(e),this.cells=e.cells}get stateSize(){let e=[];for(let t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return O(()=>{e=e;let n=e.slice(1),r=[];for(let o of this.cells.slice().reverse())Array.isArray(o.stateSize)?r.push(n.splice(0,o.stateSize.length)):r.push(n.splice(0,1));r.reverse();let s=[],a;for(let o=0;o<this.cells.length;++o){let i=this.cells[o];n=r[o],o===0?a=[e[0]].concat(n):a=[a[0]].concat(n),a=i.call(a,t),s.push(a.slice(1))}n=[];for(let o of s.slice().reverse())n.push(...o);return[a[0]].concat(n)})}build(e){qv(e)&&(e=e[0]),e=e;let t;this.cells.forEach((n,r)=>{io(`RNNCell_${r}`,()=>{n.build(e),Array.isArray(n.stateSize)?t=n.stateSize[0]:t=n.stateSize,e=[e[0],t]})}),this.built=!0}getConfig(){let e=super.getConfig(),t=s=>({className:s.getClassName(),config:s.getConfig()}),r={cells:this.cells.map(t)};return Object.assign(Object.assign({},e),r)}static fromConfig(e,t,n={}){let r=[];for(let s of t.cells)r.push(Hr(s,n));return new e({cells:r})}get trainableWeights(){if(!this.trainable)return[];let e=[];for(let t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){let e=[];for(let t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){let t=[];for(let n of this.cells)t.push(...n.trainableWeights);return t.concat(e)}return e}getWeights(){let e=[];for(let t of this.cells)e.push(...t.weights);return Kv(e)}setWeights(e){let t=[];for(let n of this.cells){let r=n.weights.length,s=e.splice(r);for(let a=0;a<n.weights.length;++a)t.push([n.weights[a],s[a]])}pI(t)}};Xm.className="StackedRNNCells";re.registerClass(Xm);function xa(e){let{ones:t,rate:n,training:r=!1,count:s=1,dropoutFunc:a}=e,o=()=>a!=null?a(t(),n):DN(t(),n),i=()=>_p(o,t,r);return!s||s<=1?qt(i().clone()):Array(s).fill(void 0).map(i).map(c=>qt(c.clone()))}var XH=function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(e!=null&&typeof Object.getOwnPropertySymbols=="function")for(var s=0,r=Object.getOwnPropertySymbols(e);s<r.length;s++)t.indexOf(r[s])<0&&Object.prototype.propertyIsEnumerable.call(e,r[s])&&(n[r[s]]=e[r[s]]);return n},x_=class extends ys{constructor(e){if(e.unroll)throw new Le("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new Le("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new Wt({ndim:5})]}call(e,t){return O(()=>{if(this.cell.dropoutMask!=null&&(_e(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(_e(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new V("ConvRNN2D cell does not support constants");let n=t==null?null:t.mask,r=t==null?null:t.training,s=t==null?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:s})})}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return O(()=>{let{stateSize:t}=this.cell,n=e.shape,r=this.computeSingleOutputShape(n),s=[r[0],...r.slice(2)],a=Ct(s);return Array.isArray(t)?Array(t.length).fill(a):[a]})}resetStates(e,t=!1){O(()=>{if(!this.stateful)throw new Ns("Cannot call resetStates() on an RNN Layer that is not stateful.");let n=this.inputSpec[0].shape,r=this.computeSingleOutputShape(n),s=[r[0],...r.slice(2)];if(n[0]==null)throw new V("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>Ct(s)):this.states_=[Ct(s)];else if(e==null)_e(this.states_),this.keptStates!=null&&(_e(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>Ct(s)):this.states_[0]=Ct(s);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new V(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):_e(this.states_);for(let o=0;o<this.states_.length;++o){let i=e[o],u=s;if(!w.arraysEqual(i.shape,u))throw new V(`State ${o} is incompatible with layer ${this.name}: expected shape=${u}, received shape=${i.shape}`);this.states_[o]=i}}this.states_=this.states_.map(o=>qt(o.clone()))})}computeSingleOutputShape(e){let{dataFormat:t,filters:n,kernelSize:r,padding:s,strides:a,dilationRate:o}=this.cell,i=t==="channelsFirst",u=e[i?3:2],c=e[i?4:3],l=jr(u,r[0],s,a[0],o[0]),p=jr(c,r[1],s,a[1],o[1]);return[...e.slice(0,2),...i?[n,l,p]:[l,p,n]]}};x_.className="ConvRNN2D";var Ym=class extends Pp{constructor(e){let{filters:t,kernelSize:n,strides:r,padding:s,dataFormat:a,dilationRate:o}=e;super(Object.assign(Object.assign({},e),{units:t})),this.filters=t,rn(this.filters,"filters"),this.kernelSize=Wu(n,2,"kernelSize"),this.kernelSize.forEach(i=>rn(i,"kernelSize")),this.strides=Wu(r||1,2,"strides"),this.strides.forEach(i=>rn(i,"strides")),this.padding=s||"valid",vr(this.padding),this.dataFormat=a||"channelsLast",Mt(this.dataFormat),this.dilationRate=Wu(o||1,2,"dilationRate"),this.dilationRate.forEach(i=>rn(i,"dilationRate"))}build(e){var t;e=Qe(e);let n=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[n]==null)throw new V(`The channel dimension of the input should be defined. Found ${e[n]}`);let r=e[n],s=4,a=this.kernelSize.concat([r,this.filters*s]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);let o=this.kernelSize.concat([this.filters,this.filters*s]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",o,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let i;if(this.unitForgetBias){let u=this.biasInitializer,c=this.filters;i=new(t=class extends Mr{apply(p,d){let h=u.apply([c]),f=er([c]),g=u.apply([c*2]);return sI([h,f,g])}},t.className="CustomInit",t)}else i=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*s],null,i,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return O(()=>{if(e.length!==3)throw new V(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let n=t.training||!1,r=e[0],s=e[1],a=e[2],o=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=xa({ones:()=>sr(r),rate:this.dropout,training:n,count:o,dropoutFunc:this.dropoutFunc}));let i=this.dropoutMask,u=(Z,J,ee)=>!J||!J[ee]?Z:B(J[ee],Z),c=u(r,i,0),l=u(r,i,1),p=u(r,i,2),d=u(r,i,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=xa({ones:()=>sr(s),rate:this.recurrentDropout,training:n,count:o,dropoutFunc:this.dropoutFunc}));let h=this.recurrentDropoutMask,f=u(s,h,0),g=u(s,h,1),m=u(s,h,2),b=u(s,h,3),v=3,[y,x,k,S]=zn(this.kernel.read(),o,v),[N,E,$,R]=this.useBias?zn(this.bias.read(),o):[null,null,null,null];c=this.inputConv(c,y,N,this.padding),l=this.inputConv(l,x,E,this.padding),p=this.inputConv(p,k,$,this.padding),d=this.inputConv(d,S,R,this.padding);let[D,F,C,L]=zn(this.recurrentKernel.read(),o,v);f=this.recurrentConv(f,D),g=this.recurrentConv(g,F),m=this.recurrentConv(m,C),b=this.recurrentConv(b,L);let U=this.recurrentActivation.apply(X(c,f)),H=this.recurrentActivation.apply(X(l,g)),K=X(B(H,a),B(U,this.activation.apply(X(p,m)))),q=B(this.recurrentActivation.apply(X(d,b)),this.activation.apply(K));return[q,q,K]})}getConfig(){let e=super.getConfig(),{units:t}=e,n=XH(e,["units"]),r={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},n),r)}inputConv(e,t,n,r){let s=Pt(e,t,this.strides,r||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return n?Zr(s,n,this.dataFormat):s}recurrentConv(e,t){return Pt(e,t,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}};Ym.className="ConvLSTM2DCell";re.registerClass(Ym);var VI=class extends x_{constructor(e){let t=new Ym(e);super(Object.assign(Object.assign({},e),{cell:t}))}static fromConfig(e,t){return new e(t)}};VI.className="ConvLSTM2D";re.registerClass(VI);var Zm=class extends We{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(this.noiseShape==null)return this.noiseShape;let t=e.shape,n=[];for(let r=0;r<this.noiseShape.length;++r)n.push(this.noiseShape[r]==null?t[r]:this.noiseShape[r]);return n}call(e,t){return O(()=>{this.invokeCallHook(e,t);let n=Ne(e);if(0<this.rate&&this.rate<1){let r=t.training==null?!1:t.training,s=this.getNoiseShape(n);return _p(()=>DN(n,this.rate,s,this.seed),()=>n,r)}return e})}getConfig(){let e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}};Zm.className="Dropout";re.registerClass(Zm);var UI=class extends Zm{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){let t=e.shape;return[t[0],1,t[2]]}};UI.className="SpatialDropout1D";re.registerClass(UI);var GI=class extends We{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.batchInputShape==null&&e.inputShape==null&&e.inputDim!=null){let t=null;e.batchSize!=null&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,rn(this.units,"units"),this.activation=va(e.activation),e.useBias!=null&&(this.useBias=e.useBias),this.kernelInitializer=Tt(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=Tt(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=Jt(e.kernelConstraint),this.biasConstraint=Jt(e.biasConstraint),this.kernelRegularizer=Nt(e.kernelRegularizer),this.biasRegularizer=Nt(e.biasRegularizer),this.activityRegularizer=Nt(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){e=Qe(e);let t=e[e.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){e=Qe(e);let t=e.slice();return t[t.length-1]=this.units,t}call(e,t){return O(()=>{this.invokeCallHook(e,t);let n=Ne(e),r=SN(this.activation.getClassName()),s;return r!=null?s=ls(n,this.kernel.read(),r,this.bias?this.bias.read():null):(s=ls(n,this.kernel.read()),this.bias!=null&&(s=Zr(s,this.bias.read())),this.activation!=null&&(s=this.activation.apply(s))),s})}getConfig(){let e={units:this.units,activation:ya(this.activation),useBias:this.useBias,kernelInitializer:At(this.kernelInitializer),biasInitializer:At(this.biasInitializer),kernelRegularizer:ft(this.kernelRegularizer),biasRegularizer:ft(this.biasRegularizer),activityRegularizer:ft(this.activityRegularizer),kernelConstraint:Zt(this.kernelConstraint),biasConstraint:Zt(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}};GI.className="Dense";re.registerClass(GI);var HI=class extends We{constructor(e){e=e||{},super(e),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=Qe(e);for(let t of e.slice(1))if(t==null)throw new V(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],da(e,1)]}call(e,t){return O(()=>{this.invokeCallHook(e,t);let n=Ne(e);if(this.dataFormat==="channelsFirst"&&n.rank>1){let r=[0];for(let s=2;s<n.rank;++s)r.push(s);r.push(1),n=Re(n,r)}return pG(n)})}getConfig(){let e={};this.dataFormat!=null&&(e.dataFormat=this.dataFormat);let t=super.getConfig();return Object.assign(e,t),e}};HI.className="Flatten";re.registerClass(HI);var jI=class extends We{constructor(e){super(e),this.supportsMasking=!0,this.activation=va(e.activation)}call(e,t){return O(()=>{this.invokeCallHook(e,t);let n=Ne(e);return this.activation.apply(n)})}getConfig(){let e={activation:ya(this.activation)},t=super.getConfig();return Object.assign(e,t),e}};jI.className="Activation";re.registerClass(jI);var qI=class extends We{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return O(()=>(e=Ne(e),lG(e,this.n)))}getConfig(){let e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}};qI.className="RepeatVector";re.registerClass(qI);var KI=class extends We{constructor(e){super(e),this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||e==null}fixUnknownDimension(e,t){let n="Total size of new array must be unchanged.",r=t.slice(),s=1,a=null;for(let i=0;i<r.length;++i){let u=r[i];if(this.isUnknown(u))if(a===null)a=i;else throw new V("Can only specifiy one unknown dimension.");else s*=u}let o=da(e);if(a!==null){if(s===0||o%s!==0)throw new V(n);r[a]=o/s}else if(o!==s)throw new V(n);return r}computeOutputShape(e){let t=!1;for(let n=0;n<e.length;++n)if(this.isUnknown(e[n])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return O(()=>{this.invokeCallHook(e,t);let n=Ne(e),r=n.shape,s=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return W(n,s)})}getConfig(){let e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}};KI.className="Reshape";re.registerClass(KI);var XI=class extends We{constructor(e){if(super(e),e.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);let t=qr(1,e.dims.length+1);if(!w.arraysEqual(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new Wt({ndim:this.dims.length+1})]}computeOutputShape(e){e=Qe(e);let t=e.slice();return this.dims.forEach((n,r)=>{t[r+1]=e[n]}),t}call(e,t){return Re(Ne(e),this.dimsIncludingBatch)}getConfig(){let e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}};XI.className="Permute";re.registerClass(XI);var YI=class extends We{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null?this.maskValue=e.maskValue==null?0:e.maskValue:this.maskValue=0}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){let n=Ne(e),r=-1;return Sd(vo(n,this.maskValue),r)}call(e,t){return O(()=>{this.invokeCallHook(e,t);let n=Ne(e),r=-1,s=!0,a=Sd(vo(n,this.maskValue),r,s);return B(n,ae(a,n.dtype))})}};YI.className="Masking";re.registerClass(YI);var ZI=class extends We{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",e.batchInputShape==null&&e.inputShape==null){let t=null;e.batchSize!=null&&(t=e.batchSize),e.inputLength==null?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(It(e.inputLength))}this.inputDim=e.inputDim,rn(this.inputDim,"inputDim"),this.outputDim=e.outputDim,rn(this.outputDim,"outputDim"),this.embeddingsInitializer=Tt(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=Nt(e.embeddingsRegularizer),this.activityRegularizer=Nt(e.activityRegularizer),this.embeddingsConstraint=Jt(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return O(()=>this.maskZero?(e=Ne(e),vo(e,je(e))):null)}computeOutputShape(e){if(e=Qe(e),this.inputLength==null)return[...e,this.outputDim];let t=It(this.inputLength);if(t.length!==e.length-1)throw new V(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let n=0;for(let r=0;r<t.length;++r){let s=t[r],a=e[r+1];if(s!=null&&a!=null&&s!==a)throw new V(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);s==null&&(t[n]=a),n++}}return[e[0],...t,this.outputDim]}call(e,t){return O(()=>{this.invokeCallHook(e,t);let n=Ne(e);n.dtype!=="int32"&&(n=cs(n,"int32"));let r=AN(this.embeddings.read(),W(n,[n.size]));return W(r,Qe(this.computeOutputShape(n.shape)))})}getConfig(){let e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:At(this.embeddingsInitializer),embeddingsRegularizer:ft(this.embeddingsRegularizer),activityRegularizer:ft(this.activityRegularizer),embeddingsConstraint:Zt(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}};ZI.className="Embedding";re.registerClass(ZI);var Qi=class extends We{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new Le}computeElementwiseOpOutputShape(e,t){if(e==null||t==null)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(t.length===0)return e;let n=e.slice(0,e.length-t.length);for(let r=0;r<t.length;++r){let s=e[e.length-t.length+r],a=t[r];if(s==null||a==null||s<0||a<0)n.push(null);else if(s===1)n.push(a);else if(a===1)n.push(s);else{if(s!==a)throw new V("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));n.push(s)}}return n}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[Qe(e)]),e=e,e.length<2)throw new V(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(let s of e)s!=null&&s[0]!==null&&t.push(s[0]);if(t=la(t),t.length>1)throw new V(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let n=e[0]==null?null:e[0].slice(1);for(let s=1;s<e.length;++s){let a=e[s]==null?null:e[s].slice(1);n=this.computeElementwiseOpOutputShape(n,a)}let r=e.map(s=>s.length);e.indexOf(null)===-1&&la(r).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return O(()=>{if(e=e,this.reshapeRequired){let n=[],r=e.map(s=>s.rank);if(r.indexOf(null)===-1){let s=ba(r);for(let a of e){let o=a.rank;for(let i=0;i<s-o;++i)a=Tp(a,1);n.push(a)}return this.mergeFunction(n)}else{let s=!1;for(let i of e){let u=i.rank;if(u==null){let c=i.shape,l=c[0],p=c.slice(1).concat([l]),d=W(i,[l].concat(da(c.slice(1))));d=Re(d,[1,0]),d=W(d,p),n.push(d),s=!0}else if(u>1){let c=qr(1,u).concat([0]);n.push(Re(i,c)),s=!0}else n.push(i)}let a=this.mergeFunction(n),o=a.rank;if(s){if(o==null){let i=a.shape,u=i.length,c=i[u-1],l=[c].concat(i.slice(0,i.length-1));a=W(Re(W(a,[-1,c]),[1,0]),l)}else if(o>1){let i=[o-1].concat(qr(0,o-1));a=Re(a,i)}}return a}}else return this.mergeFunction(e)})}computeOutputShape(e){e=e;let t;e[0]==null?t=null:t=e[0].slice(1);for(let r=1;r<e.length;++r){let s=e[r]==null?null:e[r].slice(1);t=this.computeElementwiseOpOutputShape(t,s)}let n=[];for(let r of e)r!=null&&r[0]!==null&&n.push(r[0]);return n=la(n),n.length===1?t=n.concat(t):t=[null].concat(t),t}computeMask(e,t){return O(()=>{if(t==null)return null;if(!Array.isArray(t))throw new V("`mask` should be an Array");if(!Array.isArray(e))throw new V("`inputs` should be an Array");if(t.length!==e.length)throw new V(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every(r=>r==null))return null;t=t.map(r=>r==null?r:jt(r,0));let n=t[0];for(let r=1;r<t.length-1;++r)n=Rr(n,t[r]);return n})}},JI=class extends Qi{constructor(e){super(e)}mergeFunction(e){return O(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=X(t,e[n]);return t})}};JI.className="Add";re.registerClass(JI);var QI=class extends Qi{constructor(e){super(e)}mergeFunction(e){return O(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=B(t,e[n]);return t})}};QI.className="Multiply";re.registerClass(QI);var ek=class extends Qi{constructor(e){super(e)}mergeFunction(e){return O(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=X(t,e[n]);return B(1/e.length,t)})}};ek.className="Average";re.registerClass(ek);var tk=class extends Qi{constructor(e){super(e)}mergeFunction(e){return O(()=>{let t=e[0];for(let n=1;n<e.length;++n)t=gs(t,e[n]);return t})}};tk.className="Maximum";re.registerClass(tk);var nk=class extends Qi{constructor(e){super(e)}mergeFunction(e){return O(()=>{let t=e[0];for(let n=1;n<e.length;++n)t=ga(t,e[n]);return t})}};nk.className="Minimum";re.registerClass(nk);var rk=class extends Qi{constructor(e){super(e),this.DEFAULT_AXIS=-1,e==null&&(e={}),this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!(Array.isArray(e)&&Array.isArray(e[0]))||e.length===1)throw new V("A `Concatenate` layer should be called on a list of at least 2 inputs");e=e;let t=!0;for(let r of e)if(r!=null){t=!1;break}if(t)return;let n=[];for(let r=0;r<e.length;++r){let s=e[r].slice();s.splice(this.axis,1);let a=!1;for(let o of n)if(w.arraysEqual(o,s)){a=!0;break}a||n.push(s)}if(n.length>1)throw new V("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return O(()=>sI(e,this.axis))}computeOutputShape(e){if(!(Array.isArray(e)&&Array.isArray(e[0])))throw new V("A `Concatenate` layer should be called on a list of inputs.");let t=e,n=t[0].slice(),r=this.axis<0?n.length+this.axis:this.axis;for(let s of t.slice(1)){if(n[r]==null||s[r]==null){n[r]=null;break}n[r]+=s[r]}return n}computeMask(e,t){if(t==null)return null;if(!Array.isArray(t))throw new V("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new V("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new V(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return O(()=>{let n=!0;if(t.forEach(a=>{if(a!=null){n=!1;return}}),n)return null;let r=[];for(let a=0;a<e.length;++a)t[a]==null?r.push(ae(sr(e[a]),"bool")):t[a].rank<e[a].rank?r.push(jt(t[a],-1)):r.push(t[a]);let s=tt(r,this.axis);return rm(s,-1,!1)})}getConfig(){let e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}};rk.className="Concatenate";re.registerClass(rk);function td(e,t){for(;e<0;)e+=t;return e}function YH(e,t,n){if(e.shape.length>3||t.shape.length>3)throw new Le("batchDot is not implemented for tensors of 4D or higher rank yet");if(w.assert(e.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${e.shape.length}`),w.assert(e.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`),typeof n=="number"&&(n=[n,n]),e.dtype==="complex64"||t.dtype==="complex64")throw new Le("batchDot is not implemented for complex64-type Tensors yet.");let r=e.shape.length,s=t.shape.length;n==null&&(n=[r-1,s-2]);let a=n;return O(()=>{let o;if(r>s){o=r-s;let u=[];for(let c=0;c<o;++c)u.push(1);t=W(t,t.shape.concat(u))}else if(s>r){o=s-r;let u=[];for(let c=0;c<o;++c)u.push(1);e=W(e,e.shape.concat(u))}else o=0;let i;if(e.shape.length===2&&t.shape.length===2)a[0]===a[1]?i=ge(B(e,t),a[0]):i=ge(B(Re(e,[1,0]),t),a[1]);else{let u=a[0]!==e.shape.length-1,c=a[1]===t.shape.length-1;i=Fe(e,t,u,c)}if(o>0){let u;r>s?u=r+s-3:u=r-1;let c=[];for(let l=u;l<u+o;++l)c.push(l);i=Ra(i,c)}return i.shape.length===1&&(i=jt(i,1)),i})}var sk=class extends Qi{constructor(e){super(e),this.axes=e.axes,this.normalize=e.normalize==null?!1:e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){w.assert(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let t=e[0],n=e[1];if(t.length>3||n.length>3)throw new Le("Dot layer does not support tensors of 4D or higher rank yet.");let r=this.interpretAxes(t,n);if(t[r[0]]!==n[r[1]])throw new V(`Dimension incompatibility: ${t[r[0]]} !== ${n[r[1]]}`)}mergeFunction(e){if(e.length!==2)throw new V(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t=e[0],n=e[1],r;return Array.isArray(this.axes)?r=this.axes.map((s,a)=>td(s,e[a].shape.length)):r=[td(this.axes,t.shape.length),td(this.axes,n.shape.length)],this.normalize&&(t=xf(t,r[0]),n=xf(n,r[1])),YH(t,n,r)}interpretAxes(e,t){let n;return Array.isArray(this.axes)?n=this.axes:n=[td(this.axes,e.length),td(this.axes,t.length)],n}computeOutputShape(e){w.assert(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let t=e[0].slice(),n=e[1].slice();if(t.length>3||n.length>3)throw new Le("Dot layer does not support tensors of 4D or higher rank yet.");let r=this.interpretAxes(t,n);t.splice(r[0],1),n.splice(r[1],1),n.splice(0,1);let s=t.concat(n);return s.length===1&&s.push(1),s}computeMask(e,t){return null}getConfig(){let e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}};sk.className="Dot";re.registerClass(sk);var ak=class extends We{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return O(()=>{this.invokeCallHook(e,t);let n=Ne(e);return _p(()=>X(Pm(n.shape,0,this.stddev),n),()=>n,t.training||!1)})}};ak.className="GaussianNoise";re.registerClass(ak);var ok=class extends We{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return O(()=>{this.invokeCallHook(e,t);let n=Ne(e);return this.rate>0&&this.rate<1?_p(()=>{let s=Math.sqrt(this.rate/(1-this.rate));return B(n,Pm(n.shape,1,s))},()=>n,t.training||!1):n})}};ok.className="GaussianDropout";re.registerClass(ok);var ik=class extends We{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||Ne(e).shape}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return O(()=>{if(this.rate<1&&this.rate>0){let n=this._getNoiseShape(e);return _p(()=>{let s=Ne(e),a=1.6732632423543772,o=1.0507009873554805,i=-a*o,u=Ms($a(n),this.rate);u=cs(u,"float32");let c=((1-this.rate)*(1+this.rate*i**2))**-.5,l=-c*i*this.rate,p=X(B(s,u),B(X(u,-1),i));return X(B(p,c),l)},()=>Ne(e),t.training||!1)}return e})}};ik.className="AlphaDropout";re.registerClass(ik);function Ad(e,t,n,r,s,a=.001){let o;if(e.rank===2)o=Xx(e,t,n,r,s,a);else if(e.rank===3)o=Yx(e,t,n,r,s,a);else if(e.rank===4)o=Zx(e,t,n,r,s,a);else throw new Le(`batchNormalization is not implemented for array of rank ${e.rank} yet`);return o}function ZH(e,t,n,r,s=.001){return O(()=>{let a=yp(e,r),o=a.mean,i=a.variance;return[Ad(e,o,i,n,t,s),o,i]})}function JH(e,t,n,r,s=.001){return O(()=>{let a=yp(e,r),o=a.mean,i=a.variance,u=[];for(let f of qr(0,e.rank))r.indexOf(f)!==-1?u.push(1):u.push(e.shape[f]);let c=W(o,u),l=W(i,u),p=t==null?null:W(t,u),d=n==null?null:W(n,u);return[Ad(e,c,l,d,p,s),o,i]})}function QH(e,t,n,r,s=.001){return w.arraysEqual(r.slice().sort(),qr(0,e.rank-1))?ZH(e,t,n,r,s):JH(e,t,n,r,s)}var uk=class extends We{constructor(e){e==null&&(e={}),super(e),this.supportsMasking=!0,this.axis=e.axis==null?-1:e.axis,this.momentum=e.momentum==null?.99:e.momentum,this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=Tt(e.betaInitializer||"zeros"),this.gammaInitializer=Tt(e.gammaInitializer||"ones"),this.movingMeanInitializer=Tt(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=Tt(e.movingVarianceInitializer||"ones"),this.betaConstraint=Jt(e.betaConstraint),this.gammaConstraint=Jt(e.gammaConstraint),this.betaRegularizer=Nt(e.betaRegularizer),this.gammaRegularizer=Nt(e.gammaRegularizer)}build(e){e=Qe(e);let t=this.axis>=0?this.axis:this.axis+e.length,n=e[t];if(n==null)throw new V(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new Wt({ndim:e.length,axes:{[t]:n}})];let r=[n];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return O(()=>{let n=t.training==null?!1:t.training,r=Ne(e),s=r.shape,a=s.length,o=qr(0,a),i=this.axis>=0?this.axis:this.axis+a;o.splice(i,1);let u=wo(1,a);u[i]=s[i];let c=o.slice();c.sort();let l=!w.arraysEqual(c,qr(0,a).slice(0,a-1)),p=()=>{if(l){let b=W(this.movingMean.read(),u),v=W(this.movingVariance.read(),u),y=this.center?W(this.beta.read(),u):null,x=this.scale?W(this.gamma.read(),u):null;return Ad(r,b,v,y,x,this.epsilon)}else return Ad(r,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!n)return p();let[d,h,f]=QH(r,this.gamma.read(),this.beta.read(),o,this.epsilon),g=(b,v,y)=>{O(()=>{let x=1-y,k=b.read(),S=B(de(k,v),x);b.write(de(k,S))})};return(()=>{g(this.movingMean,h,this.momentum),g(this.movingVariance,f,this.momentum)})(),d})}getConfig(){let e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:At(this.betaInitializer),gammaInitializer:At(this.gammaInitializer),movingMeanInitializer:At(this.movingMeanInitializer),movingVarianceInitializer:At(this.movingVarianceInitializer),betaRegularizer:ft(this.betaRegularizer),gammaRegularizer:ft(this.gammaRegularizer),betaConstraint:Zt(this.betaConstraint),gammaConstraint:Zt(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}};uk.className="BatchNormalization";re.registerClass(uk);var ck=class extends We{constructor(e){if(e==null&&(e={}),super(e),this.axis=e.axis==null?-1:e.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(let t of this.axis)if(!Number.isInteger(t))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=Tt(e.betaInitializer||"zeros"),this.gammaInitializer=Tt(e.gammaInitializer||"ones"),this.betaRegularizer=Nt(e.betaRegularizer),this.gammaRegularizer=Nt(e.gammaRegularizer),this.supportsMasking=!0}build(e){e=Qe(e);let t=e.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let s=0;s<this.axis.length;++s)this.axis[s]<0&&(this.axis[s]+=t);for(let s of this.axis)if(s<0||s>=t)throw new Error(`Invalid axis: ${s}`);if(this.axis.length!==la(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);let n=this.axis.map(s=>e[s]),r=!0;this.scale?this.gamma=this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,r):this.gamma=null,this.center?this.beta=this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,r):this.beta=null,this.built=!0}call(e,t){let n=Ne(e),r=n.shape,s=r.length;return O(()=>{let{mean:o,variance:i}=yp(n,this.axis,!0),u=wo(1,s);for(let f of this.axis)u[f]=r[f];let c=f=>f!=null&&f.shape.length!==s?W(f,u):f,l=this.scale?c(this.gamma.read()):null,p=this.center?c(this.beta.read()):null,d=[],h=[];for(let f=0;f<s;++f)this.axis.indexOf(f)!==-1?(d.push(r[f]),h.push(1)):(d.push(1),h.push(r[f]));return o=Ln(o,d),i=Ln(i,d),l!=null&&(l=Ln(l,h)),p!=null&&(p=Ln(p,h)),Ad(n,o,i,p,l,this.epsilon)})}getConfig(){let e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:At(this.betaInitializer),gammaInitializer:At(this.gammaInitializer),betaRegularizer:ft(this.betaRegularizer),gammaRegularizer:ft(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}};ck.className="LayerNormalization";re.registerClass(ck);function e6(e,t,n){return O(()=>{if(e.rank!==4)throw new V(`temporalPadding expects input tensor to be 4-D, but received a ${e.rank}-D tensor.`);if(t==null&&(t=[[1,1],[1,1]]),t.length!==2||t[0].length!==2||t[1].length!==2)throw new V("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(n==null&&(n=Kr()),n!=="channelsLast"&&n!=="channelsFirst")throw new V(`Unknown data format: ${n}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let r;return n==="channelsFirst"?r=[[0,0],[0,0],t[0],t[1]]:r=[[0,0],t[0],t[1],[0,0]],yr(e,r)})}var lk=class extends We{constructor(e){if(e==null&&(e={}),super(e),this.dataFormat=e.dataFormat==null?Kr():e.dataFormat,e.padding==null)this.padding=[[1,1],[1,1]];else if(typeof e.padding=="number")this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,e.padding.length!==2)throw new V(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,n;if(typeof e.padding[0]=="number")t=[e.padding[0],e.padding[0]],n=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,e.padding[0].length!==2)throw new V(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],e.padding[1].length!==2)throw new V(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);n=e.padding[1]}this.padding=[t,n]}this.inputSpec=[new Wt({ndim:4})]}computeOutputShape(e){e=Qe(e);let t,n;return this.dataFormat==="channelsFirst"?(e[2]!=null&&e[2]>=0?t=e[2]+this.padding[0][0]+this.padding[0][1]:t=null,e[3]!=null&&e[3]>=0?n=e[3]+this.padding[1][0]+this.padding[1][1]:n=null,[e[0],e[1],t,n]):(e[1]!=null&&e[1]>=0?t=e[1]+this.padding[0][0]+this.padding[0][1]:t=null,e[2]!=null&&e[2]>=0?n=e[2]+this.padding[1][0]+this.padding[1][1]:n=null,[e[0],t,n,e[3]])}call(e,t){return O(()=>e6(Ne(e),this.padding,this.dataFormat))}getConfig(){let e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}};lk.className="ZeroPadding2D";re.registerClass(lk);function Jm(e,t,n,r,s,a){return O(()=>{Mt(s),TN(a),vr(r),n==null&&(n=[1,1]),r==null&&(r="valid"),s==null&&(s=Kr()),a==null&&(a="max"),e=DI(e,s);let o,i=r==="same"?"same":"valid";return a==="max"?o=Ot(e,t,n,i):o=br(e,t,n,i),s==="channelsFirst"&&(o=Re(o,[0,3,1,2])),o})}function w_(e,t,n,r,s,a){return O(()=>{Mt(s),TN(a),vr(r),n==null&&(n=[1,1,1]),r==null&&(r="valid"),s==null&&(s=Kr()),a==null&&(a="max"),e=g_(e,s);let o,i=r==="same"?"same":"valid";return a==="max"?o=Iw(e,t,n,i):o=Kx(e,t,n,i),s==="channelsFirst"&&(o=Re(o,[0,4,1,2,3])),o})}var I_=class extends We{constructor(e){if(e.poolSize==null&&(e.poolSize=2),super(e),typeof e.poolSize=="number")this.poolSize=[e.poolSize];else if(Array.isArray(e.poolSize)&&e.poolSize.length===1&&typeof e.poolSize[0]=="number")this.poolSize=e.poolSize;else throw new V(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);if(rn(this.poolSize,"poolSize"),e.strides==null)this.strides=this.poolSize;else if(typeof e.strides=="number")this.strides=[e.strides];else if(Array.isArray(e.strides)&&e.strides.length===1&&typeof e.strides[0]=="number")this.strides=e.strides;else throw new V(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);rn(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,vr(this.padding),this.inputSpec=[new Wt({ndim:3})]}computeOutputShape(e){e=Qe(e);let t=jr(e[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return O(()=>{this.invokeCallHook(e,t),e=Tp(Ne(e),2);let n=this.poolingFunction(Ne(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return Ra(n,[2])})}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}},dk=class extends I_{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return Mt(s),vr(r),Jm(e,t,n,r,s,"max")}};dk.className="MaxPooling1D";re.registerClass(dk);var pk=class extends I_{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return Mt(s),vr(r),Jm(e,t,n,r,s,"avg")}};pk.className="AveragePooling1D";re.registerClass(pk);var k_=class extends We{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==2)throw new V(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];rn(this.poolSize,"poolSize"),rn(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Mt(this.dataFormat),vr(this.padding),this.inputSpec=[new Wt({ndim:4})]}computeOutputShape(e){e=Qe(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],n=this.dataFormat==="channelsFirst"?e[3]:e[2];return t=jr(t,this.poolSize[0],this.padding,this.strides[0]),n=jr(n,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,n]:[e[0],t,n,e[3]]}call(e,t){return O(()=>(this.invokeCallHook(e,t),this.poolingFunction(Ne(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},hk=class extends k_{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return Mt(s),vr(r),Jm(e,t,n,r,s,"max")}};hk.className="MaxPooling2D";re.registerClass(hk);var fk=class extends k_{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return Mt(s),vr(r),Jm(e,t,n,r,s,"avg")}};fk.className="AveragePooling2D";re.registerClass(fk);var S_=class extends We{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==3)throw new V(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];rn(this.poolSize,"poolSize"),rn(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Mt(this.dataFormat),vr(this.padding),this.inputSpec=[new Wt({ndim:5})]}computeOutputShape(e){e=Qe(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],n=this.dataFormat==="channelsFirst"?e[3]:e[2],r=this.dataFormat==="channelsFirst"?e[4]:e[3];return t=jr(t,this.poolSize[0],this.padding,this.strides[0]),n=jr(n,this.poolSize[1],this.padding,this.strides[1]),r=jr(r,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,n,r]:[e[0],t,n,r,e[4]]}call(e,t){return O(()=>(this.invokeCallHook(e,t),this.poolingFunction(Ne(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},mk=class extends S_{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return Mt(s),vr(r),w_(e,t,n,r,s,"max")}};mk.className="MaxPooling3D";re.registerClass(mk);var gk=class extends S_{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return Mt(s),vr(r),w_(e,t,n,r,s,"avg")}};gk.className="AveragePooling3D";re.registerClass(gk);var C_=class extends We{constructor(e){super(e),this.inputSpec=[new Wt({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new Le}},bk=class extends C_{constructor(e){super(e||{})}call(e,t){return O(()=>{let n=Ne(e);return Et(n,1)})}};bk.className="GlobalAveragePooling1D";re.registerClass(bk);var yk=class extends C_{constructor(e){super(e||{})}call(e,t){return O(()=>{let n=Ne(e);return fr(n,1)})}};yk.className="GlobalMaxPooling1D";re.registerClass(yk);var T_=class extends We{constructor(e){super(e),this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Mt(this.dataFormat),this.inputSpec=[new Wt({ndim:4})]}computeOutputShape(e){return e=e,this.dataFormat==="channelsLast"?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new Le}getConfig(){let e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},vk=class extends T_{call(e,t){return O(()=>{let n=Ne(e);return this.dataFormat==="channelsLast"?Et(n,[1,2]):Et(n,[2,3])})}};vk.className="GlobalAveragePooling2D";re.registerClass(vk);var xk=class extends T_{call(e,t){return O(()=>{let n=Ne(e);return this.dataFormat==="channelsLast"?fr(n,[1,2]):fr(n,[2,3])})}};xk.className="GlobalMaxPooling2D";re.registerClass(xk);var N_=class extends We{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(e){this.layer!=null&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){let e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t,n={}){let r=t.layer,s=Hr(r,n);delete t.layer;let a={layer:s};return Object.assign(a,t),new e(a)}},wk=class extends N_{constructor(e){super(e),this.supportsMasking=!0}build(e){if(e=Qe(e),e.length<3)throw new V(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];let t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){e=Qe(e);let t=[e[0]].concat(e.slice(2)),n=this.layer.computeOutputShape(t),r=e[1];return[n[0],r].concat(n.slice(1))}call(e,t){return O(()=>(e=Ne(e),v_((a,o)=>[Ne(this.layer.call(a,t)),[]],e,[],!1,null,null,!1,!0)[1]))}};wk.className="TimeDistributed";re.registerClass(wk);function t6(e){Zi(aG,"BidirectionalMergeMode",e)}var n6="concat",Ik=class extends N_{constructor(e){super(e);let t=e.layer.getConfig(),n={};n.className=e.layer.getClassName(),n.config=t,this.forwardLayer=Hr(n),t.goBackwards=t.goBackwards!==!0;let r={};if(r.className=e.layer.getClassName(),r.config=t,this.backwardLayer=Hr(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=e.mergeMode===void 0?n6:e.mergeMode,t6(this.mergeMode),e.weights)throw new Le("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,this.forwardLayer!=null&&(this.forwardLayer.trainable=e),this.backwardLayer!=null&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){let t=e.length,n=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,n)),this.backwardLayer.setWeights(e.slice(n))}computeOutputShape(e){let t=this.forwardLayer.computeOutputShape(e);Array.isArray(t)&&Array.isArray(t[0])||(t=[t]),t=t;let n,r,s;return this.returnState&&(s=t.slice(1)),n=t[0],n=n,this.mergeMode==="concat"?(n[n.length-1]*=2,r=[n]):this.mergeMode==null?r=[n,n.slice()]:r=[n],this.returnState?this.mergeMode==null?r.concat(s).concat(s.slice()):[n].concat(s).concat(s.slice()):Mn(r)}apply(e,t){let n=t==null?null:t.initialState,r=t==null?null:t.constants;t==null&&(t={});let s=y_(e,n,r,this.numConstants);if(e=s.inputs,n=s.initialState,r=s.constants,Array.isArray(e)&&(n=e.slice(1),e=e[0]),(n==null||n.length===0)&&r==null)return super.apply(e,t);let a=[],o=[];if(n!=null){let u=n.length;if(u%2>0)throw new V("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=n,a.push(...n);let c=n.map(l=>new Wt({shape:l.shape}));this.forwardLayer.stateSpec=c.slice(0,u/2),this.backwardLayer.stateSpec=c.slice(u/2),o.push(...c)}if(r!=null)throw new Le("Support for constants in Bidirectional layers is not implemented yet.");let i=a[0]instanceof Ur;for(let u of a)if(u instanceof Ur!==i)throw new V("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(i){let u=[e].concat(a),c=this.inputSpec.concat(o),l=this.inputSpec;this.inputSpec=c;let p=super.apply(u,t);return this.inputSpec=l,p}else return super.apply(e,t)}call(e,t){return O(()=>{let n=t.initialState,r,s;if(n==null)r=this.forwardLayer.call(e,t),s=this.backwardLayer.call(e,t);else{let i=n.slice(0,n.length/2),u=n.slice(n.length/2);r=this.forwardLayer.call(e,Object.assign(t,{initialState:i})),s=this.backwardLayer.call(e,Object.assign(t,{initialState:u}))}let a;this.returnState&&(Array.isArray(r)&&(a=r.slice(1).concat(s.slice(1))),r=r[0],s=s[0]),this.returnSequences&&(s=gr(s,1));let o;return this.mergeMode==="concat"?o=sI([r,s]):this.mergeMode==="sum"?o=X(r,s):this.mergeMode==="ave"?o=B(.5,X(r,s)):this.mergeMode==="mul"?o=B(r,s):this.mergeMode==null&&(o=[r,s]),this.returnState?this.mergeMode==null?o.concat(a):[o].concat(a):o})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){io(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),io(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,t){Array.isArray(t)&&(t=t[0]);let n;if(this.returnSequences?this.mergeMode==null?n=[t,t]:n=t:this.mergeMode==null?n=[null,null]:n=null,this.returnState){let s=this.forwardLayer.states.map(a=>null);return Array.isArray(n)?n.concat(s).concat(s):[n].concat(s).concat(s)}else return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(e),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){let e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){let n=Hr(t.layer);if(delete t.layer,t.numConstants!=null)throw new Le("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");let r=t;return r.layer=n,new e(r)}};Ik.className="Bidirectional";re.registerClass(Ik);var kk=class extends We{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){let e={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return O(()=>(e=Ne(e),e.dtype!=="float32"&&(e=cs(e,"float32")),X(B(e,this.scale),this.offset)))}};kk.className="Rescaling";re.registerClass(kk);var{resizeBilinear:r6,cropAndResize:s6}=tr,Sk=class extends We{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,t,n,r,s,a,o,i){return O(()=>{let u,c=!1,l=t/a,p=n/o,d=(r+t)/a,h=(s+n)/o,f=[l,p,d,h],g=[];e.rank===3?(c=!0,u=Rt([e])):u=e;for(let x=0;x<u.shape[0];x++)g.push(f);let m=yn(g,[g.length,4]),b=xo(0,g.length,1,"int32"),y=s6(u,m,b,[r,s],"nearest");return cs(c?Ne(dt(y)):y,i)})}upsize(e,t,n,r){return O(()=>{let s=r6(e,[t,n]);return cs(s,r)})}call(e,t){return O(()=>{let n=Ne(e),r=n.dtype,s=n.shape,a=s[s.length-3],o=s[s.length-2],i=0;a!==this.height&&(i=Math.floor((a-this.height)/2));let u=0;return o!==this.width&&(u=Math.floor((o-this.width)/2),u===0&&(u=1)),i>=0&&u>=0?this.centerCrop(n,i,u,this.height,this.width,a,o,r):this.upsize(e,this.height,this.width,r)})}getConfig(){let e={height:this.height,width:this.width},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=Qe(e);let t=e.length-3,n=e.length-2;return e[t]=this.height,e[n]=this.width,e}};Sk.className="CenterCrop";re.registerClass(Sk);function a6(e,t,n,r){let s=Ne(e);if(s.dtype!=="int32"&&(s=cs(s,"int32")),t==="int")return s;let a=s.shape;if(s.rank===0&&(s=jt(s,-1)),t==="oneHot"&&s.shape[s.shape.length-1]!==1&&(s=jt(s,-1)),s.rank>2)throw new V(`When outputMode is not int, maximum output rank is 2 Received outputMode ${t} and input shape ${a} which would result in output rank ${s.rank}.`);let o=["multiHot","oneHot"].includes(t),i=s,u;if(typeof r<"u"&&t==="count"?u=mf(i,r,n,o):u=mf(i,[],n,o),t!=="tfIdf")return u;if(r)return B(u,r);throw new V("When outputMode is 'tfIdf', weights must be provided.")}var Ck=class extends We{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){let e={numTokens:this.numTokens,outputMode:this.outputMode},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){return e=Qe(e),e==null?[this.numTokens]:this.outputMode==="oneHot"&&e[e.length-1]!==1?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,t){return O(()=>{e=Ne(e),e.dtype!=="int32"&&(e=cs(e,"int32"));let n;if(typeof t.countWeights<"u"){if(this.outputMode!=="count")throw new V(`countWeights is not used when outputMode !== count.
              Received countWeights=${t.countWeights}`);n=Ne(t.countWeights)}let r=fr(e),s=ju(e),a=Dn(this.numTokens,r).bufferSync().get(0),o=Ms(s,0).bufferSync().get(0);if(!(a&&o))throw new V(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return a6(e,this.outputMode,this.numTokens,n)})}};Ck.className="CategoryEncoding";re.registerClass(Ck);var o6=["bilinear","nearest"],ZS=new Set(o6),Tk=class extends We{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation)if(ZS.has(e.interpolation))this.interpolation=e.interpolation;else throw new V(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);else this.interpolation="bilinear";this.cropToAspectRatio=!!e.cropToAspectRatio}computeOutputShape(e){e=Qe(e);let t=e[2];return[this.height,this.width,t]}getConfig(){let e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return O(()=>{let n=[this.height,this.width];if(this.interpolation==="bilinear")return tr.resizeBilinear(e,n,!this.cropToAspectRatio);if(this.interpolation==="nearest")return tr.resizeNearestNeighbor(e,n,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...ZS]} are supported`)})}};Tk.className="Resizing";re.registerClass(Tk);var __=class{constructor(e){this.seed=e}next(){if(this.seed!==void 0)return this.seed++}};__.className="RandomSeed";var E_=class extends We{constructor(e){super(e),this.randomGenerator=new __(e.seed)}getConfig(){let e={seed:this.randomGenerator.seed},t=super.getConfig();return Object.assign(e,t),e}};E_.className="BaseRandomLayer";var i6=["bilinear","nearest"],JS=new Set(i6),Nk=class extends E_{constructor(e){super(e);let{factor:t,interpolation:n="bilinear"}=e;if(this.factor=t,Array.isArray(this.factor)&&this.factor.length===2)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else if(!Array.isArray(this.factor)&&this.factor>0)this.widthLower=-this.factor,this.widthUpper=this.factor;else throw new V(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);if(this.widthLower<-1||this.widthUpper<-1)throw new V(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new V(`factor cannot have upper bound less than lower bound.
        Got upper bound: ${this.widthUpper}.
        Got lower bound: ${this.widthLower}
      `);if(n)if(JS.has(n))this.interpolation=n;else throw new V(`Invalid interpolation parameter: ${n} is not implemented`)}getConfig(){let e={factor:this.factor,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=Qe(e);let t=e[2];return[this.imgHeight,-1,t]}call(e,t){return O(()=>{let n=Ne(e);this.imgHeight=n.shape[n.shape.length-3];let r=n.shape[n.shape.length-2];this.widthFactor=$a([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let s=this.widthFactor.dataSync()[0]*r;s=Math.round(s);let a=[this.imgHeight,s];switch(this.interpolation){case"bilinear":return tr.resizeBilinear(e,a);case"nearest":return tr.resizeNearestNeighbor(e,a);default:throw new Error(`Interpolation is ${this.interpolation}
          but only ${[...JS]} are supported`)}})}};Nk.className="RandomWidth";re.registerClass(Nk);function u6(e){return new bl(e)}function c6(e){return new _I(e)}function l6(e){return new CI(e)}function d6(e){return new TI(e)}function p6(e){return new NI(e)}function h6(e){return new AI(e)}function f6(e){return new EI(e)}function m6(e){return new jm(e)}function g6(e){return new $p(e)}function b6(e){return new FI(e)}function y6(e){return new Fp(e)}function v6(e){return new RI(e)}function x6(e){return new PI(e)}function w6(e){return new OI(e)}function I6(e){return new MI(e)}function k6(e){return new LI(e)}function S6(e){return new jI(e)}function C6(e){return new GI(e)}function T6(e){return new Zm(e)}function N6(e){return new UI(e)}function _6(e){return new HI(e)}function E6(e){return new qI(e)}function A6(e){return new KI(e)}function D6(e){return new XI(e)}function $6(e){return new ZI(e)}function F6(e){return new JI(e)}function R6(e){return new ek(e)}function P6(e){return new rk(e)}function O6(e){return new tk(e)}function M6(e){return new nk(e)}function L6(e){return new QI(e)}function z6(e){return new sk(e)}function B6(e){return new uk(e)}function W6(e){return new ck(e)}function V6(e){return new lk(e)}function _k(e){return new pk(e)}function U6(e){return _k(e)}function G6(e){return _k(e)}function Ek(e){return new fk(e)}function H6(e){return Ek(e)}function j6(e){return Ek(e)}function Ak(e){return new gk(e)}function q6(e){return Ak(e)}function K6(e){return Ak(e)}function X6(e){return new bk(e)}function Y6(e){return new vk(e)}function A_(e){return new yk(e)}function D_(e){return new xk(e)}function $_(e){return new dk(e)}function F_(e){return new hk(e)}function Z6(e){return new mk(e)}function J6(e){return new BI(e)}function Q6(e){return new Km(e)}function e5(e){return new WI(e)}function t5(e){return new Pp(e)}function n5(e){return new zI(e)}function r5(e){return new qm(e)}function s5(e){return new VI(e)}function a5(e){return new Ym(e)}function o5(e){return new ys(e)}function i5(e){return new Xm(e)}function u5(e){return new Ik(e)}function c5(e){return new wk(e)}var l5=A_,d5=D_,p5=$_,h5=F_;function f5(e){return new ak(e)}function m5(e){return new ok(e)}function g5(e){return new ik(e)}function b5(e){return new YI(e)}function y5(e){return new kk(e)}function v5(e){return new Sk(e)}function x5(e){return new Tk(e)}function w5(e){return new Ck(e)}function I5(e){return new Nk(e)}var R_={};Ee(R_,{MAPE:()=>F5,MSE:()=>O5,binaryAccuracy:()=>k5,binaryCrossentropy:()=>S5,categoricalAccuracy:()=>T5,categoricalCrossentropy:()=>N5,cosineProximity:()=>A5,mape:()=>R5,meanAbsoluteError:()=>D5,meanAbsolutePercentageError:()=>$5,meanSquaredError:()=>P5,mse:()=>M5,precision:()=>_5,recall:()=>E5,sparseCategoricalAccuracy:()=>C5});function k5(e,t){return vI(e,t)}function S5(e,t){return jN(e,t)}function C5(e,t){return qN(e,t)}function T5(e,t){return xI(e,t)}function N5(e,t){return wI(e,t)}function _5(e,t){return HN(e,t)}function E5(e,t){return cH(e,t)}function A5(e,t){return yI(e,t)}function D5(e,t){return Gm(e,t)}function $5(e,t){return yl(e,t)}function F5(e,t){return yl(e,t)}function R5(e,t){return yl(e,t)}function P5(e,t){return Ji(e,t)}function O5(e,t){return Ji(e,t)}function M5(e,t){return Ji(e,t)}var P_={};Ee(P_,{modelFromJSON:()=>MH});var O_={};Ee(O_,{l1:()=>z5,l1l2:()=>L5,l2:()=>B5});function L5(e){return new Ap(e)}function z5(e){return GH(e)}function B5(e){return HH(e)}var M_=class extends tc{constructor(){super(...arguments),this.model=null}setModel(e){if(!(e instanceof Fs))throw new Error("model must be a LayersModel, not some other Container");this.model=e}};function Vh(e,t){return e<t}function QS(e,t){return e>t}var L_=class extends M_{constructor(e){if(super(),e==null&&(e={}),e.restoreBestWeights)throw new Le("restoreBestWeights = True is not implemented in EarlyStopping yet.");this.monitor=e.monitor||"val_loss",this.minDelta=Math.abs(e.minDelta||0),this.patience=e.patience||0,this.verbose=e.verbose||0,this.mode=e.mode||"auto",this.baseline=e.baseline,["auto","min","max"].indexOf(this.mode)===-1&&(console.warn(`EarlyStopping mode '${this.mode}' is invalid. Falling back to mode 'auto'.`),this.mode="auto"),this.mode==="min"?this.monitorFunc=Vh:this.mode==="max"?this.monitorFunc=QS:this.monitor.indexOf("acc")!==-1?this.monitorFunc=QS:this.monitorFunc=Vh,this.monitorFunc===Vh&&(this.minDelta*=-1)}async onTrainBegin(e){this.wait=0,this.stoppedEpoch=0,this.baseline!=null?this.best=this.baseline:this.best=this.monitorFunc===Vh?1/0:-1/0}async onEpochEnd(e,t){await na(t);let n=this.getMonitorValue(t);n!=null&&(this.monitorFunc(n-this.minDelta,this.best)?(this.best=n,this.wait=0):(this.wait++,this.wait>=this.patience&&(this.stoppedEpoch=e,this.model.stopTraining=!0)))}async onTrainEnd(e){this.stoppedEpoch>0&&this.verbose&&console.log(`Epoch ${this.stoppedEpoch}: early stopping.`)}getMonitorValue(e){e==null&&(e={});let t=e[this.monitor];return t==null&&console.warn(`Metric for EarlyStopping ${this.monitor} is not available. Available metrics are: ${Object.keys(e)}`),t}};function W5(e){return new L_(e)}var V5={earlyStopping:W5},U5=G();U5.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,e=>{e&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var Er;(function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_QINT16=15]="DT_QINT16",e[e.DT_QUINT16=16]="DT_QUINT16",e[e.DT_UINT16=17]="DT_UINT16",e[e.DT_COMPLEX128=18]="DT_COMPLEX128",e[e.DT_HALF=19]="DT_HALF",e[e.DT_RESOURCE=20]="DT_RESOURCE",e[e.DT_VARIANT=21]="DT_VARIANT",e[e.DT_UINT32=22]="DT_UINT32",e[e.DT_UINT64=23]="DT_UINT64",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",e[e.DT_QINT16_REF=115]="DT_QINT16_REF",e[e.DT_QUINT16_REF=116]="DT_QUINT16_REF",e[e.DT_UINT16_REF=117]="DT_UINT16_REF",e[e.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",e[e.DT_HALF_REF=119]="DT_HALF_REF",e[e.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",e[e.DT_VARIANT_REF=121]="DT_VARIANT_REF",e[e.DT_UINT32_REF=122]="DT_UINT32_REF",e[e.DT_UINT64_REF=123]="DT_UINT64_REF"})(Er||(Er={}));var e1;(function(e){let t;(function(n){n[n.LEGACY=0]="LEGACY",n[n.V1=1]="V1",n[n.V2=2]="V2"})(t=e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))})(e1||(e1={}));var Dk={};function G5(e,t){let n={tfOpName:e,category:"custom",inputs:[],attrs:[],customExecutor:t};Dk[e]=n}function z_(e){return Dk[e]}function H5(e){delete Dk[e]}function I(e,t,n,r,s){let a=t.inputParams[e];if(a&&a.inputIndexStart!==void 0){let i=a.inputIndexStart,u=a.inputIndexEnd===0?void 0:a.inputIndexEnd===void 0?i+1:a.inputIndexEnd,c=i<0?t.inputNames.length+i:i;if(a.type==="tensor")return pn(t.inputNames[c],n,r,s);if(a.type==="tensors"){let d=t.inputs.slice(i,u);return t.inputNames.slice(i,u).filter((f,g)=>{var m;return((m=d[g])===null||m===void 0?void 0:m.op)!=="NoOp"}).map(f=>pn(f,n,r,s))}let l=pn(t.inputNames[c],n,r,s),p=l.dataSync();return a.type==="number"?p[0]:w.toNestedArray(l.shape,p)}let o=t.attrParams[e];return o&&o.value}function pn(e,t,n,r){let[s,a]=Jn(e,n);if(r!=null){let i=r.getHashTableHandleByName(s);if(i!=null)return i}let o=n.currentContextIds.find(i=>!!t[Cf(s,i)]);return o!==void 0?t[Cf(s,o)][a]:void 0}function t1(e,t,n){return t[Cf(e,n.currentContextId)]}function Es(e,t){let[n,r,s]=Jn(e,t);return[Cf(n,t&&t.currentContextId),r,s]}function Cf(e,t){return t?`${e}-${t}`:e}function Jn(e,t){if(e==="")return["",0,void 0];let n=t!=null&&t.parseNodeNameCache!=null;if(n){let a=t.parseNodeNameCache.get(e);if(a!=null)return a}let r=e.split(":"),s;if(r.length===1)s=[e,0,void 0];else{let a=r[0],o=r.length===3?r[1]:void 0,i=Number(r[r.length-1]);s=[a,i,o]}return n&&t.parseNodeNameCache.set(e,s),s}function Qh(e,t,n){let r=I("pad",e,t,n);if(r==="explicit"){r=I("explicitPaddings",e,t,n);let s=[[0,0],[0,0],[0,0],[0,0]];for(let a=0;a<4;a++)s[a][0]=r[a*2],s[a][1]=r[a*2+1];return s}return r}function As(e){return e.kept?e:us(e)}var B_={};Ee(B_,{json:()=>j5});var j5=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],W_={};Ee(W_,{json:()=>q5});var q5=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],V_={};Ee(V_,{json:()=>K5});var K5=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],U_={};Ee(U_,{json:()=>X5});var X5=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],G_={};Ee(G_,{json:()=>Y5});var Y5=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],H_={};Ee(H_,{json:()=>Z5});var Z5=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],j_={};Ee(j_,{json:()=>J5});var J5=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],q_={};Ee(q_,{json:()=>Q5});var Q5=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],K_={};Ee(K_,{json:()=>ej});var ej=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],X_={};Ee(X_,{json:()=>tj});var tj=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],Y_={};Ee(Y_,{json:()=>nj});var nj=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],Z_={};Ee(Z_,{json:()=>rj});var rj=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],J_={};Ee(J_,{json:()=>sj});var sj=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],Q_={};Ee(Q_,{json:()=>aj});var aj=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],e2={};Ee(e2,{json:()=>oj});var oj=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],t2={};Ee(t2,{json:()=>ij});var ij=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],n2={};Ee(n2,{json:()=>uj});var uj=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],r2={};Ee(r2,{json:()=>cj});var cj=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],s2={};Ee(s2,{json:()=>lj});var lj=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],n1=class{static get Instance(){return this._instance||(this._instance=new this)}constructor(){let e=[B_,W_,V_,U_,G_,H_,j_,q_,K_,X_,Y_,Z_,J_,Q_,e2,t2,n2,r2,s2],t=[].concat(...e.map(n=>n.json));this.opMappers=t.reduce((n,r)=>(n[r.tfOpName]=r,n),{})}transformGraph(e,t={}){let n=e.node,r=[],s=[],a=[],o=n.reduce((f,g)=>(f[g.name]=this.mapNode(g),g.op.startsWith("Placeholder")?r.push(f[g.name]):g.op==="Const"?s.push(f[g.name]):(g.input==null||g.input.length===0)&&a.push(f[g.name]),f),{}),i=[],u=[],c={},l={};t!=null&&(c=this.mapSignatureEntries(t.inputs),l=this.mapSignatureEntries(t.outputs));let p=Object.keys(o);p.forEach(f=>{let g=o[f];g.inputNames.forEach((m,b)=>{let[v,,y]=Es(m),x=o[v];if(x.outputs!=null){let k=x.outputs.indexOf(y);if(k!==-1){let S=`${v}:${k}`;g.inputNames[b]=S}}g.inputs.push(x),x.children.push(g)})}),Object.keys(l).length===0?p.forEach(f=>{let g=o[f];g.children.length===0&&u.push(g)}):Object.keys(l).forEach(f=>{let[g]=Es(f),m=o[g];m!=null&&(m.signatureKey=l[f],u.push(m))}),Object.keys(c).length>0?Object.keys(c).forEach(f=>{let[g]=Es(f),m=o[g];m&&(m.signatureKey=c[f],i.push(m))}):i=r;let d={};e.library!=null&&e.library.function!=null&&(d=e.library.function.reduce((f,g)=>(f[g.signature.name]=this.mapFunction(g),f),{}));let h={nodes:o,inputs:i,outputs:u,weights:s,placeholders:r,signature:t,functions:d};return a.length>0&&(h.initNodes=a),h}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,n)=>(t[e[n].name]=n,t),{})}mapNode(e){let t=z_(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});let n={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(r=>r.startsWith("^")?r.slice(1):r),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return t.inputs!=null&&(n.inputParams=t.inputs.reduce((r,s)=>(r[s.name]={type:s.type,inputIndexStart:s.start,inputIndexEnd:s.end},r),{})),t.attrs!=null&&(n.attrParams=t.attrs.reduce((r,s)=>{let a=s.type,o;switch(s.type){case"string":o=Qv(e.attr,s.tfName,s.defaultValue),o===void 0&&s.tfDeprecatedName&&(o=Qv(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"string[]":o=ox(e.attr,s.tfName,s.defaultValue),o===void 0&&s.tfDeprecatedName&&(o=ox(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"number":o=tx(e.attr,s.tfName,s.defaultValue||0),o===void 0&&s.tfDeprecatedName&&(o=tx(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"number[]":o=ax(e.attr,s.tfName,s.defaultValue),o===void 0&&s.tfDeprecatedName&&(o=ax(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"bool":o=ex(e.attr,s.tfName,s.defaultValue),o===void 0&&s.tfDeprecatedName&&(o=ex(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"bool[]":o=ux(e.attr,s.tfName,s.defaultValue),o===void 0&&s.tfDeprecatedName&&(o=ux(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"shape":o=sx(e.attr,s.tfName,s.defaultValue),o===void 0&&s.tfDeprecatedName&&(o=sx(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"shape[]":o=ix(e.attr,s.tfName,s.defaultValue),o===void 0&&s.tfDeprecatedName&&(o=ix(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"dtype":o=nx(e.attr,s.tfName,s.defaultValue),o===void 0&&s.tfDeprecatedName&&(o=nx(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"dtype[]":o=rx(e.attr,s.tfName,s.defaultValue),o===void 0&&s.tfDeprecatedName&&(o=rx(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"func":o=r1(e.attr,s.tfName,s.defaultValue),o===void 0&&s.tfDeprecatedName&&(o=r1(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${s.type} for op: ${e.op}`)}return r[s.name]={value:o,type:a},r},{})),n}mapFunction(e){let t=e.nodeDef,n=[],r=[],s={};t!=null&&(s=t.reduce((l,p)=>(l[p.name]=this.mapNode(p),p.op==="Const"&&r.push(l[p.name]),l),{}));let a=[],o=[];e.signature.inputArg.forEach(l=>{let[p]=Es(l.name),d={name:p,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:$k(l.type),type:"dtype"}},children:[]};d.signatureKey=l.name,a.push(d),s[p]=d}),Object.keys(s).forEach(l=>{let p=s[l];p.inputNames.forEach((d,h)=>{let[f,,g]=Es(d),m=s[f];if(m.outputs!=null){let b=m.outputs.indexOf(g);if(b!==-1){let v=`${f}:${b}`;p.inputNames[h]=v}}p.inputs.push(m),m.children.push(p)})});let u=e.ret;e.signature.outputArg.forEach(l=>{let[p,d]=Es(u[l.name]),h=s[p];h!=null&&(h.defaultOutput=d,o.push(h))});let c=this.mapArgsToSignature(e);return{nodes:s,inputs:a,outputs:o,weights:r,placeholders:n,signature:c}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n),t),{}),outputs:e.signature.outputArg.reduce((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n,e.ret),t),{})}}mapArgToTensorInfo(e,t){let n=e.name;return t!=null&&(n=t[n]),{name:n,dtype:e.type}}};function dj(e){let t=G().global;if(typeof t.atob<"u")return t.atob(e);if(typeof Buffer<"u")return new Buffer(e,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function a2(e,t){let n=Array.isArray(e)?String.fromCharCode.apply(null,e):dj(e);return t?n:n.toLowerCase()}function Qv(e,t,n,r=!1){let s=e[t];return s!=null?a2(s.s,r):n}function ex(e,t,n){let r=e[t];return r?r.b:n}function tx(e,t,n){let r=e[t]||{},s=r.i!=null?r.i:r.f!=null?r.f:n;return typeof s=="number"?s:parseInt(s,10)}function $k(e){switch(typeof e=="string"&&(e=Er[e]),e){case Er.DT_FLOAT:case Er.DT_HALF:return"float32";case Er.DT_INT32:case Er.DT_INT64:case Er.DT_INT8:case Er.DT_UINT8:return"int32";case Er.DT_BOOL:return"bool";case Er.DT_DOUBLE:return"float32";case Er.DT_STRING:return"string";default:return null}}function r1(e,t,n){let r=e[t];return r&&r.func?r.func.name:n}function nx(e,t,n){let r=e[t];return r&&r.type?$k(r.type):n}function rx(e,t,n){let r=e[t];return r&&r.list&&r.list.type?r.list.type.map(s=>$k(s)):n}function o2(e){if(!e.unknownRank)return e.dim!=null?e.dim.map(t=>typeof t.size=="number"?t.size:parseInt(t.size,10)):[]}function sx(e,t,n){let r=e[t];return r&&r.shape?o2(r.shape):n}function ax(e,t,n){let r=e[t];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map(s=>typeof s=="number"?s:parseInt(s,10)):n}function ox(e,t,n,r=!1){let s=e[t];return s&&s.list&&s.list.s?s.list.s.map(a=>a2(a,r)):n}function ix(e,t,n){let r=e[t];return r&&r.list&&r.list.shape?r.list.shape.map(s=>o2(s)):n}function ux(e,t,n){let r=e[t];return r&&r.list&&r.list.b?r.list.b:n}var pj=class{constructor(e,t,n){this.node=e,this.tensorMap=t,this.context=n,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(r=>this.getInput(r)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((r,s)=>(r[s]=this.getAttr(s),r),{}))}getInput(e){return pn(e,this.tensorMap,this.context)}getAttr(e,t){let n=this.node.rawAttrs[e];if(n.tensor!=null)return pn(e,this.tensorMap,this.context);if(n.i!=null||n.f!=null)return tx(this.node.rawAttrs,e,t);if(n.s!=null)return Qv(this.node.rawAttrs,e,t);if(n.b!=null)return ex(this.node.rawAttrs,e,t);if(n.shape!=null)return sx(this.node.rawAttrs,e,t);if(n.type!=null)return nx(this.node.rawAttrs,e,t);if(n.list!=null){if(n.list.i!=null||n.list.f!=null)return ax(this.node.rawAttrs,e,t);if(n.list.s!=null)return ox(this.node.rawAttrs,e,t);if(n.list.shape!=null)return ix(this.node.rawAttrs,e,t);if(n.list.b!=null)return ux(this.node.rawAttrs,e,t);if(n.list.type!=null)return rx(this.node.rawAttrs,e,t)}return t}},un={};Ee(un,{OP_SCOPE_SUFFIX:()=>Rx,abs:()=>Bt,acos:()=>zx,acosh:()=>Bx,add:()=>X,addN:()=>PC,all:()=>rm,any:()=>Sd,argMax:()=>mo,argMin:()=>Wx,asin:()=>Vx,asinh:()=>Ux,atan:()=>Gx,atan2:()=>Hx,atanh:()=>jx,avgPool:()=>br,avgPool3d:()=>Kx,basicLSTMCell:()=>zC,batchNorm:()=>Ea,batchNorm2d:()=>Xx,batchNorm3d:()=>Yx,batchNorm4d:()=>Zx,batchToSpaceND:()=>pp,bincount:()=>Jx,bitwiseAnd:()=>BC,booleanMaskAsync:()=>ET,broadcastArgs:()=>WC,broadcastTo:()=>oo,buffer:()=>ze,cast:()=>ae,ceil:()=>Qx,clipByValue:()=>an,clone:()=>us,complex:()=>Rs,concat:()=>tt,concat1d:()=>ew,concat2d:()=>tw,concat3d:()=>nw,concat4d:()=>rw,conv1d:()=>sm,conv2d:()=>Pt,conv2dTranspose:()=>am,conv3d:()=>aw,conv3dTranspose:()=>ow,cos:()=>hp,cosh:()=>om,cosineWindow:()=>_m,cumprod:()=>Nd,cumsum:()=>im,denseBincount:()=>mf,depthToSpace:()=>iw,depthwiseConv2d:()=>Aa,diag:()=>UC,dilation2d:()=>uw,div:()=>fe,divNoNan:()=>cw,dot:()=>lw,dropout:()=>Bw,einsum:()=>Ja,elu:()=>pl,enclosingPowerOfTwo:()=>Ww,ensureShape:()=>HC,equal:()=>nr,erf:()=>dw,euclideanNorm:()=>fw,exp:()=>vn,expandDims:()=>jt,expm1:()=>mw,eye:()=>um,fft:()=>Ip,fill:()=>xn,floor:()=>fl,floorDiv:()=>nm,fused:()=>Ju,gather:()=>ml,gatherND:()=>FT,greater:()=>Dn,greaterEqual:()=>Ms,ifft:()=>Zu,imag:()=>fp,image:()=>tr,inTopKAsync:()=>RT,irfft:()=>Im,isFinite:()=>gw,isInf:()=>bw,isNaN:()=>yw,leakyRelu:()=>mp,less:()=>qu,lessEqual:()=>Da,linalg:()=>Gw,linspace:()=>YC,localResponseNormalization:()=>vw,log:()=>rr,log1p:()=>gp,logSigmoid:()=>xw,logSoftmax:()=>lm,logSumExp:()=>dm,logicalAnd:()=>Rr,logicalNot:()=>bp,logicalOr:()=>pm,logicalXor:()=>ww,losses:()=>jT,lowerBound:()=>JC,matMul:()=>Fe,max:()=>fr,maxPool:()=>Ot,maxPool3d:()=>Iw,maxPoolWithArgmax:()=>QC,maximum:()=>gs,mean:()=>Et,meshgrid:()=>eT,min:()=>ju,minimum:()=>ga,mirrorPad:()=>kw,mod:()=>Sw,moments:()=>yp,movingAverage:()=>AT,mul:()=>B,multiRNNCell:()=>tT,multinomial:()=>nT,neg:()=>bt,norm:()=>hl,notEqual:()=>vo,oneHot:()=>Ku,ones:()=>er,onesLike:()=>sr,op:()=>z,outerProduct:()=>rT,pad:()=>yr,pad1d:()=>sT,pad2d:()=>aT,pad3d:()=>oT,pad4d:()=>iT,pool:()=>Cw,pow:()=>Ps,prelu:()=>xp,print:()=>Mx,prod:()=>Tw,raggedGather:()=>uT,raggedRange:()=>cT,raggedTensorToTensor:()=>lT,rand:()=>dT,randomGamma:()=>mT,randomNormal:()=>fm,randomStandardNormal:()=>gT,randomUniform:()=>$a,randomUniformInt:()=>bT,range:()=>xo,real:()=>Xu,reciprocal:()=>Dw,relu:()=>Ke,relu6:()=>mm,reshape:()=>W,reverse:()=>gr,reverse1d:()=>yT,reverse2d:()=>vT,reverse3d:()=>xT,reverse4d:()=>wT,rfft:()=>kp,round:()=>gm,rsqrt:()=>bm,scalar:()=>xe,scatterND:()=>DT,searchSorted:()=>hm,selu:()=>ym,separableConv2d:()=>Fa,setdiff1dAsync:()=>IT,sigmoid:()=>hr,sign:()=>$w,signal:()=>HT,sin:()=>vm,sinh:()=>xm,slice:()=>Ue,slice1d:()=>wp,slice2d:()=>wm,slice3d:()=>Ki,slice4d:()=>Yu,softmax:()=>Yr,softplus:()=>qi,spaceToBatchND:()=>vp,sparse:()=>qT,sparseToDense:()=>$T,spectral:()=>GT,split:()=>zn,sqrt:()=>fn,square:()=>ct,squaredDifference:()=>km,squeeze:()=>Ra,stack:()=>Rt,step:()=>Xi,stridedSlice:()=>Fw,string:()=>KT,sub:()=>de,sum:()=>ge,tan:()=>Rw,tanh:()=>bo,tensor:()=>yn,tensor1d:()=>He,tensor2d:()=>Fr,tensor3d:()=>Sp,tensor4d:()=>Or,tensor5d:()=>kT,tensor6d:()=>ST,tensorScatterUpdate:()=>TT,tile:()=>Ln,topk:()=>Ow,transpose:()=>Re,truncatedNormal:()=>Tm,unique:()=>Mw,unsortedSegmentSum:()=>Nm,unstack:()=>dt,upperBound:()=>NT,variable:()=>Lw,where:()=>sn,whereAsync:()=>zw,zeros:()=>Ct,zerosLike:()=>je});var hj=(e,t,n,r=un)=>{switch(e.op){case"BiasAdd":case"AddV2":case"Add":return[r.add(I("a",e,t,n),I("b",e,t,n))];case"AddN":return[r.addN(I("tensors",e,t,n))];case"FloorMod":case"Mod":return[r.mod(I("a",e,t,n),I("b",e,t,n))];case"Mul":return[r.mul(I("a",e,t,n),I("b",e,t,n))];case"RealDiv":case"Div":return[r.div(I("a",e,t,n),I("b",e,t,n))];case"DivNoNan":return[r.divNoNan(I("a",e,t,n),I("b",e,t,n))];case"FloorDiv":return[r.floorDiv(I("a",e,t,n),I("b",e,t,n))];case"Sub":return[r.sub(I("a",e,t,n),I("b",e,t,n))];case"Minimum":return[r.minimum(I("a",e,t,n),I("b",e,t,n))];case"Maximum":return[r.maximum(I("a",e,t,n),I("b",e,t,n))];case"Pow":return[r.pow(I("a",e,t,n),I("b",e,t,n))];case"SquaredDifference":return[r.squaredDifference(I("a",e,t,n),I("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},fj=(e,t,n,r=un)=>{switch(e.op){case"Abs":case"ComplexAbs":return[r.abs(I("x",e,t,n))];case"Acos":return[r.acos(I("x",e,t,n))];case"Acosh":return[r.acosh(I("x",e,t,n))];case"Asin":return[r.asin(I("x",e,t,n))];case"Asinh":return[r.asinh(I("x",e,t,n))];case"Atan":return[r.atan(I("x",e,t,n))];case"Atan2":return[r.atan2(I("x",e,t,n),I("y",e,t,n))];case"Atanh":return[r.atanh(I("x",e,t,n))];case"Ceil":return[r.ceil(I("x",e,t,n))];case"Complex":return[r.complex(I("real",e,t,n),I("imag",e,t,n))];case"Cos":return[r.cos(I("x",e,t,n))];case"Cosh":return[r.cosh(I("x",e,t,n))];case"Elu":return[r.elu(I("x",e,t,n))];case"Erf":return[r.erf(I("x",e,t,n))];case"Exp":return[r.exp(I("x",e,t,n))];case"Expm1":return[r.expm1(I("x",e,t,n))];case"Floor":return[r.floor(I("x",e,t,n))];case"Log":return[r.log(I("x",e,t,n))];case"Log1p":return[r.log1p(I("x",e,t,n))];case"Imag":return[r.imag(I("x",e,t,n))];case"Neg":return[r.neg(I("x",e,t,n))];case"Reciprocal":return[r.reciprocal(I("x",e,t,n))];case"Real":return[r.real(I("x",e,t,n))];case"Relu":return[r.relu(I("x",e,t,n))];case"Round":return[r.round(I("x",e,t,n))];case"Selu":return[r.selu(I("x",e,t,n))];case"Sigmoid":return[r.sigmoid(I("x",e,t,n))];case"Sin":return[r.sin(I("x",e,t,n))];case"Sign":return[r.sign(I("x",e,t,n))];case"Sinh":return[r.sinh(I("x",e,t,n))];case"Softplus":return[r.softplus(I("x",e,t,n))];case"Sqrt":return[r.sqrt(I("x",e,t,n))];case"Square":return[r.square(I("x",e,t,n))];case"Tanh":return[r.tanh(I("x",e,t,n))];case"Tan":return[r.tan(I("x",e,t,n))];case"ClipByValue":return[r.clipByValue(I("x",e,t,n),I("clipValueMin",e,t,n),I("clipValueMax",e,t,n))];case"Relu6":return[r.relu6(I("x",e,t,n))];case"Rsqrt":return[r.rsqrt(pn(e.inputNames[0],t,n))];case"LeakyRelu":return[r.leakyRelu(I("x",e,t,n),I("alpha",e,t,n))];case"Prelu":return[r.prelu(I("x",e,t,n),I("alpha",e,t,n))];case"IsNan":return[r.isNaN(pn(e.inputNames[0],t,n))];case"IsInf":return[r.isInf(pn(e.inputNames[0],t,n))];case"IsFinite":return[r.isFinite(pn(e.inputNames[0],t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};function $r(e,t,n=""){if(!(typeof e=="number"||typeof t=="number")){w.assert(e.length===t.length,()=>n+` Shapes ${e} and ${t} must match`);for(let r=0;r<e.length;r++){let s=e[r],a=t[r];w.assert(s<0||a<0||s===a,()=>n+` Shapes ${e} and ${t} must match`)}}}function s1(e){return!(typeof e=="number"||e.some(t=>t<0))}function nd(e,t,n){let r=cx(e,n),s=!s1(r);if(s&&t.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(s&&t.forEach(a=>{r=cx(a.shape,r)}),!s1(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function cx(e,t){if(typeof e=="number")return t;if(typeof t=="number")return e;if(e.length!==t.length)throw new Error(`Incompatible ranks during merge: ${e} vs. ${t}`);let n=[];for(let r=0;r<e.length;++r){let s=e[r],a=t[r];if(s>=0&&a>=0&&s!==a)throw new Error(`Incompatible shape during merge: ${e} vs. ${t}`);n[r]=s>=0?s:a}return n}var mj=class{constructor(e,t,n,r,s,a,o){this.name=e,this.dtype=t,this.maxSize=n,this.elementShape=r,this.identicalElementShapes=s,this.dynamicSize=a,this.clearAfterRead=o,this.tensors=[],this.closed_=!1,this.idTensor=xe(0),qt(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.tensor.id))&&t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);let t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(t=>this.read(t))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);let n=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=t.shape),$r(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),n.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(n.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);n.tensor=t,qt(t),n.written=!0,this.tensors[e]=n}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((n,r)=>this.write(n,t[r]))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let r=0;r<this.size();r++)e.push(r)}if(e.length===0)return yn([],[0].concat(this.elementShape));let n=this.readMany(e);return $r(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),Rt(n,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return yn([],[0].concat(this.elementShape));let t=[];for(let r=0;r<this.size();r++)t.push(r);let n=this.readMany(t);return $r(this.elementShape,n[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`),tt(n,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);let n=Math.max(...e);if(!this.dynamicSize&&n>=this.maxSize)throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);this.writeMany(e,dt(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let n=0,r=e.map(i=>(n+=i,n));if(n!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${n}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);let s=n===0?0:t.size/n,a=[];O(()=>{t=W(t,[1,n,s]);for(let i=0;i<e.length;++i){let c=[0,i===0?0:r[i-1],0],l=[1,e[i],s];a[i]=W(Ue(t,c,l),this.elementShape)}return a});let o=[];for(let i=0;i<e.length;i++)o[i]=i;this.writeMany(o,a)}},rc=class{get id(){return this.idTensor.id}constructor(e,t,n,r=-1){this.tensors=e,this.elementShape=t,this.elementDtype=n,e?.forEach(s=>{if(n!==s.dtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${s.dtype}`);$r(t,s.shape,"TensorList shape mismatch: "),qt(s)}),this.idTensor=xe(0),this.maxNumElements=r,qt(this.idTensor)}copy(){return new rc([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.id))&&t.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,n=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(n!==-1&&this.tensors.length!==n)throw new Error(`Operation expected a list with ${n} elements but got a list with ${this.tensors.length} elements.`);$r(e,this.elementShape,"TensorList shape mismatch: ");let r=nd(this.elementShape,this.tensors,e);return O(()=>{let s=this.tensors.map(a=>W(a,r));return Rt(s,0)})}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");let n=nd(this.elementShape,this.tensors,e),r=this.tensors.pop();return r.kept=!1,$r(r.shape,e,"TensorList shape mismatch: "),W(r,n)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if($r(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");qt(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(this.maxNumElements!==-1&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);let t=new rc([],this.elementShape,this.elementDtype,this.maxNumElements);t.tensors.length=e;for(let n=0;n<Math.min(this.tensors.length,e);++n)t.tensors[n]=this.tensors[n];return t}getItem(e,t,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(this.tensors[e]==null)throw new Error(`element at index ${e} is null.`);$r(this.tensors[e].shape,t,"TensorList shape mismatch: ");let r=nd(this.elementShape,this.tensors,t);return W(this.tensors[e],r)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||this.maxNumElements!==-1&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);$r(this.elementShape,t.shape,"TensorList shape mismatch: "),qt(t),this.tensors[e]!=null&&(this.tensors[e].kept=!1),this.tensors[e]=t}gather(e,t,n){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);$r(this.elementShape,n,"TensorList shape mismatch: "),e=e.slice(0,this.size());let r=nd(this.elementShape,this.tensors,n);return e.length===0?yn([],[0].concat(r)):O(()=>{let s=e.map(a=>W(this.tensors[a],r));return Rt(s,0)})}concat(e,t){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);$r(this.elementShape,t,"TensorList shape mismatch: ");let n=nd(this.elementShape,this.tensors,t);return this.size()===0?yn([],[0].concat(n)):O(()=>{let r=this.tensors.map(s=>W(s,n));return tt(r,0)})}};function gj(e,t,n){let r=e.dtype;if(e.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${e.shape}`);if(e.dtype!==n)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${n}`);let s=e.shape.slice(1);$r(s,t,"TensorList shape mismatch: ");let a=dt(e);return new rc(a,t,r)}function bj(e,t,n,r){return new rc([],e,t,r)}function yj(e,t,n,r){if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);let s=Math.max(...t);if(r!=null&&r!==-1&&s>=r)throw new Error(`Max index must be < array size (${s}  vs. ${r})`);let a=new rc([],n,e.dtype,r),o=dt(e,0);return t.forEach((i,u)=>{a.setItem(i,o[u])}),a}function vj(e,t,n){let r=0,s=t.map(l=>(r+=l,r));if(r!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r}, and tensor's shape is: ${e.shape}`);let a=e.shape.slice(1),o=cx(a,n),i=r===0?0:e.size/r,u=O(()=>{let l=[];e=W(e,[1,r,i]);for(let p=0;p<t.length;++p){let h=[0,p===0?0:s[p-1],0],f=[1,t[p],i];l[p]=W(Ue(e,h,f),o)}return e.dispose(),l}),c=new rc([],n,e.dtype,t.length);for(let l=0;l<u.length;l++)c.setItem(l,u[l]);return c}var xj=async(e,t,n)=>{switch(e.op){case"If":case"StatelessIf":{let r=I("thenBranch",e,t,n),s=I("elseBranch",e,t,n),a=I("cond",e,t,n),o=I("args",e,t,n);return(await a.data())[0]?n.functionMap[r].executeFunctionAsync(o,n.tensorArrayMap,n.tensorListMap):n.functionMap[s].executeFunctionAsync(o,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{let r=I("body",e,t,n),s=I("cond",e,t,n),a=I("args",e,t,n),o=await n.functionMap[s].executeFunctionAsync(a,n.tensorArrayMap,n.tensorListMap),i=a.map(l=>l.id),u=await o[0].data();o.forEach(l=>{!l.kept&&i.indexOf(l.id)===-1&&l.dispose()});let c=a;for(;u[0];){let l=c;c=await n.functionMap[r].executeFunctionAsync(c,n.tensorArrayMap,n.tensorListMap);let p=c.map(h=>h.id);l.forEach(h=>{!h.kept&&i.indexOf(h.id)===-1&&p.indexOf(h.id)===-1&&h.dispose()});let d=await n.functionMap[s].executeFunctionAsync(c,n.tensorArrayMap,n.tensorListMap);u=await d[0].data(),d.forEach(h=>{!h.kept&&i.indexOf(h.id)===-1&&p.indexOf(h.id)===-1&&h.dispose()})}return c}case"LoopCond":{let r=I("pred",e,t,n);return[As(r)]}case"Switch":{let r=I("pred",e,t,n),s=I("data",e,t,n);return s.kept||(s=As(s)),(await r.data())[0]?[void 0,s]:[s,void 0]}case"Merge":{let r=e.inputNames.find(s=>pn(s,t,n)!==void 0);if(r){let s=pn(r,t,n);return[As(s)]}return}case"Enter":{let r=I("frameName",e,t,n),s=I("tensor",e,t,n);return n.enterFrame(r),[As(s)]}case"Exit":{let r=I("tensor",e,t,n);return n.exitFrame(),[As(r)]}case"NextIteration":{let r=I("tensor",e,t,n);return n.nextIteration(),[As(r)]}case"TensorArrayV3":{let r=I("size",e,t,n),s=I("dtype",e,t,n),a=I("elementShape",e,t,n),o=I("dynamicSize",e,t,n),i=I("clearAfterRead",e,t,n),u=I("identicalElementShapes",e,t,n),c=I("name",e,t,n),l=new mj(c,s,r,a,u,o,i);return n.addTensorArray(l),[l.idTensor,xe(1)]}case"TensorArrayWriteV3":{let r=I("tensorArrayId",e,t,n),s=I("index",e,t,n),a=I("tensor",e,t,n),o=n.getTensorArray(r.id);return o.write(s,a),[o.idTensor]}case"TensorArrayReadV3":{let r=I("tensorArrayId",e,t,n),s=I("index",e,t,n);return[n.getTensorArray(r.id).read(s)]}case"TensorArrayGatherV3":{let r=I("tensorArrayId",e,t,n),s=I("indices",e,t,n),a=I("dtype",e,t,n);return[n.getTensorArray(r.id).gather(s,a)]}case"TensorArrayScatterV3":{let r=I("tensorArrayId",e,t,n),s=I("indices",e,t,n),a=I("tensor",e,t,n),o=n.getTensorArray(r.id);return o.scatter(s,a),[o.idTensor]}case"TensorArrayConcatV3":{let r=I("tensorArrayId",e,t,n),s=n.getTensorArray(r.id),a=I("dtype",e,t,n);return[s.concat(a)]}case"TensorArraySplitV3":{let r=I("tensorArrayId",e,t,n),s=I("tensor",e,t,n),a=I("lengths",e,t,n),o=n.getTensorArray(r.id);return o.split(a,s),[o.idTensor]}case"TensorArraySizeV3":{let r=I("tensorArrayId",e,t,n),s=n.getTensorArray(r.id);return[xe(s.size(),"int32")]}case"TensorArrayCloseV3":{let r=I("tensorArrayId",e,t,n),s=n.getTensorArray(r.id);return s.clearAndClose(),[s.idTensor]}case"TensorListSetItem":{let r=I("tensorListId",e,t,n),s=I("index",e,t,n),a=I("tensor",e,t,n),o=n.getTensorList(r.id);return o.setItem(s,a),[o.idTensor]}case"TensorListGetItem":{let r=I("tensorListId",e,t,n),s=I("index",e,t,n),a=I("elementShape",e,t,n),o=I("elementDType",e,t,n);return[n.getTensorList(r.id).getItem(s,a,o)]}case"TensorListScatterV2":case"TensorListScatter":{let r=I("indices",e,t,n),s=I("tensor",e,t,n),a=I("elementShape",e,t,n),o=I("numElements",e,t,n),i=yj(s,r,a,o);return n.addTensorList(i),[i.idTensor]}case"TensorListReserve":case"EmptyTensorList":{let r=I("elementShape",e,t,n),s=I("elementDType",e,t,n),a;e.op==="TensorListReserve"?a="numElements":a="maxNumElements";let o=I(a,e,t,n),i=e.op==="TensorListReserve"?-1:o,u=bj(r,s,o,i);return n.addTensorList(u),[u.idTensor]}case"TensorListGather":{let r=I("tensorListId",e,t,n),s=I("indices",e,t,n),a=I("elementShape",e,t,n),o=I("elementDType",e,t,n);return[n.getTensorList(r.id).gather(s,o,a)]}case"TensorListStack":{let r=I("tensorListId",e,t,n),s=I("elementShape",e,t,n),a=I("elementDType",e,t,n),o=I("numElements",e,t,n);return[n.getTensorList(r.id).stack(s,a,o)]}case"TensorListFromTensor":{let r=I("tensor",e,t,n),s=I("elementShape",e,t,n),a=I("elementDType",e,t,n),o=gj(r,s,a);return n.addTensorList(o),[o.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{let r=I("tensorListId",e,t,n),s=n.getTensorList(r.id),a=I("dtype",e,t,n),o=I("elementShape",e,t,n);return[s.concat(a,o)]}case"TensorListPushBack":{let r=I("tensorListId",e,t,n),s=I("tensor",e,t,n),a=n.getTensorList(r.id);return a.pushBack(s),[a.idTensor]}case"TensorListPopBack":{let r=I("tensorListId",e,t,n),s=I("elementShape",e,t,n),a=I("elementDType",e,t,n);return[n.getTensorList(r.id).popBack(s,a)]}case"TensorListSplit":{let r=I("tensor",e,t,n),s=I("elementShape",e,t,n),a=I("lengths",e,t,n),o=vj(r,a,s);return n.addTensorList(o),[o.idTensor]}case"TensorListLength":{let r=I("tensorListId",e,t,n),s=n.getTensorList(r.id);return[xe(s.size(),"int32")]}case"TensorListResize":{let r=I("tensorListId",e,t,n),s=I("size",e,t,n),o=n.getTensorList(r.id).resize(s);return n.addTensorList(o),[o.idTensor]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};function a1(e,t,n){let[r,s]=I("fusedOps",e,t,n),a=r==="biasadd",o=!a,i=s==="prelu",u=r==="fusedbatchnorm",c=I("numArgs",e,t,n);if(a){if(i&&c!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!i&&a&&c!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(u)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");let l=I("strides",e,t,n),p=Qh(e,t,n),d=I("dataFormat",e,t,n).toUpperCase(),h=I("dilations",e,t,n),[f,g]=I("args",e,t,n);o&&(g=f,f=void 0);let m=I("leakyreluAlpha",e,t,n);return{stride:l,pad:p,dataFormat:d,dilations:h,biasArg:f,preluArg:g,activationFunc:s,leakyreluAlpha:m}}var wj=(e,t,n,r=un)=>{switch(e.op){case"Conv1D":{let s=I("stride",e,t,n),a=I("pad",e,t,n),o=I("dataFormat",e,t,n).toUpperCase(),i=I("dilation",e,t,n);return[r.conv1d(I("x",e,t,n),I("filter",e,t,n),s,a,o,i)]}case"Conv2D":{let s=I("strides",e,t,n),a=Qh(e,t,n),o=I("dataFormat",e,t,n).toUpperCase(),i=I("dilations",e,t,n);return[r.conv2d(I("x",e,t,n),I("filter",e,t,n),[s[1],s[2]],a,o,[i[1],i[2]])]}case"_FusedConv2D":{let{stride:s,pad:a,dataFormat:o,dilations:i,biasArg:u,preluArg:c,activationFunc:l,leakyreluAlpha:p}=a1(e,t,n);return[r.fused.conv2d({x:I("x",e,t,n),filter:I("filter",e,t,n),strides:[s[1],s[2]],pad:a,dataFormat:o,dilations:[i[1],i[2]],bias:u,activation:l,preluActivationWeights:c,leakyreluAlpha:p})]}case"FusedDepthwiseConv2dNative":{let{stride:s,pad:a,dataFormat:o,dilations:i,biasArg:u,preluArg:c,activationFunc:l,leakyreluAlpha:p}=a1(e,t,n);return[r.fused.depthwiseConv2d({x:I("x",e,t,n),filter:I("filter",e,t,n),strides:[s[1],s[2]],pad:a,dataFormat:o,dilations:[i[1],i[2]],bias:u,activation:l,preluActivationWeights:c,leakyreluAlpha:p})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{let s=I("outputShape",e,t,n),a=I("strides",e,t,n),o=Qh(e,t,n);return[r.conv2dTranspose(I("x",e,t,n),I("filter",e,t,n),s,[a[1],a[2]],o)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{let s=I("strides",e,t,n),a=Qh(e,t,n),o=I("dilations",e,t,n),i=I("dataFormat",e,t,n).toUpperCase();return[r.depthwiseConv2d(I("input",e,t,n),I("filter",e,t,n),[s[1],s[2]],a,i,[o[1],o[2]])]}case"Conv3D":{let s=I("strides",e,t,n),a=I("pad",e,t,n),o=I("dataFormat",e,t,n).toUpperCase(),i=I("dilations",e,t,n);return[r.conv3d(I("x",e,t,n),I("filter",e,t,n),[s[1],s[2],s[3]],a,o,[i[1],i[2],i[3]])]}case"AvgPool":{let s=I("strides",e,t,n),a=I("pad",e,t,n),o=I("kernelSize",e,t,n);return[r.avgPool(I("x",e,t,n),[o[1],o[2]],[s[1],s[2]],a)]}case"MaxPool":{let s=I("strides",e,t,n),a=I("pad",e,t,n),o=I("kernelSize",e,t,n);return[r.maxPool(I("x",e,t,n),[o[1],o[2]],[s[1],s[2]],a)]}case"MaxPoolWithArgmax":{let s=I("strides",e,t,n),a=I("pad",e,t,n),o=I("kernelSize",e,t,n),i=I("includeBatchInIndex",e,t,n),{result:u,indexes:c}=r.maxPoolWithArgmax(I("x",e,t,n),[o[1],o[2]],[s[1],s[2]],a,i);return[u,c]}case"AvgPool3D":{let s=I("strides",e,t,n),a=I("pad",e,t,n),o=I("kernelSize",e,t,n);return[r.avgPool3d(I("x",e,t,n),[o[1],o[2],o[3]],[s[1],s[2],s[3]],a)]}case"MaxPool3D":{let s=I("strides",e,t,n),a=I("pad",e,t,n),o=I("kernelSize",e,t,n);return[r.maxPool3d(I("x",e,t,n),[o[1],o[2],o[3]],[s[1],s[2],s[3]],a)]}case"Dilation2D":{let s=I("strides",e,t,n),a=I("pad",e,t,n),o=I("dilations",e,t,n),i=s[1],u=s[2],c=o[1],l=o[2];return[r.dilation2d(I("x",e,t,n),I("filter",e,t,n),[i,u],a,[c,l],"NHWC")]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},Ij=(e,t,n,r=un)=>{switch(e.op){case"Fill":{let s=I("shape",e,t,n),a=I("dtype",e,t,n),o=I("value",e,t,n);return[r.fill(s,o,a)]}case"LinSpace":{let s=I("start",e,t,n),a=I("stop",e,t,n),o=I("num",e,t,n);return[r.linspace(s,a,o)]}case"Multinomial":{let s=I("logits",e,t,n),a=I("numSamples",e,t,n),o=I("seed",e,t,n);return[r.multinomial(s,a,o)]}case"OneHot":{let s=I("indices",e,t,n),a=I("depth",e,t,n),o=I("onValue",e,t,n),i=I("offValue",e,t,n),u=I("dtype",e,t,n);return[r.oneHot(s,a,o,i,u)]}case"Ones":return[r.ones(I("shape",e,t,n),I("dtype",e,t,n))];case"OnesLike":return[r.onesLike(I("x",e,t,n))];case"RandomStandardNormal":return[r.randomStandardNormal(I("shape",e,t,n),I("dtype",e,t,n),I("seed",e,t,n))];case"RandomUniform":return[r.randomUniform(I("shape",e,t,n),I("minval",e,t,n),I("maxval",e,t,n),I("dtype",e,t,n))];case"RandomUniformInt":return[r.randomUniformInt(I("shape",e,t,n),I("minval",e,t,n),I("maxval",e,t,n),I("seed",e,t,n))];case"Range":{let s=I("start",e,t,n),a=I("stop",e,t,n),o=I("step",e,t,n);return[r.range(s,a,o,I("dtype",e,t,n))]}case"TruncatedNormal":{let s=I("shape",e,t,n),a=I("mean",e,t,n),o=I("stdDev",e,t,n),i=I("seed",e,t,n);return[r.truncatedNormal(s,a,o,I("dtype",e,t,n),i)]}case"Zeros":return[r.zeros(I("shape",e,t,n),I("dtype",e,t,n))];case"ZerosLike":return[r.zerosLike(I("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};function Sv(e,t,n){let r=I("boxes",e,t,n),s=I("scores",e,t,n),a=I("maxOutputSize",e,t,n),o=I("iouThreshold",e,t,n),i=I("scoreThreshold",e,t,n),u=I("softNmsSigma",e,t,n);return{boxes:r,scores:s,maxOutputSize:a,iouThreshold:o,scoreThreshold:i,softNmsSigma:u}}var kj=async(e,t,n,r,s=un)=>{switch(e.op){case"NonMaxSuppressionV5":{let{boxes:a,scores:o,maxOutputSize:i,iouThreshold:u,scoreThreshold:c,softNmsSigma:l}=Sv(e,t,n),p=await s.image.nonMaxSuppressionWithScoreAsync(a,o,i,u,c,l);return[p.selectedIndices,p.selectedScores]}case"NonMaxSuppressionV4":{let{boxes:a,scores:o,maxOutputSize:i,iouThreshold:u,scoreThreshold:c}=Sv(e,t,n),l=I("padToMaxOutputSize",e,t,n),p=await s.image.nonMaxSuppressionPaddedAsync(a,o,i,u,c,l);return[p.selectedIndices,p.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{let{boxes:a,scores:o,maxOutputSize:i,iouThreshold:u,scoreThreshold:c}=Sv(e,t,n);return[await s.image.nonMaxSuppressionAsync(a,o,i,u,c)]}case"Where":{let a=s.cast(I("condition",e,t,n),"bool"),o=[await s.whereAsync(a)];return a.dispose(),o}case"ListDiff":return s.setdiff1dAsync(I("x",e,t,n),I("y",e,t,n));default:throw TypeError(`Node type ${e.op} is not implemented`)}},Sj=(e,t,n,r=un)=>{switch(e.op){case"LowerBound":{let s=I("sortedSequence",e,t,n),a=I("values",e,t,n);return[r.lowerBound(s,a)]}case"TopKV2":{let s=I("x",e,t,n),a=I("k",e,t,n),o=I("sorted",e,t,n),i=r.topk(s,a,o);return[i.values,i.indices]}case"UpperBound":{let s=I("sortedSequence",e,t,n),a=I("values",e,t,n);return[r.upperBound(s,a)]}case"Unique":{let s=I("x",e,t,n),a=r.unique(s);return[a.values,a.indices]}case"UniqueV2":{let s=I("x",e,t,n),a=I("axis",e,t,n),o=r.unique(s,a);return[o.values,o.indices]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},Cj=(e,t,n,r=un)=>{switch(e.op){case"Const":return t[e.name];case"PlaceholderWithDefault":let s=I("default",e,t,n);return[pn(e.name,t,n)||s];case"Placeholder":return[pn(e.name,t,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{let l=I("x",e,t,n);return[As(l)]}case"IdentityN":return I("x",e,t,n).map(l=>As(l));case"Snapshot":let a=I("x",e,t,n);return[As(a)];case"Shape":return[r.tensor1d(I("x",e,t,n).shape,"int32")];case"ShapeN":return I("x",e,t,n).map(l=>r.tensor1d(l.shape));case"Size":return[r.scalar(I("x",e,t,n).size,"int32")];case"Rank":return[r.scalar(I("x",e,t,n).rank,"int32")];case"NoOp":return[r.scalar(1)];case"Print":let o=I("x",e,t,n),i=I("data",e,t,n),u=I("message",e,t,n),c=I("summarize",e,t,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(u);for(let l=0;l<i.length;l++)console.log(Array.prototype.slice.call(i[l].dataSync()).slice(0,c));return[o];default:throw TypeError(`Node type ${e.op} is not implemented`)}},Tj=class{get id(){return this.handle.id}constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=xe(0),this.tensorMap=new Map,qt(this.handle)}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return xe(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);let n=await e.data();return this.tensorMap.forEach(r=>r.dispose()),this.tensorMap.clear(),O(()=>{let r=dt(t),s=n.length,a=r.length;w.assert(s===a,()=>`The number of elements doesn't match, keys has ${s} elements, the values has ${a} elements.`);for(let o=0;o<s;o++){let i=n[o],u=r[o];qt(u),this.tensorMap.set(i,u)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);let n=await e.data();return O(()=>{let r=[];for(let s=0;s<n.length;s++){let a=n[s],o=this.findWithDefault(a,t);r.push(o)}return Rt(r)})}findWithDefault(e,t){let n=this.tensorMap.get(e);return n??t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}},Nj=async(e,t,n,r)=>{switch(e.op){case"HashTable":case"HashTableV2":{let s=r.getHashTableHandleByName(e.name);if(s!=null)return[s];{let a=I("keyDType",e,t,n),o=I("valueDType",e,t,n),i=new Tj(a,o);return r.addHashTable(e.name,i),[i.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{let s=I("tableHandle",e,t,n,r),a=I("keys",e,t,n),o=I("values",e,t,n);return[await r.getHashTableById(s.id).import(a,o)]}case"LookupTableFind":case"LookupTableFindV2":{let s=I("tableHandle",e,t,n,r),a=I("keys",e,t,n),o=I("defaultValue",e,t,n);return[await r.getHashTableById(s.id).find(a,o)]}case"LookupTableSize":case"LookupTableSizeV2":{let s=I("tableHandle",e,t,n,r);return[r.getHashTableById(s.id).tensorSize()]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},_j=(e,t,n,r=un)=>{switch(e.op){case"ResizeBilinear":{let s=I("images",e,t,n),a=I("size",e,t,n),o=I("alignCorners",e,t,n),i=I("halfPixelCenters",e,t,n);return[r.image.resizeBilinear(s,[a[0],a[1]],o,i)]}case"ResizeNearestNeighbor":{let s=I("images",e,t,n),a=I("size",e,t,n),o=I("alignCorners",e,t,n),i=I("halfPixelCenters",e,t,n);return[r.image.resizeNearestNeighbor(s,[a[0],a[1]],o,i)]}case"CropAndResize":{let s=I("image",e,t,n),a=I("boxes",e,t,n),o=I("boxInd",e,t,n),i=I("cropSize",e,t,n),u=I("method",e,t,n),c=I("extrapolationValue",e,t,n);return[r.image.cropAndResize(s,a,o,i,u,c)]}case"ImageProjectiveTransformV3":{let s=I("images",e,t,n),a=I("transforms",e,t,n),o=I("outputShape",e,t,n),i=I("fillValue",e,t,n),u=I("interpolation",e,t,n),c=I("fillMode",e,t,n);return[r.image.transform(s,a,u.toLowerCase(),c.toLowerCase(),i,o)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},Ej=(e,t,n,r=un)=>{switch(e.op){case"Equal":return[r.equal(I("a",e,t,n),I("b",e,t,n))];case"NotEqual":return[r.notEqual(I("a",e,t,n),I("b",e,t,n))];case"Greater":return[r.greater(I("a",e,t,n),I("b",e,t,n))];case"GreaterEqual":return[r.greaterEqual(I("a",e,t,n),I("b",e,t,n))];case"Less":return[r.less(I("a",e,t,n),I("b",e,t,n))];case"LessEqual":return[r.lessEqual(I("a",e,t,n),I("b",e,t,n))];case"LogicalAnd":return[r.logicalAnd(I("a",e,t,n),I("b",e,t,n))];case"LogicalNot":return[r.logicalNot(I("a",e,t,n))];case"LogicalOr":return[r.logicalOr(I("a",e,t,n),I("b",e,t,n))];case"Select":case"SelectV2":return[r.where(I("condition",e,t,n),I("a",e,t,n),I("b",e,t,n))];case"BitwiseAnd":return[r.bitwiseAnd(I("a",e,t,n),I("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},Aj=(e,t,n,r=un)=>{switch(e.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[r.matMul(I("a",e,t,n),I("b",e,t,n),I("transposeA",e,t,n),I("transposeB",e,t,n))];case"Einsum":return[r.einsum(I("equation",e,t,n),...I("tensors",e,t,n))];case"Transpose":return[r.transpose(I("x",e,t,n),I("perm",e,t,n))];case"_FusedMatMul":let[s,a]=I("fusedOps",e,t,n),o=s==="biasadd",i=a==="prelu",u=I("numArgs",e,t,n),c=I("leakyreluAlpha",e,t,n);if(o){if(i&&u!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!i&&u!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}let[l,p]=I("args",e,t,n);return[r.fused.matMul({a:I("a",e,t,n),b:I("b",e,t,n),transposeA:I("transposeA",e,t,n),transposeB:I("transposeB",e,t,n),bias:l,activation:a,preluActivationWeights:p,leakyreluAlpha:c})];case"MatrixBandPart":return[r.linalg.bandPart(I("a",e,t,n),I("numLower",e,t,n),I("numUpper",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},Dj=(e,t,n,r=un)=>{switch(e.op){case"EuclideanNorm":return[r.euclideanNorm(I("x",e,t,n),I("axis",e,t,n),I("keepDims",e,t,n))];case"FusedBatchNorm":case"FusedBatchNormV2":return[r.batchNorm(I("x",e,t,n),I("mean",e,t,n),I("variance",e,t,n),I("offset",e,t,n),I("scale",e,t,n),I("epsilon",e,t,n))];case"FusedBatchNormV3":return[r.batchNorm(I("x",e,t,n),I("mean",e,t,n),I("variance",e,t,n),I("offset",e,t,n),I("scale",e,t,n),I("epsilon",e,t,n))];case"LRN":return[r.localResponseNormalization(I("x",e,t,n),I("radius",e,t,n),I("bias",e,t,n),I("alpha",e,t,n),I("beta",e,t,n))];case"Softmax":return[r.softmax(I("x",e,t,n))];case"LogSoftmax":return[r.logSoftmax(I("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},$j=(e,t,n,r=un)=>{switch(e.op){case"RaggedGather":{let{outputNestedSplits:s,outputDenseValues:a}=r.raggedGather(I("paramsNestedSplits",e,t,n),I("paramsDenseValues",e,t,n),I("indices",e,t,n),I("outputRaggedRank",e,t,n));return s.concat(a)}case"RaggedRange":{let{rtNestedSplits:s,rtDenseValues:a}=r.raggedRange(I("starts",e,t,n),I("limits",e,t,n),I("splits",e,t,n));return[s,a]}case"RaggedTensorToTensor":return[r.raggedTensorToTensor(I("shape",e,t,n),I("values",e,t,n),I("defaultValue",e,t,n),I("rowPartitionTensors",e,t,n),I("rowPartitionTypes",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},Fj=(e,t,n,r=un)=>{switch(e.op){case"Max":{let i=I("axis",e,t,n),u=I("keepDims",e,t,n);return[r.max(I("x",e,t,n),i,u)]}case"Mean":{let i=I("axis",e,t,n),u=I("keepDims",e,t,n);return[r.mean(I("x",e,t,n),i,u)]}case"Min":{let i=I("axis",e,t,n),u=I("keepDims",e,t,n);return[r.min(I("x",e,t,n),i,u)]}case"Sum":{let i=I("axis",e,t,n),u=I("keepDims",e,t,n);return[r.sum(I("x",e,t,n),i,u)]}case"All":{let i=I("axis",e,t,n),u=I("keepDims",e,t,n);return[r.all(I("x",e,t,n),i,u)]}case"Any":{let i=I("axis",e,t,n),u=I("keepDims",e,t,n);return[r.any(I("x",e,t,n),i,u)]}case"ArgMax":{let i=I("axis",e,t,n);return[r.argMax(I("x",e,t,n),i)]}case"ArgMin":{let i=I("axis",e,t,n);return[r.argMin(I("x",e,t,n),i)]}case"Prod":{let i=I("axis",e,t,n),u=I("keepDims",e,t,n);return[r.prod(I("x",e,t,n),i,u)]}case"Cumprod":{let i=I("axis",e,t,n),u=I("exclusive",e,t,n),c=I("reverse",e,t,n);return[r.cumprod(I("x",e,t,n),i,u,c)]}case"Cumsum":{let i=I("axis",e,t,n),u=I("exclusive",e,t,n),c=I("reverse",e,t,n);return[r.cumsum(I("x",e,t,n),i,u,c)]}case"Bincount":let s=I("x",e,t,n),a=I("weights",e,t,n),o=I("size",e,t,n);return[r.bincount(s,a,o)];case"DenseBincount":{let i=I("x",e,t,n),u=I("weights",e,t,n),c=I("size",e,t,n),l=I("binaryOutput",e,t,n);return[r.denseBincount(i,u,c,l)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},Rj=(e,t,n,r=un)=>{switch(e.op){case"ConcatV2":case"Concat":{let s=I("n",e,t,n),a=I("axis",e,t,n),o=I("tensors",e,t,n);return o=o.slice(0,s),[r.concat(o,a)]}case"Gather":{let s=I("x",e,t,n),a=I("indices",e,t,n);return[r.gather(s,r.cast(a,"int32"),0)]}case"GatherV2":{let s=I("axis",e,t,n),a=I("batchDims",e,t,n),o=I("x",e,t,n),i=I("indices",e,t,n);return[r.gather(o,r.cast(i,"int32"),s,a)]}case"Reverse":{let s=I("dims",e,t,n),a=[];for(let i=0;i<s.length;i++)s[i]&&a.push(i);let o=I("x",e,t,n);return[r.reverse(o,a)]}case"ReverseV2":{let s=I("axis",e,t,n),a=I("x",e,t,n);return[r.reverse(a,s)]}case"Slice":{let s=I("begin",e,t,n),a=I("size",e,t,n);return[r.slice(I("x",e,t,n),s,a)]}case"StridedSlice":{let s=I("begin",e,t,n),a=I("end",e,t,n),o=I("strides",e,t,n),i=I("beginMask",e,t,n),u=I("endMask",e,t,n),c=I("ellipsisMask",e,t,n),l=I("newAxisMask",e,t,n),p=I("shrinkAxisMask",e,t,n),d=I("x",e,t,n);return[r.stridedSlice(d,s,a,o,i,u,c,l,p)]}case"Pack":return O(()=>{let s=I("axis",e,t,n),a=I("tensors",e,t,n),o=a[0].shape,i=r.squeeze(a[0]).shape,u=a.map(c=>{let l=w.arraysEqual(c.shape,o);if(!l&&!w.arraysEqual(r.squeeze(c).shape,i))throw new Error("the input tensors shape does not match");return l?c:r.reshape(c,o)});return[r.stack(u,s)]});case"Unpack":{let s=I("axis",e,t,n),a=I("tensor",e,t,n);return r.unstack(a,s)}case"Tile":{let s=I("reps",e,t,n);return[r.tile(I("x",e,t,n),s)]}case"Split":case"SplitV":{let s=I("axis",e,t,n),a=I("numOrSizeSplits",e,t,n),o=I("x",e,t,n);return r.split(o,a,s)}case"ScatterNd":{let s=I("indices",e,t,n),a=I("values",e,t,n),o=I("shape",e,t,n);return[r.scatterND(s,a,o)]}case"GatherNd":{let s=I("x",e,t,n),a=I("indices",e,t,n);return[r.gatherND(s,a)]}case"SparseToDense":{let s=I("sparseIndices",e,t,n),a=I("outputShape",e,t,n),o=I("sparseValues",e,t,n),i=I("defaultValue",e,t,n);return[r.sparseToDense(s,o,a,o.dtype===i.dtype?i:r.cast(i,o.dtype))]}case"TensorScatterUpdate":{let s=I("indices",e,t,n),a=I("values",e,t,n),o=I("tensor",e,t,n);return[r.tensorScatterUpdate(o,s,a)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},Pj=(e,t,n,r=un)=>{switch(e.op){case"SparseFillEmptyRows":{let{outputIndices:s,outputValues:a,emptyRowIndicator:o,reverseIndexMap:i}=r.sparse.sparseFillEmptyRows(I("indices",e,t,n),I("values",e,t,n),I("denseShape",e,t,n),I("defaultValue",e,t,n));return[s,a,o,i]}case"SparseReshape":{let{outputIndices:s,outputShape:a}=r.sparse.sparseReshape(I("inputIndices",e,t,n),I("inputShape",e,t,n),I("newShape",e,t,n));return[s,a]}case"SparseSegmentMean":return[r.sparse.sparseSegmentMean(I("data",e,t,n),I("indices",e,t,n),I("segmentIds",e,t,n))];case"SparseSegmentSum":return[r.sparse.sparseSegmentSum(I("data",e,t,n),I("indices",e,t,n),I("segmentIds",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},Oj=(e,t,n,r=un)=>{switch(e.op){case"FFT":return[r.fft(I("x",e,t,n))];case"IFFT":return[r.ifft(I("x",e,t,n))];case"RFFT":return[r.rfft(I("x",e,t,n))];case"IRFFT":return[r.irfft(I("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},Mj=(e,t,n,r=un)=>{switch(e.op){case"StaticRegexReplace":return[r.string.staticRegexReplace(I("input",e,t,n),I("pattern",e,t,n),I("rewrite",e,t,n),I("replaceGlobal",e,t,n))];case"StringNGrams":{let{nGrams:s,nGramsSplits:a}=r.string.stringNGrams(I("data",e,t,n),I("dataSplits",e,t,n),I("separator",e,t,n),I("nGramWidths",e,t,n),I("leftPad",e,t,n),I("rightPad",e,t,n),I("padWidth",e,t,n),I("preserveShortSequences",e,t,n));return[s,a]}case"StringSplit":{let{indices:s,values:a,shape:o}=r.string.stringSplit(I("input",e,t,n),I("delimiter",e,t,n),I("skipEmpty",e,t,n));return[s,a,o]}case"StringToHashBucketFast":return[r.string.stringToHashBucketFast(I("input",e,t,n),I("numBuckets",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},Lj=(e,t,n,r=un)=>{switch(e.op){case"Cast":return[r.cast(I("x",e,t,n),I("dtype",e,t,n))];case"ExpandDims":{let s=I("axis",e,t,n);return[r.expandDims(I("x",e,t,n),s)]}case"Squeeze":{let s=I("axis",e,t,n);return[r.squeeze(I("x",e,t,n),s)]}case"Reshape":return[r.reshape(I("x",e,t,n),I("shape",e,t,n))];case"EnsureShape":return[r.ensureShape(I("x",e,t,n),I("shape",e,t,n))];case"MirrorPad":return[r.mirrorPad(I("x",e,t,n),I("padding",e,t,n),I("mode",e,t,n))];case"PadV2":case"Pad":return[r.pad(I("x",e,t,n),I("padding",e,t,n),I("constantValue",e,t,n))];case"SpaceToBatchND":{let s=I("blockShape",e,t,n),a=I("paddings",e,t,n);return[r.spaceToBatchND(I("x",e,t,n),s,a)]}case"BatchToSpaceND":{let s=I("blockShape",e,t,n),a=I("crops",e,t,n);return[r.batchToSpaceND(I("x",e,t,n),s,a)]}case"DepthToSpace":{let s=I("blockSize",e,t,n),a=I("dataFormat",e,t,n).toUpperCase();return[r.depthToSpace(I("x",e,t,n),s,a)]}case"BroadcastTo":return[r.broadcastTo(I("x",e,t,n),I("shape",e,t,n))];case"BroadcastArgs":return[r.broadcastArgs(I("s0",e,t,n),I("s1",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};function o1(e,t,n,r,s=O){let a=((o,i,u)=>{switch(o.category){case"arithmetic":return s(()=>hj(o,i,u));case"basic_math":return s(()=>fj(o,i,u));case"control":return xj(o,i,u);case"convolution":return s(()=>wj(o,i,u));case"creation":return s(()=>Ij(o,i,u));case"dynamic":return kj(o,i,u);case"evaluation":return s(()=>Sj(o,i,u));case"image":return s(()=>_j(o,i,u));case"graph":return s(()=>Cj(o,i,u));case"logical":return s(()=>Ej(o,i,u));case"matrices":return s(()=>Aj(o,i,u));case"normalization":return s(()=>Dj(o,i,u));case"ragged":return s(()=>$j(o,i,u));case"reduction":return s(()=>Fj(o,i,u));case"slice_join":return s(()=>Rj(o,i,u));case"sparse":return s(()=>Pj(o,i,u));case"spectral":return s(()=>Oj(o,i,u));case"string":return s(()=>Mj(o,i,u));case"transformation":return s(()=>Lj(o,i,u));case"hash_table":return Nj(o,i,u,r);case"custom":let c=z_(o.op);if(c&&c.customExecutor)return c.customExecutor(new pj(o,i,u));throw TypeError(`Custom op ${o.op} is not registered.`);default:throw TypeError(`Unknown op '${o.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(e,t,n);return w.isPromise(a)?a.then(o=>[].concat(o)):[].concat(a)}var i1=class{constructor(e={},t={},n={},r={},s){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=n,this.functionMap=r,this.parseNodeNameCache=s,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){let e=[];for(let t=0;t<this.contexts.length-1;t++){let n=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(n))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(t=>t.id===0&&t.iterationId===0?"":`${t.frameName}-${t.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;let e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(let t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(let t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}};function u1(e,t,n,r){let s=new Set,a=[],o=null,i=null,u=new Set,c=new Set(Object.keys(e).map(d=>Jn(d)[0]));r=r||[];let l=new Set(r.map(d=>Jn(d.name)[0])),p=[...t];for(;p.length>0;){let d=p.pop();if((to(d)||jj(d)||qj(d))&&o==null&&(o=d,i=o.children.map(h=>h.name).filter(h=>s.has(h))),s.add(d.name),n[d.name]==null&&!c.has(d.name)&&!l.has(d.name)){if(d.inputs.length===0){a.push(d.name);continue}d.inputs.forEach(h=>{u.has(h.name)||(u.add(h.name),p.push(h))})}}return{inputs:e,outputs:t,usedNodes:s,missingInputs:a,dynamicNode:o,syncInputs:i}}function zj(e,t){let{usedNodes:n,inputs:r}=t,s=Object.keys(r).map(m=>Jn(m)[0]).map(m=>e.nodes[m]),a=e.initNodes||[],o=m=>n.has(typeof m=="string"?m:m.name);function i(m){return[...new Map(m.map(b=>[b.name,b])).values()]}let u=i([...s,...e.weights,...a]).filter(o),c=i([...u,...Object.values(e.nodes)]).filter(o),l=new Map(c.map(m=>[m.name,m])),p={};for(let m of c){p[m.name]=p[m.name]||0;for(let b of m.children)o(b)||(p[b.name]=Number.POSITIVE_INFINITY),p[b.name]=(p[b.name]||0)+1}let d=Object.entries(p).filter(([,m])=>m===0).map(([m])=>m),h=[...d];for(;d.length>0;){let m=d.pop(),b=l.get(m);for(let v of b.children.filter(o))--p[v.name]===0&&(h.push(v.name),d.push(v.name))}let f=h.map(m=>l.get(m)),g=Bj(f,u);return Wj(g,u),g}function Bj(e,t){let n=new Map(e.map(o=>[o.name,o])),r=t.map(o=>o.name),s=new Set(r);for(;r.length>0;){let o=r.pop(),i=n.get(o);for(let u of i.children)!n.has(u.name)||s.has(u.name)||(s.add(u.name),r.push(u.name))}return e.filter(o=>s.has(o.name))}var Uh=class extends Error{constructor(e){super(`NodesExecutionOrderError: ${e}`)}};function Wj(e,t){let n=new Map(e.map((i,u)=>[i.name,u])),r=new Set(t.map(i=>i.name)),s=i=>r.has(typeof i=="string"?i:i.name),a=new Set(e.map(i=>i.name)),o=i=>a.has(typeof i=="string"?i:i.name);for(let i of e){for(let u of i.children.filter(o)){if(!n.has(u.name))throw new Uh(`Child ${u.name} of node ${i.name} is unreachable.`);if(n.get(i.name)>n.get(u.name))throw new Uh(`Node ${i.name} is scheduled to run after its child ${u.name}.`)}if(!s(i))for(let u of i.inputs){if(!n.has(u.name))throw new Uh(`Input ${u.name} of node ${i.name} is unreachable.`);if(n.get(u.name)>n.get(i.name))throw new Uh(`Node ${i.name} is scheduled to run before its input ${u.name}.`)}}}function Vj(e){let t=new Map(e.map((i,u)=>[i.name,u])),n=Number.MAX_SAFE_INTEGER,r=e.map((i,u)=>to(i)?n:u),s=i=>{let u=r[t.get(i.name)];return u??-1},a=e.map((i,u)=>i.children.map(s).reduce((c,l)=>Math.max(c,l),r[u])),o=new Map;for(let i=0;i<e.length;++i){let u=a[i];if(u===n)continue;let c=e[i],l=e[u];o.has(l.name)||o.set(l.name,[]),o.get(l.name).push(c)}return o}var Uj=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),Gj=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),Hj=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function to(e){return Uj.has(e.op)}function jj(e){return Gj.has(e.op)}function qj(e){return Hj.has(e.op)}var lx=class{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){let t=Object.keys(e).map(n=>e[n].map(r=>r.id));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{let t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t})}get functions(){return Object.keys(this._functions).reduce((e,t)=>(e[t]=this._functions[t].signature,e),{})}constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,e.functions!=null&&Object.keys(e.functions).forEach(n=>{this._functionExecutorMap[n]=new lx(e.functions[n],this)})}getCompilationKey(e,t){let n=e.map(s=>s.name).sort(),r=t.map(s=>s.name).sort();return n.join(this.SEPARATOR)+"--"+r.join(this.SEPARATOR)}compile(e,t){let n=u1(e,t,this.weightMap,this._initNodes),{missingInputs:r,dynamicNode:s,syncInputs:a}=n;if(s!=null)throw new Error(`This execution contains the node '${s.name}', which has the dynamic op '${s.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${a}]`);if(r.length>0){let u=t.map(l=>l.name),c=Object.keys(e);throw new Error(`Cannot compute the outputs [${u}] from the provided inputs [${c}]. Missing the following inputs: [${r}]`)}let o=zj(this.graph,n),i=Vj(o);return{orderedNodes:o,nodeLiveUntilMap:i}}cloneAndKeepTensor(e){if(e==null)return null;let t=e.clone();return qt(t),t}cloneTensorList(e){return e?e.map(n=>this.cloneAndKeepTensor(n)):null}cloneTensorMap(e){return Object.fromEntries(Object.entries(e).map(([t,n])=>[t,this.cloneTensorList(n)]))}execute(e,t){this.disposeIntermediateTensors(),e=this.mapInputs(e);let n=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);let r=n.map(p=>this.graph.nodes[Jn(p)[0]]),s=t.map(p=>Jn(p)[0]),a=new Set(s),o=s.map(p=>this.graph.nodes[p]);o.length===0&&(o=this._outputs);let i=this.getCompilationKey(r,o),u=this.compiledMap.get(i);u==null&&(u=this.compile(e,o),this.compiledMap.set(i,u));try{this.keepIntermediateTensors=G().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(p){this.keepIntermediateTensors=!1,console.warn(p.message)}let c={},l={};return O(()=>{let p=new i1(this.weightMap,c,l,this.functionExecutorMap,this.parseNodeNameCache),d=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(e).forEach(m=>{let[b,v]=Jn(m,p),y=[];y[v]=e[m],d[b]=y,this.keepIntermediateTensors&&(this.clonedTensorsMap[b]=this.cloneTensorList(y))});let h=this.getFrozenTensorIds(d),{orderedNodes:f,nodeLiveUntilMap:g}=u;for(let m of f){if(d[m.name])continue;let b=o1(m,d,p,this._resourceManager);if(w.isPromise(b))throw new Error(`The execution of the op '${m.op}' returned a promise. Please use model.executeAsync() instead.`);d[m.name]=b,this.keepIntermediateTensors&&(this.clonedTensorsMap[m.name]=this.cloneTensorList(b)),this.checkTensorForDisposalWithNodeLiveUntilInfo(m,d,p,h,a,g.get(m.name))}return this.parent==null&&p.dispose(h),t.map(m=>pn(m,d,p))})}getFrozenTensorIds(e){let t=[].concat.apply([],Object.keys(e).map(n=>e[n]).map(n=>n.map(r=>r.id)));return new Set(t)}checkTensorForDisposal(e,t,n,r,s,a,o){if(!(to(t)||a.has(e))){for(let i of n[e])i!=null&&(o[i.id]=(o[i.id]||0)+t.children.length);for(let i of t.inputs){if(to(i))continue;let u=t1(i.name,n,r);if(u!=null)for(let c of u){if(!c||c.kept||s.has(c.id))continue;let l=o[c.id];l===1?(c.dispose(),delete o[c.id]):l!=null&&o[c.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(e,t,n,r,s,a){function o(i){return to(i)||s.has(i.name)}if(!(to(e)||a==null))for(let i of a){if(o(i))continue;let u=t1(i.name,t,n);for(let c of u)!c||c.kept||r.has(c.id)||c.dispose()}}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(e=>{for(let t of e)t&&!t.isDisposed&&t.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(e,t,n=!1,r={},s={}){this.disposeIntermediateTensors(),n||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepIntermediateTensors=G().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(p){this.keepIntermediateTensors=!1,console.warn(p.message)}let a=new i1(this.weightMap,r,s,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));let o=await this.executeWithControlFlow(e,a,t,n),i=t.map(p=>pn(p,o,a)),u=i.map(p=>p.id),c=Object.keys(e).map(p=>e[p].id),l=new Set([...u,...c,...this.weightIds]);return Object.values(o).forEach(p=>{p.forEach(d=>{d&&!d.isDisposed&&!l.has(d.id)&&d.dispose()})}),this.parent==null&&a.dispose(l),i}async executeFunctionAsync(e,t,n){let r=e.reduce((s,a,o)=>(s[this.inputs[o].name]=a,s),{});return this._executeAsync(r,this.outputNodes,!0,t,n)}async executeWithControlFlow(e,t,n,r){let s=Object.keys(e),a=s.map(y=>this.graph.nodes[Jn(y)[0]]),o=n.map(y=>Jn(y)[0]),i=new Set(o),u=o.map(y=>this.graph.nodes[y]);u.length===0&&(u=this._outputs);let{usedNodes:c,missingInputs:l,dynamicNode:p,syncInputs:d}=u1(e,u,this.weightMap,this._initNodes),h=[...a,...this.graph.weights,...this._initNodes||[]].map(y=>({node:y,contexts:t.currentContext})),f=Object.assign({},this.weightMap);Object.keys(e).forEach(y=>{let[x,k]=Jn(y),S=[];S[k]=e[y],f[x]=S});let g={},m=this.getFrozenTensorIds(f),b={};for(;h.length>0;){let y=this.processStack(a,h,t,f,b,m,i,g,c);await Promise.all(y)}p==null&&!r&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");let v=u.filter(y=>!to(y)&&!pn(y.name,f,t)).map(y=>y.name);if(v.length>0){let y="";throw p!=null&&(y=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${d}]`),new Error(`Cannot compute the outputs [${v}] from the provided inputs [${s}]. Consider providing the following inputs: [${l}]. ${y}`)}return f}processStack(e,t,n,r,s,a,o,i,u){let c=[];for(;t.length>0;){let l=t.pop();n.currentContext=l.contexts;let p="";if(l.node.op==="Enter"&&I("isConstant",l.node,r,n)&&([p]=Es(l.node.name,n)),r[l.node.name]==null){let d=o1(l.node,r,n,this._resourceManager);p||([p]=Es(l.node.name,n));let h=n.currentContext;w.isPromise(d)?c.push(d.then(f=>(r[p]=f,this.keepIntermediateTensors&&(this.clonedTensorsMap[p]=this.cloneTensorList(f)),n.currentContext=h,this.checkTensorForDisposal(p,l.node,r,n,a,o,i),this.processChildNodes(l.node,t,n,r,s,u),f))):(r[p]=d,this.keepIntermediateTensors&&(this.clonedTensorsMap[p]=this.cloneTensorList(d)),this.checkTensorForDisposal(p,l.node,r,n,a,o,i),this.processChildNodes(l.node,t,n,r,s,u))}else this.processChildNodes(l.node,t,n,r,s,u)}return c}processChildNodes(e,t,n,r,s,a){e.children.forEach(o=>{let[i]=Es(o.name,n);s[i]||!a.has(o.name)||(o.op==="Merge"?o.inputNames.some(u=>!!pn(u,r,n))&&(s[i]=!0,t.push({contexts:n.currentContext,node:o})):o.inputNames.every(u=>!!pn(u,r,n))&&(s[i]=!0,t.push({contexts:n.currentContext,node:o})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(t=>t.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(t=>{let n=e[t],[r]=Jn(t),s=this.graph.nodes[r];if(s.attrParams.shape&&s.attrParams.shape.value){let a=s.attrParams.shape.value,o=a.length===n.shape.length&&n.shape.every((i,u)=>a[u]===-1||a[u]===i);w.assert(o,()=>`The shape of dict['${s.name}'] provided in model.execute(dict) must be [${a}], but was [${n.shape}]`)}s.attrParams.dtype&&s.attrParams.dtype.value&&w.assert(n.dtype===s.attrParams.dtype.value,()=>`The dtype of dict['${s.name}'] provided in model.execute(dict) must be ${s.attrParams.dtype.value}, but was ${n.dtype}`)})}mapInputs(e){var t,n;let r={};for(let s in e){let a=(n=(t=this._signature)===null||t===void 0?void 0:t.inputs)===null||n===void 0?void 0:n[s];a!=null?r[a.name]=e[s]:r[s]=e[s]}return r}checkInputs(e){let t=Object.keys(e).filter(n=>{let[r]=Jn(n);return this.graph.nodes[r]==null});if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map(t=>{var n,r;let s=(r=(n=this._signature)===null||n===void 0?void 0:n.outputs)===null||r===void 0?void 0:r[t];return s!=null?s.name:t},{})}checkOutputs(e){e.forEach(t=>{let[n]=Jn(t);if(!this.graph.nodes[n])throw new Error(`The output '${t}' is not found in the graph`)})}},Kj=class{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(let e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(let e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}},Xj="?tfjs-format=file",Yj="model.json",Fk=class{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(e,t={},n=Kt){this.modelUrl=e,this.loadOptions=t,this.version="n/a",this.io=n,t==null&&(this.loadOptions={}),this.resourceManager=new Kj}findIOHandler(){let e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{let t=this.io.getLoadHandlers(e,this.loadOptions);if(t.length===0)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let e=this.handler.load();return w.isPromise(e)?e.then(t=>this.loadSync(t)):this.loadSync(e)}loadSync(e){this.artifacts=e;let t=this.artifacts.modelTopology,n=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){let s=this.artifacts.userDefinedMetadata;s.signature!=null&&(n=s.signature),s.structuredOutputKeys!=null&&(this.structuredOutputKeys=s.structuredOutputKeys)}this.signature=n,this.version=`${t.versions.producer}.${t.versions.minConsumer}`;let r=this.io.decodeWeights(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new lx(n1.Instance.transformGraph(t,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(r),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){let s=n1.Instance.transformGraph(e.modelInitializer);this.initializer=new lx(s),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if(typeof e=="string"){let n=this.io.getSaveHandlers(e);if(n.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(n.length>1)throw new Error(`Found more than one (${n.length}) save handlers for URL '${e}'`);e=n[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){let t=e instanceof Te?[e]:e,n={};return t.forEach((r,s)=>n[this.structuredOutputKeys[s]]=r),n}return e}predict(e,t){let n=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(n)}async predictAsync(e,t){let n=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(n)}normalizeInputs(e){var t;if(!(e instanceof Te)&&!Array.isArray(e)){let s=(t=this.signature)===null||t===void 0?void 0:t.inputs;if(s!=null)for(let a in s){let o=s[a];o.resourceId!=null&&(e[a]=this.resourceIdToCapturedInput[o.resourceId])}return e}e=Array.isArray(e)?e:[e];let n=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+n!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-n} non-resource placeholders, while there are ${e.length} input tensors provided.`);let r=0;return this.inputNodes.reduce((s,a)=>{var o,i,u;let c=(u=(i=(o=this.signature)===null||o===void 0?void 0:o.inputs)===null||i===void 0?void 0:i[a])===null||u===void 0?void 0:u.resourceId;return c!=null?s[a]=this.resourceIdToCapturedInput[c]:s[a]=e[r++],s},{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){let t=this.initializerSignature.outputs,n=Object.keys(t);for(let r=0;r<n.length;r++){let s=n[r],a=t[s];this.resourceIdToCapturedInput[a.resourceId]=e[r]}}}execute(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let n=this.executor.execute(e,t);return n.length>1?n:n[0]}async executeAsync(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let n=await this.executor.executeAsync(e,t);return n.length>1?n:n[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,n)=>(t[n]=[e[n]],t),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&_e(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}};async function Zj(e,t={},n=Kt){if(e==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");t==null&&(t={}),t.fromTFHub&&typeof e=="string"&&(e=Qj(e));let r=new Fk(e,t,n);return await r.load(),r}function Jj(e){if(e==null)throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model");let t;if(e instanceof Array){let[r,s]=e;if(!r)throw new Error("modelJSON must be the first element of the array");if(!s||!(s instanceof ArrayBuffer))throw new Error("An ArrayBuffer of weights must be the second element of the array");if(!("modelTopology"in r))throw new Error("Model JSON is missing 'modelTopology'");if(!("weightsManifest"in r))throw new Error("Model JSON is missing 'weightsManifest'");let a=Kt.getWeightSpecs(r.weightsManifest),o=Kt.getModelArtifactsForJSONSync(r,a,s);t=Kt.fromMemorySync(o)}else if("load"in e)t=e;else if("modelTopology"in e&&"weightSpecs"in e&&"weightData"in e)t=Kt.fromMemorySync(e);else throw new Error("Unknown model format");let n=new Fk(t);return n.load(),n}function Qj(e){return e.endsWith("/")||(e=e+"/"),`${e}${Yj}${Xj}`}var eq="4.9.0",i2={};Ee(i2,{CSVDataset:()=>g2,Dataset:()=>vl,FileDataSource:()=>k2,TextLineDataset:()=>m2,URLDataSource:()=>S2,array:()=>kq,csv:()=>Rq,func:()=>Pq,generator:()=>Oq,microphone:()=>Lq,version_data:()=>zq,webcam:()=>Mq,zip:()=>Sq});var tq=ka(Of()),nq=ka(Of());function rq(e,t){return Tf(e,t)}function Tf(e,t,n=new Map,r=new Set){if(e==null)return null;if(typeof Blob=="function"&&e instanceof Blob)return e.slice();if(r.has(e))throw new Error("Circular references are not supported.");if(n.has(e))return n.get(e);let s=t(e);if(s.recurse&&s.value!==null)throw new Error("A deep map function may not return both a value and recurse=true.");if(s.recurse)if(sc(e)){let a=Array.isArray(e)?[]:{};r.add(e);for(let o in e){let i=e[o],u=Tf(i,t,n,r);a[o]=u}return r.delete(e),e.__proto__&&(a.__proto__=e.__proto__),a}else throw new Error(`Can't recurse into non-iterable type: ${e}`);else return n.set(e,s.value),s.value}function sq(e,t=c2){return u2(e,t)}function u2(e,t,n=new Set){let r=e[0];if(n.has(r))throw new Error("Circular references are not supported.");let s=t(e);if(s.recurse&&s.value!==null)throw new Error("A deep zip function may not return both a value and recurse=true.");if(s.recurse)if(sc(r)){let a=Array.isArray(r)?[]:{};n.add(r);for(let o in r){let i=e.map(c=>c[o]),u=u2(i,t,n);a[o]=u}return n.delete(r),a}else throw new Error(`Can't recurse into non-iterable type: ${r}`);else return s.value}function c2(e){return e===null?null:sc(e[0])?{value:null,recurse:!0}:{value:e,recurse:!1}}async function l2(e,t){let n=new Map;Tf(e,t,n);for(let s of Array.from(n.keys())){let a=n.get(s);if(w.isPromise(a)){let o=await a;n.set(s,o)}}return Tf(e,t,n)}function sc(e){let t=!1;if(G().get("IS_BROWSER"))t=e instanceof TextDecoder;else{let{StringDecoder:n}=K1();t=e instanceof n}return e!=null&&!ArrayBuffer.isView(e)&&(Array.isArray(e)||typeof e=="object"&&!(e instanceof Te)&&!(e instanceof Promise)&&!t)}function aq(e){return e==null||oq(e)||Array.isArray(e)||typeof e=="object"&&e instanceof Te||w.isTypedArray(e)}function oq(e){return e===null||typeof e!="object"&&typeof e!="function"}function iq(e){return rq(e,uq)}function uq(e){return e instanceof Te?{value:e.clone(),recurse:!1}:sc(e)?{value:null,recurse:!0}:{value:e,recurse:!1}}var d2=class{constructor(e){if(this.capacity=e,this.begin=0,this.end=0,e==null)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,t){if(e<0)throw new RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=t}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return this.length()===0}push(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(let t of e)this.push(t)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);let e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let t=this.wrap(this.begin+e),n=this.get(t);return this.set(t,this.pop()),n}},Rk=class extends d2{constructor(){super(Rk.INITIAL_CAPACITY)}isFull(){return!1}push(e){super.isFull()&&this.expand(),super.push(e)}unshift(e){super.isFull()&&this.expand(),super.unshift(e)}expand(){let e=this.capacity*2,t=new Array(e),n=this.length();for(let r=0;r<n;r++)t[r]=this.get(this.wrap(this.begin+r));this.data=t,this.capacity=e,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=n}};Rk.INITIAL_CAPACITY=32;function p2(e){return new dq(e)}function Pk(e){return new pq(e)}function cq(e,t){return new h2(e,t)}function lq(e,t=ia.FAIL){return new wq(e,t)}var on=class{async toArray(){let e=[],t=await this.next();for(;!t.done;)e.push(t.value),t=await this.next();return e}async toArrayForTest(){let e=this.prefetch(100),t=[],n=await e.next();for(;!n.done;)t.push(n.value),n=await e.next();return t}async resolveFully(){let e=await this.next();for(;!e.done;)e=await this.next()}async resolveWhile(e){let t=await this.next(),n=e(t.value);for(;!t.done&&n;)t=await this.next(),n=e(t.value)}handleErrors(e){return new vq(this,e)}filter(e){return new bq(this,e)}map(e){return new yq(this,e)}mapAsync(e){return new c1(this,e)}serialMapAsync(e){return new c1(this,e).serial()}flatmap(e){return new xq(this,e)}async forEachAsync(e){return this.map(e).resolveFully()}async serialForEach(e){return this.serialMapAsync(e).resolveWhile(t=>t===!0)}rowMajorBatch(e,t=!0){return new gq(this,e,t)}columnMajorBatch(e,t=!0,n=c2){return this.rowMajorBatch(e,t).map(s=>sq(s,n))}concatenate(e,t){return new h2(p2([this,e]),t)}take(e){return e<0||e==null?this:new mq(this,e)}skip(e){return e<0||e==null?this:new fq(this,e)}prefetch(e){return new f2(this,e)}shuffle(e,t){return new Iq(this,e,t)}serial(){return new hq(this)}},dq=class extends on{constructor(e){super(),this.items=e,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};let e=this.items[this.trav];return this.trav++,{value:iq(e),done:!1}}},pq=class extends on{constructor(e){super(),this.nextFn=e}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(e){throw e.message=`Error thrown while iterating through a dataset: ${e.message}`,e}}},hq=class extends on{constructor(e){super(),this.upstream=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){return this.upstream.next()}},fq=class extends on{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){let e=await this.upstream.next();if(e.done)return e;_e(e.value)}return this.upstream.next()}},mq=class extends on{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}},gq=class extends on{constructor(e,t,n=!0){super(),this.upstream=e,this.batchSize=t,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){let e=[];for(;e.length<this.batchSize;){let t=await this.upstream.next();if(t.done)return this.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(t.value)}return{value:e,done:!1}}},bq=class extends on{constructor(e,t){super(),this.upstream=e,this.predicate=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;){let e=await this.upstream.next();if(e.done||this.predicate(e.value))return e;_e(e.value)}}},yq=class extends on{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Map`}async next(){let e=await this.upstream.next();if(e.done)return{value:null,done:!0};let t=Gr.getTensorsInContainer(e.value),n=this.transform(e.value),r=Gr.getTensorsInContainer(n);for(let s of t)Gr.isTensorInList(s,r)||s.dispose();return{value:n,done:!1}}},vq=class extends on{constructor(e,t){super(),this.upstream=e,this.handler=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(e){if(!this.handler(e))return{value:null,done:!0}}}},c1=class extends on{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){let e=await this.upstream.next();if(e.done)return{value:null,done:!0};let t=Gr.getTensorsInContainer(e.value),n=await this.transform(e.value),r=Gr.getTensorsInContainer(n);for(let s of t)Gr.isTensorInList(s,r)||s.dispose();return{value:n,done:!1}}},Ok=class extends on{constructor(){super(),this.outputQueue=new Rk,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.outputQueue.length()===0;)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}},xq=class extends Ok{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){let e=await this.upstream.next();if(e.done)return!1;let t=Gr.getTensorsInContainer(e.value),n=this.transform(e.value),r=Gr.getTensorsInContainer(n);this.outputQueue.pushAll(n);for(let s of t)Gr.isTensorInList(s,r)||s.dispose();return!0}},h2=class extends on{constructor(e,t){super(),this.baseErrorHandler=t,this.lastRead=null,this.iterator=null,this.moreIterators=e}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(e){if(await e,this.iterator==null){let n=await this.moreIterators.next();if(n.done)return{value:null,done:!0};this.iterator=n.value,this.baseErrorHandler!=null&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}let t=await this.iterator.next();return t.done?(this.iterator=null,this.readFromChain(e)):t}},ia;(function(e){e[e.FAIL=0]="FAIL",e[e.SHORTEST=1]="SHORTEST",e[e.LONGEST=2]="LONGEST"})(ia||(ia={}));var wq=class extends on{constructor(e,t=ia.FAIL){super(),this.iterators=e,this.mismatchMode=t,this.count=0,this.currentPromise=null}summary(){return"{TODO: fill in upstream of zip summaries} -> Zip"}async nextState(e){await e;let t=0,n=0;function r(a){return a instanceof on?{value:a.next().then(i=>(t++,i.done&&n++,i.value)),recurse:!1}:{value:null,recurse:!0}}let s=await l2(this.iterators,r);if(t===n)return{value:null,done:!0};if(n>0)switch(this.mismatchMode){case ia.FAIL:throw new Error(`Zipped streams should have the same length. Mismatched at element ${this.count}.`);case ia.SHORTEST:return{value:null,done:!0};case ia.LONGEST:default:}return this.count++,{value:s,done:!1}}async next(){return this.currentPromise=this.nextState(this.currentPromise),this.currentPromise}},f2=class extends on{constructor(e,t){super(),this.upstream=e,this.bufferSize=t,this.buffer=new d2(t)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){let e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}},Iq=class extends f2{constructor(e,t,n){super(e,t),this.upstream=e,this.windowSize=t,this.upstreamExhausted=!1,this.random=nq.alea(n||w.now().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){let e=this.chooseIndex(),t=await this.buffer.shuffleExcise(e);if(t.done)this.upstreamExhausted=!0;else return this.refill(),t}return{value:null,done:!0}}},vl=class{constructor(){this.size=null}batch(e,t=!0){let n=this;w.assert(e>0,()=>`batchSize needs to be positive, but it is
      ${e}`);let r;return this.size===1/0||this.size==null?r=this.size:t?r=Math.ceil(this.size/e):r=Math.floor(this.size/e),Zn(async()=>(await n.iterator()).columnMajorBatch(e,t,Cq),r)}concatenate(e){let t=this,n;return this.size===1/0||e.size===1/0?n=1/0:this.size!=null&&e.size!=null?n=this.size+e.size:n=null,Zn(async()=>(await t.iterator()).concatenate(await e.iterator()),n)}filter(e){let t=this,n;return this.size===1/0?n=1/0:n=null,Zn(async()=>(await t.iterator()).filter(r=>O(()=>e(r))),n)}async forEachAsync(e){return(await this.iterator()).forEachAsync(e)}map(e){let t=this;return Zn(async()=>(await t.iterator()).map(n=>O(()=>e(n))),this.size)}mapAsync(e){let t=this;return Zn(async()=>(await t.iterator()).mapAsync(e),this.size)}prefetch(e){if(e==null)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");let t=this;return Zn(async()=>(await t.iterator()).prefetch(e),this.size)}repeat(e){let t=this,n;return this.size!=null&&e>0?n=this.size*e:e===0?n=0:this.size!=null&&(e===void 0||e<0)?n=1/0:n=null,Zn(async()=>{let r=Pk(async()=>({value:await t.iterator(),done:!1}));return cq(r.take(e))},n)}skip(e){let t=this,n;return this.size!=null&&e>=0&&this.size>=e?n=this.size-e:this.size!=null&&(this.size<e||e===void 0||e<0)?n=0:n=null,Zn(async()=>(await t.iterator()).skip(e),n)}shuffle(e,t,n=!0){if(e==null||e<0)throw this.size==null?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);let r=this,s=tq.alea(t||w.now().toString());return Zn(async()=>{let a=s.int32();return n&&(a+=s.int32()),(await r.iterator()).shuffle(e,a.toString())},this.size)}take(e){let t=this,n;return this.size!=null&&this.size>e?n=e:this.size!=null&&this.size<=e?n=this.size:n=null,Zn(async()=>(await t.iterator()).take(e),n)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}};vl.MAX_BUFFER_SIZE=1e4;function Zn(e,t=null){return new class extends vl{constructor(){super(...arguments),this.size=t}async iterator(){return e()}}}function kq(e){return Zn(async()=>p2(e),e.length)}function Sq(e){if(!sc(e))throw new Error("The argument to zip() must be an object or array.");let t;if(Array.isArray(e))for(let n=0;n<e.length;n++)t=t==null?e[n].size:Math.min(t,e[n].size);else if(e instanceof Object)for(let n in e)t=t==null?e[n].size:Math.min(t,e[n].size);return Zn(async()=>{let n=await l2(e,r=>{if(r instanceof vl)return{value:r.iterator(),recurse:!1};if(sc(r))return{value:null,recurse:!0};throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.")});return lq(n,ia.SHORTEST)},t)}function Cq(e){if(e===null)return null;let t=e[0];return aq(t)?{value:Tq(e),recurse:!1}:{value:null,recurse:!0}}function Tq(e){if(e.length===0)throw new Error("Can't make a batch of zero elements.");return e[0]instanceof Te?Rt(e):yn(e)}var m2=class extends vl{constructor(e){super(),this.input=e}async iterator(){return(await this.input.iterator()).decodeUTF8().split(`
`).map(r=>(r.endsWith("\r")&&(r=r.slice(0,-1)),r))}},Gh='"',rd=Symbol("out"),l1=Symbol("field"),Hh=Symbol("quote"),Cv=Symbol("quoteafterquote"),d1=Symbol("quoteinquote"),g2=class extends vl{async columnNames(){return this.columnNamesValidated||await this.setColumnNames(),this.configuredColumnsOnly?Object.keys(this.columnConfigs):this.fullColumnNames}async setColumnNames(){let e=await this.maybeReadHeaderLine();if(!this.fullColumnNames&&!e)throw new Error("Column names must be provided if there is no header line.");this.fullColumnNames&&e&&w.assert(e.length===this.fullColumnNames.length,()=>"The length of provided columnNames ("+this.fullColumnNames.length.toString()+") does not match the length of the header line read from file ("+e.length.toString()+")."),this.fullColumnNames||(this.fullColumnNames=e);let t=this.fullColumnNames.reduce((r,s)=>(r[s]=r[s]+1||1,r),{}),n=Object.keys(t).filter(r=>t[r]>1);if(w.assert(n.length===0,()=>"Duplicate column names found: "+n.toString()),this.columnConfigs){for(let r of Object.keys(this.columnConfigs))if(this.fullColumnNames.indexOf(r)===-1)throw new Error('The key "'+r+'" provided in columnConfigs does not match any of the column names ('+this.fullColumnNames.toString()+").")}this.columnNamesValidated=!0}async maybeReadHeaderLine(){if(this.hasHeader){let t=await(await this.base.iterator()).next();if(t.done)throw new Error("No data was found for CSV parsing.");let n=t.value;return this.parseRow(n,!1)}else return null}constructor(e,t){super(),this.input=e,this.hasHeader=!0,this.fullColumnNames=null,this.columnNamesValidated=!1,this.columnConfigs=null,this.configuredColumnsOnly=!1,this.delimiter=",",this.delimWhitespace=!1,this.base=new m2(e),t||(t={}),this.hasHeader=t.hasHeader!==!1,this.fullColumnNames=t.columnNames,this.columnConfigs=t.columnConfigs,this.configuredColumnsOnly=t.configuredColumnsOnly,t.delimWhitespace?(w.assert(t.delimiter==null,()=>"Delimiter should not be provided when delimWhitespace is true."),this.delimWhitespace=!0,this.delimiter=" "):this.delimiter=t.delimiter?t.delimiter:","}async iterator(){this.columnNamesValidated||await this.setColumnNames();let e=await this.base.iterator();return this.hasHeader&&(e=e.skip(1)),e.map(t=>this.makeDataElement(t))}makeDataElement(e){let t=this.parseRow(e),n={},r={};for(let s=0;s<this.fullColumnNames.length;s++){let a=this.fullColumnNames[s],o=this.columnConfigs?this.columnConfigs[a]:null;if(!(this.configuredColumnsOnly&&!o)){let i=t[s],u=null;if(i==="")if(o&&o.default!==void 0)u=o.default;else{if(o&&(o.required||o.isLabel))throw new Error(`Required column ${a} is empty in this line: ${e}`);u=void 0}else{let c=Number(i);if(isNaN(c))o&&o.dtype==="bool"?u=this.getBoolean(i):u=i;else if(!o||!o.dtype)u=c;else switch(o.dtype){case"float32":u=c;break;case"int32":u=Math.floor(c);break;case"bool":u=this.getBoolean(i);break;default:u=c}}o&&o.isLabel?r[a]=u:n[a]=u}}return Object.keys(r).length===0?n:{xs:n,ys:r}}getBoolean(e){return e==="1"||e.toLowerCase()==="true"?1:0}parseRow(e,t=!0){let n=[],r=0,s=e.length,a=rd;for(let o=0;o<s;o++)switch(a){case rd:switch(e.charAt(o)){case Gh:r=o+1,a=Hh;break;case this.delimiter:if(r=o+1,this.delimiter===" "&&this.delimWhitespace)break;n.push(""),a=rd;break;default:a=l1,r=o;break}break;case l1:switch(e.charAt(o)){case this.delimiter:n.push(e.substring(r,o)),a=rd,r=o+1;break;default:}break;case Hh:switch(e.charAt(o)){case Gh:a=Cv;break;default:}break;case Cv:switch(e.charAt(o)){case this.delimiter:n.push(e.substring(r,o-1)),a=rd,r=o+1;break;case Gh:a=Hh;break;default:a=d1;break}break;case d1:switch(e.charAt(o)){case Gh:a=Hh;break;default:}break;default:}if(a===Cv?n.push(e.substring(r,s-1)):n.push(e.substring(r)),t&&n.length!==this.fullColumnNames.length)throw new Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${n}`);return n}},b2=class extends on{constructor(e){super(),this.microphoneConfig=e,this.isClosed=!1,this.fftSize=e.fftSize||1024;let t=Math.log2(this.fftSize);if(this.fftSize<0||t<4||t>14||!Number.isInteger(t))throw new Error(`Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got ${this.fftSize}`);if(this.numFrames=e.numFramesPerSpectrogram||43,this.sampleRateHz=e.sampleRateHz,this.columnTruncateLength=e.columnTruncateLength||this.fftSize,this.audioTrackConstraints=e.audioTrackConstraints,this.smoothingTimeConstant=e.smoothingTimeConstant||0,this.includeSpectrogram=e.includeSpectrogram!==!1,this.includeWaveform=e.includeWaveform===!0,!this.includeSpectrogram&&!this.includeWaveform)throw new Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.")}summary(){return"microphone"}static async create(e={}){if(!G().get("IS_BROWSER"))throw new Error("microphone API is only supported in browser environment.");let t=new b2(e);return await t.start(),t}async start(){try{this.stream=await navigator.mediaDevices.getUserMedia({audio:this.audioTrackConstraints==null?!0:this.audioTrackConstraints,video:!1})}catch(n){throw new Error(`Error thrown while initializing video stream: ${n.message}`)}if(!this.stream)throw new Error("Could not obtain audio from microphone.");let e=window.AudioContext||window.webkitAudioContext;if(this.audioContext=new e,!this.sampleRateHz)this.sampleRateHz=this.audioContext.sampleRate;else if(this.audioContext.sampleRate!==this.sampleRateHz)throw new Error(`Mismatch in sampling rate: Expected: ${this.sampleRateHz}; Actual: ${this.audioContext.sampleRate}`);let t=this.audioContext.createMediaStreamSource(this.stream);this.analyser=this.audioContext.createAnalyser(),this.analyser.fftSize=this.fftSize*2,this.analyser.smoothingTimeConstant=this.smoothingTimeConstant,t.connect(this.analyser),this.freqData=new Float32Array(this.fftSize),this.timeData=new Float32Array(this.fftSize)}async next(){if(this.isClosed)return{value:null,done:!0};let e,t,n=await this.getAudioData();if(this.includeSpectrogram){let r=this.flattenQueue(n.freqDataQueue);e=this.getTensorFromAudioDataArray(r,[this.numFrames,this.columnTruncateLength,1])}if(this.includeWaveform){let r=this.flattenQueue(n.timeDataQueue);t=this.getTensorFromAudioDataArray(r,[this.numFrames*this.fftSize,1])}return{value:{spectrogram:e,waveform:t},done:!1}}async capture(){return(await this.next()).value}async getAudioData(){let e=[],t=[],n=0;return new Promise(r=>{let s=setInterval(()=>{this.includeSpectrogram&&(this.analyser.getFloatFrequencyData(this.freqData),this.freqData[0]===-1/0&&r({freqDataQueue:e,timeDataQueue:t}),e.push(this.freqData.slice(0,this.columnTruncateLength))),this.includeWaveform&&(this.analyser.getFloatTimeDomainData(this.timeData),t.push(this.timeData.slice())),++n===this.numFrames&&(clearInterval(s),r({freqDataQueue:e,timeDataQueue:t}))},this.fftSize/this.sampleRateHz*1e3)})}stop(){this.isClosed||(this.isClosed=!0,this.analyser.disconnect(),this.audioContext.close(),this.stream!=null&&this.stream.getTracks().length>0&&this.stream.getTracks()[0].stop())}toArray(){throw new Error("Can not convert infinite audio stream to array.")}getSampleRate(){return this.sampleRateHz}flattenQueue(e){let t=e[0].length,n=new Float32Array(e.length*t);return e.forEach((r,s)=>n.set(r,s*t)),n}getTensorFromAudioDataArray(e,t){let n=new Float32Array(w.sizeFromShape(t));return n.set(e,n.length-e.length),yn(n,t)}},y2=class extends on{constructor(e,t){if(super(),this.webcamVideoElement=e,this.webcamConfig=t,this.isClosed=!0,this.resize=!1,this.needToResize())if(this.resize=!0,this.cropSize=[this.webcamConfig.resizeHeight,this.webcamConfig.resizeWidth],this.cropBoxInd=He([0],"int32"),this.webcamConfig.centerCrop){let n=this.webcamConfig.resizeWidth*1/this.webcamVideoElement.width,r=this.webcamConfig.resizeHeight*1/this.webcamVideoElement.height,s=(1-n)/2,a=(1-r)/2,o=s+n,i=r+a;this.cropBox=Fr([a,s,i,o],[1,4])}else this.cropBox=Fr([0,0,1,1],[1,4])}summary(){return"webcam"}static async create(e,t={}){if(!G().get("IS_BROWSER"))throw new Error("tf.data.webcam is only supported in browser environment.");if(!e){if(e=document.createElement("video"),!t.resizeWidth||!t.resizeHeight)throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");e.width=t.resizeWidth,e.height=t.resizeHeight}let n=new y2(e,t);return await n.start(),n}async start(){this.webcamConfig.facingMode&&w.assert(this.webcamConfig.facingMode==="user"||this.webcamConfig.facingMode==="environment",()=>`Invalid webcam facing mode: ${this.webcamConfig.facingMode}. Please provide 'user' or 'environment'`);try{this.stream=await navigator.mediaDevices.getUserMedia({video:{deviceId:this.webcamConfig.deviceId,facingMode:this.webcamConfig.facingMode?this.webcamConfig.facingMode:"user",width:this.webcamVideoElement.width,height:this.webcamVideoElement.height}})}catch(e){throw e.message=`Error thrown while initializing video stream: ${e.message}`,e}if(!this.stream)throw new Error("Could not obtain video from webcam.");try{this.webcamVideoElement.srcObject=this.stream}catch(e){console.log(e),this.webcamVideoElement.src=window.URL.createObjectURL(this.stream)}return this.webcamVideoElement.play(),this.isClosed=!1,new Promise(e=>{this.webcamVideoElement.onloadedmetadata=()=>{e()}})}async next(){if(this.isClosed)return{value:null,done:!0};let e;try{e=Yi.fromPixels(this.webcamVideoElement)}catch(t){throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(t)}`)}if(this.resize)try{return{value:this.cropAndResizeFrame(e),done:!1}}catch(t){throw new Error(`Error thrown cropping the video: ${t.message}`)}finally{e.dispose()}else return{value:e,done:!1}}needToResize(){return!!(this.webcamConfig.resizeWidth&&this.webcamConfig.resizeHeight&&(this.webcamVideoElement.width!==this.webcamConfig.resizeWidth||this.webcamVideoElement.height!==this.webcamConfig.resizeHeight))}cropAndResizeFrame(e){return O(()=>{let t=jt(ae(e,"float32"),0),n;n=tr.cropAndResize(t,this.cropBox,this.cropBoxInd,this.cropSize,"bilinear");let r=n.shape;return W(n,r.slice(1))})}async capture(){return(await this.next()).value}stop(){this.stream.getTracks().forEach(t=>t.stop());try{this.webcamVideoElement.srcObject=null}catch(t){console.log(t),this.webcamVideoElement.src=null}this.isClosed=!0}toArray(){throw new Error("Can not convert infinite video stream to array.")}},v2=class{},x2=class extends on{split(e){return new Nq(this,e)}},Nq=class extends x2{constructor(e,t){super(),this.upstream=e,this.impl=new _q(e,t)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},_q=class extends Ok{constructor(e,t){super(),this.upstream=e,this.separator=t,this.carryover=""}summary(){return`${this.upstream.summary()} -> Split('${this.separator}')`}async pump(){let e=await this.upstream.next();if(e.done)return this.carryover===""?!1:(this.outputQueue.push(this.carryover),this.carryover="",!0);let t=e.value.split(this.separator);t[0]=this.carryover+t[0];for(let n of t.slice(0,-1))this.outputQueue.push(n);return this.carryover=t[t.length-1],!0}},Eq=class extends on{decodeUTF8(){return new Aq(this)}},Aq=class extends x2{constructor(e){super(),this.upstream=e,this.impl=new Dq(e)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},Dq=class extends Ok{constructor(e){if(super(),this.upstream=e,G().get("IS_BROWSER"))this.decoder=new TextDecoder("utf-8");else{let{StringDecoder:t}=K1();this.decoder=new t("utf8")}}summary(){return`${this.upstream.summary()} -> Utf8`}async pump(){let e=await this.upstream.next(),t;if(e.done)return!1;t=e.value;let n;return G().get("IS_BROWSER")?n=this.decoder.decode(t,{stream:!0}):n=this.decoder.write(Buffer.from(t.buffer)),this.outputQueue.push(n),!0}},w2=class extends Eq{constructor(e,t={}){super(),this.file=e,this.options=t,w.assert(e instanceof Uint8Array||(G().get("IS_BROWSER")?e instanceof File||e instanceof Blob:!1),()=>"FileChunkIterator only supports File, Blob and Uint8Array right now."),this.offset=t.offset||0,this.chunkSize=t.chunkSize||1024*1024}summary(){return`FileChunks ${this.file}`}async next(){return this.offset>=(this.file instanceof Uint8Array?this.file.byteLength:this.file.size)?{value:null,done:!0}:{value:await new Promise((t,n)=>{let r=this.offset+this.chunkSize;if(this.file instanceof Uint8Array)t(new Uint8Array(this.file.slice(this.offset,r)));else{let s=new FileReader;s.onload=o=>{let i=s.result;if(i instanceof ArrayBuffer&&(i=new Uint8Array(i)),!(i instanceof Uint8Array))return n(new TypeError("FileReader returned unknown type."));t(i)},s.onabort=o=>n(new Error("Aborted")),s.onerror=o=>n(new Error(o.type));let a=this.file.slice(this.offset,r);s.readAsArrayBuffer(a)}this.offset=r}),done:!1}}};async function $q(e,t={},n){let r,s;typeof e=="string"?r=e:(r=e.url,s=Fq(e));let a=await(n||w.fetch)(r,s);if(a.ok){let o=new Uint8Array(await a.arrayBuffer());return new w2(o,t)}else throw new Error(a.statusText)}var Fq=e=>({method:e.method,headers:e.headers,body:e.body,mode:e.mode,credentials:e.credentials,cache:e.cache,redirect:e.redirect,referrer:e.referrer,integrity:e.integrity});function I2(e){return typeof e=="string"&&e.slice(0,7)==="file://"}var k2=class extends v2{constructor(e,t={}){super(),this.input=e,this.options=t}async iterator(){if(I2(this.input)&&G().get("IS_NODE")){let e=Nx();this.input=e.readFileSync(this.input.slice(7))}return new w2(this.input,this.options)}},S2=class extends v2{constructor(e,t={}){super(),this.url=e,this.fileOptions=t}async iterator(){return I2(this.url)?new k2(this.url,this.fileOptions).iterator():$q(this.url,this.fileOptions)}};function Rq(e,t={}){return new g2(new S2(e),t)}function Pq(e){let t=Pk(e);return Zn(async()=>t)}function Oq(e){return Zn(async()=>{let t=await e();return Pk(()=>t.next())})}async function Mq(e,t){return y2.create(e,t)}async function Lq(e){return b2.create(e)}var zq="4.9.0";function be(e,t){Array.isArray(e)||(e=[e]),e.forEach(n=>{n!=null&&w.assert(n.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the CPU backend.`)})}var Bq=bs.whereImpl,Qm=class extends Md{nextDataId(){return Qm.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new Mf(this,Dr())}write(e,t,n){this.firstUse&&(this.firstUse=!1,G().get("IS_NODE")&&T.warn(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));let r={id:this.nextDataId()};return this.data.set(r,{values:e,dtype:n,refCount:1}),r}makeTensorInfo(e,t,n){let r;if(t==="string"&&n!=null&&n.length>0&&w.isString(n[0])){let s=n.map(a=>w.encodeString(a));r=this.write(s,e,t)}else r=this.write(n,e,t);return{dataId:r,shape:e,dtype:t}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){let t=this.data.get(e);t.refCount++}decRef(e){if(this.data.has(e)){let t=this.data.get(e);t.refCount--}}move(e,t,n,r,s){this.data.set(e,{values:t,dtype:r,refCount:s})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){let{dtype:t,complexTensorInfos:n}=this.data.get(e);if(t==="complex64"){let r=this.readSync(n.real.dataId),s=this.readSync(n.imag.dataId);return T.mergeRealAndImagArrays(r,s)}return w.convertBackendValuesAndArrayBuffer(this.data.get(e).values,t)}bufferSync(e){let t=this.readSync(e.dataId);if(e.dtype==="string")try{let n=t.map(r=>w.decodeString(r));return ze(e.shape,e.dtype,n)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return ze(e.shape,e.dtype,t)}makeOutput(e,t,n){return Dr().makeTensorFromTensorInfo(this.makeTensorInfo(t,n,e),this)}disposeData(e,t=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;let{complexTensorInfos:n}=this.data.get(e);n!=null&&(this.disposeData(n.real.dataId,!0),this.disposeData(n.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){let t=w.now();return e(),{kernelMs:w.now()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){be([e],"where");let t=this.readSync(e.dataId);return Bq(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}};Qm.nextDataId=0;var Mk={};Ee(Mk,{addImpl:()=>N2,bincountImpl:()=>zk,bincountReduceImpl:()=>_2,bitwiseAndImpl:()=>E2,castImpl:()=>T2,ceilImpl:()=>A2,concatImpl:()=>Bk,equalImpl:()=>D2,expImpl:()=>F2,expm1Impl:()=>P2,floorDivImpl:()=>M2,floorImpl:()=>O2,gatherNdImpl:()=>L2,gatherV2Impl:()=>z2,greaterEqualImpl:()=>W2,greaterImpl:()=>B2,lessEqualImpl:()=>U2,lessImpl:()=>V2,linSpaceImpl:()=>G2,logImpl:()=>H2,maxImpl:()=>j2,maximumImpl:()=>q2,minimumImpl:()=>K2,multiplyImpl:()=>Wk,negImpl:()=>X2,notEqualImpl:()=>Y2,prodImpl:()=>Z2,raggedGatherImpl:()=>J2,raggedRangeImpl:()=>Q2,raggedTensorToTensorImpl:()=>eE,rangeImpl:()=>Uk,rsqrtImpl:()=>tE,scatterImpl:()=>ao,sigmoidImpl:()=>L8,simpleAbsImpl:()=>C2,sliceImpl:()=>_f,sparseFillEmptyRowsImpl:()=>rE,sparseReshapeImpl:()=>sE,sparseSegmentReductionImpl:()=>Gk,sqrtImpl:()=>W8,squaredDifferenceImpl:()=>aE,staticRegexReplaceImpl:()=>oE,stridedSliceImpl:()=>iE,stringNGramsImpl:()=>Hk,stringSplitImpl:()=>jk,stringToHashBucketFastImpl:()=>qk,subImpl:()=>uE,tileImpl:()=>cE,topKImpl:()=>dE,transposeImpl:()=>Vk,uniqueImpl:()=>Xk});function C2(e){let t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}var Wq=e=>{let{x:t}=e.inputs,n=e.backend;be(t,"abs");let r=new Float32Array(w.sizeFromShape(t.shape)),s=n.data.get(t.dataId).values;return r=C2(s),n.makeOutput(r,t.shape,t.dtype)},Vq={kernelName:cc,backendName:"cpu",kernelFunc:Wq};function Lt(e){return(t,n,r,s,a)=>{let o=T.assertAndGetBroadcastShape(t,n),i=o.length,u=w.computeStrides(o),c=w.sizeFromShape(o),l=w.getTypedArrayFromDType(a,c),p=t.length,d=n.length,h=w.computeStrides(t),f=w.computeStrides(n),g=T.getBroadcastDims(t,o),m=T.getBroadcastDims(n,o);if(g.length+m.length===0)for(let b=0;b<l.length;++b)l[b]=e(r[b%r.length],s[b%s.length]);else for(let b=0;b<l.length;++b){let v=w.indexToLoc(b,i,u),y=v.slice(-p);g.forEach(N=>y[N]=0);let x=w.locToIndex(y,p,h),k=v.slice(-d);m.forEach(N=>k[N]=0);let S=w.locToIndex(k,d,f);l[b]=e(r[x],s[S])}return[l,o]}}function Qn(e){let{inputs:t,backend:n}=e,{real:r,imag:s}=t,a=n.data.get(r.dataId).values,o=n.data.get(s.dataId).values,i=n.makeTensorInfo(r.shape,"complex64"),u=n.data.get(i.dataId);return u.complexTensorInfos={real:n.makeTensorInfo(r.shape,"float32",a),imag:n.makeTensorInfo(s.shape,"float32",o)},i}var Uq={kernelName:Bf,backendName:"cpu",kernelFunc:Qn};function Nf(e,t,n="float32"){if(n==="complex64"){let s=Nf(e,t,"float32"),a=Nf(e,t,"float32");return Qn({inputs:{real:s,imag:a},backend:e})}let r=w.makeZerosTypedArray(w.sizeFromShape(t),n);return e.makeTensorInfo(t,n,r)}function hs(e){let{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}var Gq={kernelName:si,backendName:"cpu",kernelFunc:hs};function Io(e){let{inputs:t,backend:n}=e,{input:r}=t,s=n.data.get(r.dataId).complexTensorInfos.real,a=n.data.get(s.dataId).values;return n.makeTensorInfo(s.shape,s.dtype,a)}var Hq={kernelName:Jf,backendName:"cpu",kernelFunc:Io};function T2(e,t,n,r){if(r==="int32"){let s=Int32Array.from(e);return[t,"int32",s]}if(r==="bool"){let s=w.toTypedArray([0],n),[a,o]=Lt((i,u)=>i!==u?1:0)(t,[],e,s,"bool");return[o,"bool",a]}throw new Error(`Error in Cast: failed to cast ${n} to ${r}`)}function wa(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dtype:a}=r;if(a==="complex64"){if(s.dtype==="complex64")return hs({inputs:{x:s},backend:n});let l=Nf(n,s.shape,s.dtype),p=wa({inputs:{x:s},backend:n,attrs:{dtype:"float32"}}),d=Qn({inputs:{real:p,imag:l},backend:n});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(p),d}if(s.dtype==="complex64"){let l=Io({inputs:{input:s},backend:n}),p=wa({inputs:{x:l},backend:n,attrs:{dtype:a}});return n.disposeIntermediateTensorInfo(l),p}if(!w.hasEncodingLoss(s.dtype,a)){let l=hs({inputs:{x:s},backend:n});return{dataId:l.dataId,shape:l.shape,dtype:a}}let o=n.data.get(s.dataId).values,[i,u,c]=T2(o,s.shape,s.dtype,a);return n.makeTensorInfo(i,u,c)}var jq={kernelName:zo,backendName:"cpu",kernelFunc:wa};function Qt(e,t,n,r){return n==null?({inputs:s,backend:a})=>{let{a:o,b:i}=s,u=a;be([o,i],e);let c=u.data.get(o.dataId).values,l=u.data.get(i.dataId).values,p=o.dtype==="string"?T.fromUint8ToStringArray(c):c,d=o.dtype==="string"?T.fromUint8ToStringArray(l):l,h=r||o.dtype,[f,g]=t(o.shape,i.shape,p,d,h);return u.makeTensorInfo(g,h,f)}:({inputs:s,backend:a})=>{let{a:o,b:i}=s,u=a;if(o.dtype==="complex64"||i.dtype==="complex64"){let c=wa({inputs:{x:o},backend:u,attrs:{dtype:"complex64"}}),l=u.data.get(c.dataId),p=l.complexTensorInfos.real,d=l.complexTensorInfos.imag,h=u.data.get(p.dataId).values,f=u.data.get(d.dataId).values,g=wa({inputs:{x:i},backend:u,attrs:{dtype:"complex64"}}),m=u.data.get(g.dataId),b=m.complexTensorInfos.real,v=m.complexTensorInfos.imag,y=u.data.get(b.dataId).values,x=u.data.get(v.dataId).values,[k,S,N]=n(o.shape,i.shape,h,f,y,x),E=u.makeTensorInfo(N,"float32",k),$=u.makeTensorInfo(N,"float32",S),R=Qn({inputs:{real:E,imag:$},backend:u});return u.disposeIntermediateTensorInfo(c),u.disposeIntermediateTensorInfo(g),u.disposeIntermediateTensorInfo(E),u.disposeIntermediateTensorInfo($),R}else{let c=u.data.get(o.dataId).values,l=u.data.get(i.dataId).values,p=r||o.dtype,[d,h]=t(o.shape,i.shape,c,l,p);return u.makeTensorInfo(h,p,d)}}}function Lk(e){return(t,n,r,s,a,o)=>{let i=T.assertAndGetBroadcastShape(t,n),u=w.sizeFromShape(i),c=i.length,l=w.computeStrides(i),p=w.getTypedArrayFromDType("float32",u),d=w.getTypedArrayFromDType("float32",u),h=T.getBroadcastDims(t,i),f=T.getBroadcastDims(n,i),g=T.mergeRealAndImagArrays(r,s),m=T.mergeRealAndImagArrays(a,o),b=t.length,v=w.computeStrides(t),y=n.length,x=w.computeStrides(n);if(h.length+f.length===0)for(let k=0;k<p.length;k++){let S=k%g.length,N=k%m.length,E=e(g[S*2],g[S*2+1],m[N*2],m[N*2+1]);p[k]=E.real,d[k]=E.imag}else for(let k=0;k<p.length;k++){let S=w.indexToLoc(k,c,l),N=S.slice(-b);h.forEach(F=>N[F]=0);let E=w.locToIndex(N,b,v),$=S.slice(-y);f.forEach(F=>$[F]=0);let R=w.locToIndex($,y,x),D=e(g[E*2],g[E*2+1],m[R*2],m[R*2+1]);p[k]=D.real,d[k]=D.imag}return[p,d,i]}}var N2=Lt((e,t)=>e+t),qq=Lk((e,t,n,r)=>({real:e+n,imag:t+r})),ac=Qt(Sa,N2,qq),Kq={kernelName:Sa,backendName:"cpu",kernelFunc:ac};function zk(e,t,n,r,s){let a=w.sizeFromShape(r),o=w.makeZerosTypedArray(s,n);for(let i=0;i<e.length;i++){let u=e[i];if(u<0)throw new Error("Input x must be non-negative!");u>=s||(a>0?o[u]+=t[i]:o[u]+=1)}return o}function _2(e,t,n,r=!1){let s=e.shape[0],a=e.shape[1],o=ze([s,n],t.dtype);for(let i=0;i<s;i++)for(let u=0;u<a;u++){let c=e.get(i,u);if(c<0)throw new Error("Input x must be non-negative!");c>=n||(r?o.set(1,i,c):t.size>0?o.set(o.get(i,c)+t.get(i,u),i,c):o.set(o.get(i,c)+1,i,c))}return o}var E2=Lt((e,t)=>e&t),Xq=Qt(bc,E2),Yq={kernelName:bc,backendName:"cpu",kernelFunc:Xq};function vs(e){return(t,n,r)=>{let s=w.getArrayFromDType(n,t.length);for(let a=0;a<t.length;++a)s[a]=e(t[a],r);return s}}function it(e,t,n){let r=vs(t);return Pa(e,r,n)}function Pa(e,t,n){return({inputs:r,attrs:s,backend:a})=>{let{x:o}=r;be(o,e);let i=a,u=i.data.get(o.dataId).values,c;if(o.dtype==="string"){if(!Array.isArray(u))throw new Error("String tensor's value was not an instance of Array");c=T.fromUint8ToStringArray(u)}else c=u;let l=n||o.dtype,p=t(c,l,s);return i.makeTensorInfo(o.shape,l,p)}}var A2=vs(e=>Math.ceil(e)),Zq=Pa(Bo,A2),Jq={kernelName:Bo,backendName:"cpu",kernelFunc:Zq};function Bk(e,t,n,r){let s=w.getArrayFromDType(n,w.sizeFromShape(t));if(r&&n!=="string"){let a=0;e.forEach(o=>{let i=w.sizeFromShape(o.shape);s.set(o.vals,a),a+=i})}else{let a=0;e.forEach(o=>{let i=n==="string"?T.fromUint8ToStringArray(o.vals):o.vals,u=0;for(let c=0;c<o.shape[0];++c){let l=c*t[1]+a;for(let p=0;p<o.shape[1];++p)s[l+p]=i[u++]}a+=o.shape[1]})}return s}var D2=Lt((e,t)=>e===t?1:0),$2=Qt(Cc,D2,null,"bool"),Qq={kernelName:Cc,backendName:"cpu",kernelFunc:$2},F2=vs(e=>Math.exp(e)),R2=Pa(Jo,F2,"float32"),e8={kernelName:Jo,backendName:"cpu",kernelFunc:R2},P2=vs(e=>Math.expm1(e)),t8=Pa(Qo,P2),n8={kernelName:Qo,backendName:"cpu",kernelFunc:t8},O2=vs(e=>Math.floor(e)),r8=Pa(ei,O2),s8={kernelName:ei,backendName:"cpu",kernelFunc:r8},M2=Lt((e,t)=>Math.floor(e/t)),a8=Qt(ti,M2,null,"int32"),o8={kernelName:ti,backendName:"cpu",kernelFunc:a8};function L2(e,t,n,r,s,a,o,i,u){let c=ze([r,a],n);for(let l=0;l<r;l++){let p=[],d=0;for(let h=0;h<s;h++){let f=e[l*s+h];d+=f*o[h],p.push(f)}if(d<0||d>=u/a)throw new Error(`Invalid indices: ${p} does not index into ${i}`);for(let h=0;h<a;h++)c.values[l*a+h]=t.get(...t.indexToLoc(d*a+h))}return c}function z2(e,t,n){let r=ze(n,e.dtype);for(let s=0;s<r.size;++s){let o=r.indexToLoc(s).slice(),i=o[0],u=o[2],c=t.locToIndex([i,u]);o[2]=t.values[c];let l=e.locToIndex(o);0<=l&&l<e.values.length&&(r.values[s]=e.values[l])}return r}var B2=Lt((e,t)=>e>t?1:0),i8=Qt(Ac,B2,null,"bool"),u8={kernelName:Ac,backendName:"cpu",kernelFunc:i8},W2=Lt((e,t)=>e>=t?1:0),c8=Qt(ri,W2,null,"bool"),l8={kernelName:ri,backendName:"cpu",kernelFunc:c8},V2=Lt((e,t)=>e<t?1:0),d8=Qt(Dc,V2,null,"bool"),p8={kernelName:Dc,backendName:"cpu",kernelFunc:d8},U2=Lt((e,t)=>e<=t?1:0),h8=Qt($c,U2,null,"bool"),f8={kernelName:$c,backendName:"cpu",kernelFunc:h8};function G2(e,t,n){let r=(t-e)/(n-1),s=w.makeZerosTypedArray(n,"float32");s[0]=e;for(let a=1;a<s.length;a++)s[a]=s[a-1]+r;return s}var H2=vs(e=>Math.log(e)),m8=Pa(ci,H2),g8={kernelName:ci,backendName:"cpu",kernelFunc:m8};function j2(e,t,n,r){let s=w.getTypedArrayFromDType(r,w.sizeFromShape(n));for(let a=0;a<s.length;++a){let o=a*t,i=e[o];for(let u=0;u<t;++u){let c=e[o+u];(Number.isNaN(c)||c>i)&&(i=c)}s[a]=i}return s}var q2=Lt((e,t)=>Math.max(e,t)),b8=Qt(hi,q2),y8={kernelName:hi,backendName:"cpu",kernelFunc:b8},K2=Lt((e,t)=>Math.min(e,t)),v8=Qt(bi,K2),x8={kernelName:bi,backendName:"cpu",kernelFunc:v8},Wk=Lt((e,t)=>e*t),w8=Lk((e,t,n,r)=>({real:e*n-t*r,imag:e*r+t*n})),eg=Qt(xi,Wk,w8),I8={kernelName:xi,backendName:"cpu",kernelFunc:eg};function X2(e,t,n){let r=w.createScalarValue(-1,n);return Wk([],t,r,e,n)}function k8(e){let{inputs:t,backend:n}=e,{x:r}=t;be(r,"neg");let s=n.data.get(r.dataId).values,[a,o]=X2(s,r.shape,r.dtype);return n.makeTensorInfo(o,r.dtype,a)}var S8={kernelName:Bc,backendName:"cpu",kernelFunc:k8},Y2=Lt((e,t)=>e!==t?1:0),C8=Qt(Wc,Y2,null,"bool"),T8={kernelName:Wc,backendName:"cpu",kernelFunc:C8};function Vk(e,t,n,r,s){let a=t.length,o=w.sizeFromShape(t),i=w.computeStrides(t),u=w.computeStrides(s),c=w.getTypedArrayFromDType(n,w.sizeFromShape(s));for(let l=0;l<o;++l){let p=w.indexToLoc(l,a,i),d=new Array(p.length);for(let f=0;f<d.length;f++)d[f]=p[r[f]];let h=w.locToIndex(d,a,u);c[h]=e[l]}return c}function Un(e){let{inputs:t,attrs:n,backend:r}=e,{x:s}=t,{perm:a}=n;be(s,"transpose");let o=s.shape.length,i=new Array(o);for(let p=0;p<i.length;p++)i[p]=s.shape[a[p]];let u=r.data.get(s.dataId).values,c=Vk(u,s.shape,s.dtype,a,i);return{dataId:r.write(c,i,s.dtype),shape:i,dtype:s.dtype}}var N8={kernelName:$s,backendName:"cpu",kernelFunc:Un};function Z2(e,t,n,r){let[s,a]=T.computeOutAndReduceShapes(e,r),o=mr(t,"int32"),i=w.makeZerosTypedArray(w.sizeFromShape(s),o),u=w.sizeFromShape(a);for(let c=0;c<i.length;++c){let l=c*u,p=1;for(let d=0;d<u;++d)p*=n[l+d];i[c]=p}return{outVals:i,outShape:s,outDtype:o}}function _8(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:o}=r;be(s,"prod");let i=s.shape.length,u=w.parseAxisParam(a,s.shape),c=T.getAxesPermutation(u,i),l=u,p=s,d=[];c!=null&&(p=Un({inputs:{x:s},backend:n,attrs:{perm:c}}),d.push(p),l=T.getInnerMostAxes(l.length,i));let h=n.data.get(p.dataId).values,{outVals:f,outShape:g,outDtype:m}=Z2(p.shape,p.dtype,h,l),b=g;return o&&(b=T.expandShapeToKeepDim(g,u)),d.forEach(v=>n.disposeIntermediateTensorInfo(v)),n.makeTensorInfo(b,m,f)}var E8={kernelName:Ci,backendName:"cpu",kernelFunc:_8};function A8(e,t,n){e.forEach((r,s)=>{if(r<0||r>=n){let a=w.indexToLoc(s,t.length,w.computeStrides(t)).join(",");throw new Error(`indices[${a}] = ${r} is not in [0, ${n})`)}})}function D8(e,t){for(let n=0;n<e.length;++n){let r=e[n],s=n===e.length-1?t:e[n+1].length;if(r.length===0)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>s)throw new Error("Ragged splits must not point past values");for(let a=1;a<r.length;++a)if(r[a-1]>r[a])throw new Error("Ragged splits must be sorted in ascending order")}}function $8(e,t,n,r){let s=[],a=0,o=t.length-1+n.length,i=new Array(o).fill(null).map(()=>[0]);D8(n,r);let u=1;for(let c=0;c<t.length-1;++c){u*=t[c];let l=t[c+1];for(let p=1;p<u+1;++p)i[c].push(p*l)}for(let c=0;c<e.length;++c){let l=e[c],p=e[c]+1;for(let d=0;d<n.length;++d){let h=n[d],f=d+t.length-1;if(f>=0){let g=i[f],m=g[g.length-1]-h[l];for(let b=l;b<p;++b)i[f].push(h[b+1]+m)}l=h[l],p=h[p]}p!==l&&(s.push([l,p]),a+=p-l)}return{outSplits:i,valueSlices:s,numValues:a}}function F8(e){let t=[];for(let n=0;n<e.length;++n){let r=e[n].length,s=w.getArrayFromDType("int32",r);t.push(s),e[n].forEach((a,o)=>s[o]=a)}return t}function p1(e,t){let n=e.slice(0,t);for(;n.length<t;)n.push(1);for(let r=t;r<e.length;r++)n[t-1]*=e[r];return n}function R8(e,t,n,r,s,a){let o=p1(t,2)[1],i=p1(a,2)[1],u=0;for(let c of n)for(let l=c[0];l<c[1];++l){for(let p=0;p<r;++p)s[u*i+p]=e[l*o+p];++u}}function P8(e,t,n,r,s){let a=t.slice();a[0]=s;let o=w.getArrayFromDType(n,w.sizeFromShape(a)),i=e.length,u=i===0?0:i/t[0];return R8(e,t,r,u,o,a),[o,a]}function J2(e,t,n,r,s,a,o,i){if(e.length===0)throw new Error("paramsNestedSplits must be non empty");if(t[0].length===0)throw new Error("Split tensors must not be scalars");let u=t[0][0]-1;if(A8(a,o,u),r.length===0)throw new Error("params.rank must be nonzero");let c=r[0],{outSplits:l,valueSlices:p,numValues:d}=$8(a,o,e,c),h=F8(l),f=P8(n,r,s,p,d);return[h,f[0],f[1]]}var h1=2147483647;function Q2(e,t,n,r,s,a,o){if(t.length>1)throw new Error("starts must be a scalar or vector");if(s.length>1)throw new Error("limits must be a scalar or vector");if(o.length>1)throw new Error("deltas must be a scalar or vector");let i=t.length===0,u=s.length===0,c=o.length===0,l=[];i||l.push(t[0]),u||l.push(s[0]),c||l.push(o[0]);for(let m=1;m<l.length;++m)if(l[m]!==l[m-1])throw new Error("starts, limits, and deltas must have the same shape");let p=l.length===0?1:l[0],d=w.getArrayFromDType("int32",p+1);d[0]=0;for(let m=0;m<p;++m){let b=i?e[0]:e[m],v=u?r[0]:r[m],y=c?a[0]:a[m];if(y===0)throw new Error("Requires delta != 0");let x;if(y>0&&v<b||y<0&&v>b)x=0;else if(x=Math.ceil(Math.abs((v-b)/y)),x>h1)throw new Error(`Requires ((limit - start) / delta) <= ${h1}`);d[m+1]=d[m]+x}let h=d[p],f=w.getArrayFromDType(n,h),g=0;for(let m=0;m<p;++m){let b=d[m+1]-d[m],v=i?e[0]:e[m],y=c?a[0]:a[m];for(let x=0;x<b;++x)f[g++]=v,v+=y}return[d,f]}var _r=T.RowPartitionType,dx=class{constructor(e,t,n,r,s,a,o,i,u,c){this.shape=e,this.shapeShape=t,this.values=n,this.valuesShape=r,this.valuesDType=s,this.defaultValue=a,this.defaultValueShape=o,this.rowPartitionValues=i,this.rowPartitionValuesShapes=u,this.rowPartitionTypes=T.getRowPartitionTypesHelper(c),this.raggedRank=T.getRaggedRank(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===_r.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===_r.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){let t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case _r.VALUE_ROWIDS:return dx.getMaxWidthValueRowID(t);case _r.ROW_SPLITS:return dx.getMaxWidthRowSplit(t);default:throw new Error(`Cannot handle partition type ${_r[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){let t=e.length;if(t===0||t===1)return 0;let n=0;for(let r=0;r<t-1;++r){let s=e[r+1]-e[r];s>n&&(n=s)}return n}static getMaxWidthValueRowID(e){let t=e.length;if(t===0)return 0;let n=0,r=e[0],s=0;for(let a=1;a<t;++a){let o=e[a];o!==r&&(r=o,s=Math.max(a-n,s),n=a)}return Math.max(t-n,s)}tensorShapeFromTensor(e,t,n=!0){if(t.length===0){if(e[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return m1(e,n)}calculateOutputSize(e){let t=this.valuesShape,n=this.defaultValueShape;T.validateDefaultValueShape(n,t);let r=this.tensorShapeFromTensor(this.shape,this.shapeShape),a=T.combineRaggedTensorToTensorShapes(this.raggedRank,r,t);a[0]<0&&(a[0]=e);for(let o=1;o<=this.raggedRank;++o)a[o]<0&&(a[o]=this.getMaxWidth(o));return a}calculateFirstParentOutputIndex(e,t,n){let r=Math.min(e,n),s=[],a=0;for(let o=0;o<r;++o,a+=t)s.push(a);for(let o=r;o<e;++o)s.push(-1);return w.assert(s.length===e,()=>"Final length of result must be equal to firstDimension."),s}calculateOutputIndexRowSplit(e,t,n,r){let s=e.length,a=[];for(let o=0;o<s-1;++o){let i=e[o+1]-e[o],u=Math.min(r,i),c=t[o];c===-1&&(u=0);for(let l=0;l<u;++l)a.push(c),c+=n;for(let l=0;l<i-u;++l)a.push(-1)}if(s>0&&a.length!==e[s-1])throw new Error("Invalid row split size.");return a}calculateOutputIndexValueRowID(e,t,n,r){let s=e.length,a=[];if(s===0)return[];let o=0,i=e[0];if(i>=t.length)throw new Error(`Got currentValueRowId=${i}, which is not less than ${t.length}`);let u=t[i];a.push(u);for(let c=1;c<s;++c){let l=e[c];if(l===i)u>=0&&(++o,o<r?u+=n:u=-1);else{if(o=0,i=l,l>=t.length)throw new Error(`Got nextValueRowId=${l} which is not less than ${t.length}`);u=t[l]}a.push(u)}if(a.length!==e.length)throw new Error("Invalid row ids.");return a}calculateOutputIndex(e,t,n,r){let s=this.getRowPartitionTensor(e),a=this.getRowPartitionTypeByDimension(e);switch(a){case _r.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(s,t,n,r);case _r.ROW_SPLITS:if(s.length-1>t.length)throw new Error(`Row partition size is greater than output size: ${s.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(s,t,n,r);default:throw new Error(`Unsupported partition type: ${_r[a]}`)}}getFirstDimensionSize(){let e=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");let t=this.rowPartitionTypes[0];switch(t){case _r.FIRST_DIM_SIZE:return e[0];case _r.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case _r.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${_r[t]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");let t=this.getFirstDimensionSize(),n=this.calculateOutputSize(t),r=new Array(this.raggedRank+1);r[r.length-1]=1;for(let i=r.length-2;i>=0;--i)r[i]=r[i+1]*n[i+1];let s=m1(n,!1),a=w.getArrayFromDType(this.valuesDType,w.sizeFromShape(s));if(r[0]*n[0]>0){let i=this.calculateFirstParentOutputIndex(t,r[0],n[0]);for(let u=1;u<=this.raggedRank;++u)i=this.calculateOutputIndex(u-1,i,r[u],n[u]);this.setOutput(this.raggedRank,i,a,s)}return[s,a]}setOutput(e,t,n,r){if(n.length===0)return;let s=this.values,a=n,o=r.slice();o=o.slice(e+1);let i=w.sizeFromShape(o),u=t.length,c=this.defaultValue;if(c.length!==i&&c.length!==1){let h=this.defaultValueShape;O(()=>{let f=W(c,h);c=oo(f,o).dataSync()})}let l=0,p=0,d=0;for(let h=0;h<=u;++h){let f=h<u?t[h]:-1;if(f===d){++d;continue}if(p<d){let g=s.subarray(l*i),m=a.subarray(p*i),b=(d-p)*i;f1(m,g,b)}if(h>=u){let g=n.length;f=Math.floor(g/i)}if(f>d)if(this.defaultValue.length===1)a.subarray(d*i,f*i).fill(this.defaultValue[0]),d=f;else for(;f>d;){let g=a.slice(d*i);f1(g,c,i),++d}f<0?(l=h+1,p=d):(l=h,p=d,d=p+1)}}};function f1(e,t,n){for(let r=0;r<n;r++)e[r]=t[r]}function m1(e,t){let n=[];for(let r of e){if(r<0){if(!t)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}n.push(r)}return n}function eE(e,t,n,r,s,a,o,i,u,c){return new dx(e,t,n,r,s,a,o,i,u,c).compute()}function Uk(e,t,n,r){let s=e===t,a=e<t&&n<0,o=t<e&&n>1;if(s||a||o)return w.makeZerosTypedArray(0,r);let i=Math.abs(Math.ceil((t-e)/n)),u=w.makeZerosTypedArray(i,r);t<e&&n===1&&(n=-1),u[0]=e;for(let c=1;c<u.length;c++)u[c]=u[c-1]+n;return u}var tE=vs(e=>1/Math.sqrt(e)),O8=Pa(Fi,tE),M8={kernelName:Fi,backendName:"cpu",kernelFunc:O8};function ao(e,t,n,r,s,a,o,i,u,c){let l=[r/s,s],p=e.values,d=t.values;if(r===0)return ze(n,t.dtype);let h=u instanceof Vt?u:ze(l,t.dtype);typeof u=="string"||typeof u=="number"?h.values.fill(u):typeof u=="boolean"&&h.values.fill(+u);for(let f=0;f<a;f++){let g=[],m=0;for(let b=0;b<o;b++){let v=p[f*o+b];g.push(v),m+=v*i[b]}if(m<0||m>=r/s)throw new Error(`Invalid indices: ${g} does not index into ${n}`);for(let b=0;b<s;b++)c?h.values[m*s+b]+=d[f*s+b]:h.values[m*s+b]=t.rank===0?d[0]:d[f*s+b]}return h}var L8=vs(e=>1/(1+Math.exp(-e))),nE=it(Li,e=>1/(1+Math.exp(-e))),z8={kernelName:Li,backendName:"cpu",kernelFunc:nE};function _f(e,t,n,r,s){let a=Yt.isSliceContinous(r,t,n),o=w.sizeFromShape(n),i=w.computeStrides(r);if(a){let p=Yt.computeFlatOffset(t,i);return s==="string"?e.slice(p,p+o):e.subarray(p,p+o)}let u=s==="string"?T.fromUint8ToStringArray(e):e,c=ze(r,s,u),l=ze(n,s);for(let p=0;p<l.size;++p){let d=l.indexToLoc(p),h=d.map((f,g)=>f+t[g]);l.set(c.get(...h),...d)}return s==="string"?T.fromStringArrayToUint8(l.values):l.values}function ko(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,size:o}=r;be(s,"slice");let[i,u]=Yt.parseSliceParams(s,a,o);Yt.assertParamsValid(s,i,u);let c=n.data.get(s.dataId).values,l=_f(c,i,u,s.shape,s.dtype);return n.makeTensorInfo(u,s.dtype,l)}var B8={kernelName:el,backendName:"cpu",kernelFunc:ko};function rE(e,t,n,r,s,a,o){let i=t[0],u=a[0],c=new Array(u),l=new Array(i),p=t[1];if(u===0){if(i!==0)throw new Error(T.getSparseFillEmptyRowsIndicesDenseShapeMismatch(i));let m=w.getArrayFromDType(n,0),b=w.getArrayFromDType(s,0);return[m,[0,p],b,c,l]}let d=!0,h=0,f=new Array(u).fill(0);for(let m=0;m<i;++m){let b=e[m*p];if(b<0)throw new Error(T.getSparseFillEmptyRowsNegativeIndexErrorMessage(m,b));if(b>=u)throw new Error(T.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(m,b,u));++f[b],d=d&&b>=h,h=b}let g=!0;for(let m=0;m<u;++m){let b=f[m]===0;c[m]=b,g=g&&!b,f[m]=Math.max(f[m],1),m>0&&(f[m]+=f[m-1])}if(g&&d){let m=e,b=r;for(let v=0;v<i;++v)l[v]=v;return[m,[i,p],b,c,l]}else{let m=f[u-1],b=w.getArrayFromDType(n,m*p),v=w.getArrayFromDType(s,m),y=new Array(u).fill(0);for(let x=0;x<i;++x){let k=e[x*p],S=y[k],N=(k===0?0:f[k-1])+S;y[k]++;for(let E=0;E<p;++E)b[N*p+E]=e[x*p+E];v[N]=r[x],l[x]=N}for(let x=0;x<u;++x)if(y[x]===0){let S=x===0?0:f[x-1];b[S*p+0]=x;for(let N=1;N<p;++N)b[S*p+N]=0;v[S]=o}return[b,[m,p],v,c,l]}}function sE(e,t,n,r,s){let a=w.sizeFromShape(r),o=t[0],i=s.length,u=[],c=1,l=-1;for(let m=0;m<i;++m){let b=s[m];if(b===-1){if(l!==-1)throw new Error(T.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(l,m));l=m,u.push(1)}else{if(b<0)throw new Error(T.getSparseReshapeNegativeOutputDimErrorMessage(m,b));c*=b,u.push(b)}}if(l!==-1){if(c<=0)throw new Error(T.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());let m=Math.trunc(a/c);if(c*m!==a)throw new Error(T.getSparseReshapeInputOutputMultipleErrorMessage(r,u));u[l]=m}if(w.sizeFromShape(u)!==a)throw new Error(T.getSparseReshapeInputOutputMismatchErrorMessage(r,u));let d=r.length,h=[];if(d>0){h[d-1]=1;for(let m=d-2;m>=0;--m)h[m]=h[m+1]*r[m+1]}let f=[];if(i>0){f[i-1]=1;for(let m=i-2;m>=0;--m)f[m]=f[m+1]*u[m+1]}let g=w.getArrayFromDType(n,o*i);for(let m=0;m<o;++m){let b=0;for(let v=0;v<d;++v)b+=e[m*d+v]*h[v];for(let v=0;v<i;++v)g[m*i+v]=Math.trunc(b/f[v]),b%=f[v]}return[g,[o,i],u]}function Gk(e,t,n,r,s,a=!1,o=0){let i=r.length,u=[t[0],e.length/t[0]],c=u[1],p=i>0?s[i-1]+1:0;if(p<0)throw new Error(T.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let d=t.slice();d[0]=p;let h=d.reduce((y,x)=>y*x,1),f=w.getArrayFromDType(n,h);if(i===0)return p>0&&f.fill(o),[f,d];if(p<=0)throw new Error(T.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let g=0,m=1,b=0,v=s[g];for(;;){let y=0;if(m<i){if(y=s[m],v===y){++m;continue}if(v>=y)throw new Error(T.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(v<0||v>=p)throw new Error(T.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(v,p));v>b&&f.fill(o,b*c,v*c);for(let x=g;x<m;++x){let k=r[x];if(k<0||k>=u[0])throw new Error(T.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(x,r[x],u[0]));for(let S=0;S<c;S++)f[v*c+S]+=e[k*c+S]}if(a)for(let x=0;x<c;x++)f[v*c+x]/=m-g;if(g=m,++m,b=v+1,v=y,m>i)break}return b<p&&f.fill(o,b*c,p*c),[f,d]}var W8=vs(e=>Math.sqrt(e)),V8=it(Bi,e=>Math.sqrt(e)),U8={kernelName:Bi,backendName:"cpu",kernelFunc:V8},aE=Lt((e,t)=>{let n=e-t;return n*n}),G8=Qt(Ui,aE),H8={kernelName:Ui,backendName:"cpu",kernelFunc:G8},oE=vs((e,t)=>{let{pattern:n,replaceGlobal:r,rewrite:s}=t;return e.replace(new RegExp(n,r?"g":""),s)}),j8=Pa(ep,oE),q8={kernelName:ep,backendName:"cpu",kernelFunc:j8};function iE(e,t,n,r){let s=ze(e,t.dtype);for(let a=0;a<s.size;a++){let o=s.indexToLoc(a),i=new Array(o.length);for(let u=0;u<i.length;u++)i[u]=o[u]*n[u]+r[u];s.set(t.get(...i),...o)}return s}var K8=class{constructor(e,t,n,r,s,a){this.separator=w.encodeString(e),this.nGramWidths=t,this.leftPad=w.encodeString(n),this.rightPad=w.encodeString(r),this.padWidth=s,this.preserveShort=a}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){let n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,r,s,a){for(let o=0;o<s;++o){let i=this.getPadWidth(a),u=Math.max(0,i-o),c=Math.max(0,i-(s-(o+1))),l=a-(u+c),p=t+(u>0?0:o-i),d=0;d+=u*this.leftPad.length;for(let b=0;b<l;++b)d+=e[p+b].length;d+=c*this.rightPad.length;let h=u+c+l-1;d+=h*this.separator.length,n[r+o]=new Uint8Array(d);let f=n[r+o],g=0,m=b=>b.forEach(v=>f[g++]=v);for(let b=0;b<u;++b)m(this.leftPad),m(this.separator);for(let b=0;b<l-1;++b)m(e[p+b]),m(this.separator);if(l>0){m(e[p+l-1]);for(let b=0;b<c;++b)m(this.separator),m(this.rightPad)}else{for(let b=0;b<c-1;++b)m(this.rightPad),m(this.separator);m(this.rightPad)}}}compute(e,t){let n=e.length,r=t.length;if(r>0){let i=t[0];if(i!==0)throw new Error(`First split value must be 0, got ${i}`);for(let u=1;u<r;++u){let c=t[u]>=i;if(c=c&&t[u]<=n,!c)throw new Error(`Invalid split value ${t[u]}, must be in [${i}, ${n}]`);i=t[u]}if(i!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${i}`)}let s=r-1,a=w.getArrayFromDType("int32",r);if(n===0||r===0){let i=new Array(n);for(let u=0;u<=s;++u)a[u]=0;return[i,a]}a[0]=0;for(let i=1;i<=s;++i){let u=t[i]-t[i-1],c=0;this.nGramWidths.forEach(l=>{c+=this.getNumNGrams(u,l)}),this.preserveShort&&u>0&&c===0&&(c=1),a[i]=a[i-1]+c}let o=new Array(a[s]);for(let i=0;i<s;++i){let u=t[i],c=a[i];if(this.nGramWidths.forEach(l=>{let p=t[i+1]-t[i],d=this.getNumNGrams(p,l);this.createNGrams(e,u,o,c,d,l),c+=d}),this.preserveShort&&c===a[i]){let l=t[i+1]-t[i];if(l===0)continue;let p=l+2*this.padWidth,d=1;this.createNGrams(e,u,o,c,d,p)}}return[o,a]}};function Hk(e,t,n,r,s,a,o,i){return new K8(n,r,s,a,o,i).compute(e,t)}function X8(e,t,n,r){if(!e.length)return;if(t.length===0){for(let a=0;a<e.length;++a)r.push(e.subarray(a,a+1));return}if(t.length===1){let a=t[0],o=e.indexOf(a);for(;o!==-1;){let i=e.subarray(0,o);(!n||i.length!==0)&&r.push(i),e=e.subarray(o+1),o=e.indexOf(a)}(!n||e.length!==0)&&r.push(e);return}let s=0;for(let a=0;a<e.length+1;a++)if(a===e.length||t.indexOf(e[a])!==-1){let o=e.subarray(s,a);(!n||o.length!==0)&&r.push(o),s=a+1}}function jk(e,t,n){let r=e.length,s=[],a=0,o=0,i=new Array(r);for(let d=0;d<r;++d){let h=s.length;X8(e[d],t,n,s);let f=s.length-h;i[d]=f,a+=f,o=Math.max(o,f)}let u=w.getArrayFromDType("int32",a*2),c=new Array(a),l=[r,o],p=0;for(let d=0;d<r;++d)for(let h=0;h<i[d];++h)u[p*2]=d,u[p*2+1]=h,c[p]=s[p],++p;return[u,c,l]}function qk(e,t){let n=w.getArrayFromDType("int32",e.length);for(let r=0;r<e.length;++r)n[r]=w.fingerPrint64(e[r]).modulo(t).getLowBitsUnsigned();return n}var uE=Lt((e,t)=>e-t),Y8=Lk((e,t,n,r)=>({real:e-n,imag:t-r})),Kk=Qt(Gi,uE,Y8),Z8={kernelName:Gi,backendName:"cpu",kernelFunc:Kk};function cE(e,t){let n=new Array(e.rank);for(let s=0;s<n.length;s++)n[s]=e.shape[s]*t[s];let r=ze(n,e.dtype);for(let s=0;s<r.values.length;++s){let a=r.indexToLoc(s),o=new Array(e.rank);for(let u=0;u<o.length;u++)o[u]=a[u]%e.shape[u];let i=e.locToIndex(o);r.values[s]=e.values[i]}return r}var id=(e,t)=>{let n=t.value-e.value;return n===0?e.index-t.index:n};function lE(e,t,n=0,r=e.length-1){for(;r>n;){if(r-n>600){let i=r-n+1,u=t-n+1,c=Math.log(i),l=.5*Math.exp(2*c/3),p=.5*Math.sqrt(c*l*(i-l)/i)*Math.sign(u-i/2),d=Math.max(n,Math.floor(t-u*l/i+p)),h=Math.min(r,Math.floor(t+(i-u)*l/i+p));lE(e,t,d,h)}let s=e[t],a=n,o=r;for(w.swap(e,n,t),id(e[r],s)>0&&w.swap(e,n,r);a<o;){for(w.swap(e,a,o),a++,o--;id(e[a],s)<0;)a=a+1;for(;id(e[o],s)>0;)o=o-1}id(e[n],s)===0?w.swap(e,n,o):(o=o+1,w.swap(e,o,r)),o<=t&&(n=o+1),t<=o&&(r=o-1)}}function dE(e,t,n,r,s){let a=t[t.length-1],[o,i]=[e.length/a,a],u=w.getTypedArrayFromDType(n,o*r),c=w.getTypedArrayFromDType("int32",o*r);for(let p=0;p<o;p++){let d=p*i,h=e.subarray(d,d+i),f=new Array(h.length);h.forEach((v,y)=>f[y]={value:v,index:y}),r<f.length&&(lE(f,r),f=f.slice(0,r)),s&&f.sort(id);let g=p*r,m=u.subarray(g,g+r),b=c.subarray(g,g+r);for(let v=0;v<r;v++)m[v]=f[v].value,b[v]=f[v].index}let l=t.slice();return l[l.length-1]=r,[ze(l,n,u),ze(l,"int32",c)]}function Xk(e,t,n,r){let s=w.parseAxisParam(t,n)[0],a=[1,n[0],1];for(let f=0;f<s;f++)a[0]*=n[f];a[1]=n[s];for(let f=s+1;f<n.length;f++)a[2]*=n[f];let o=new Map,i=new Int32Array(n[s]),u=new Vt(a,r,e),c=[],l=a[0]===1&&a[2]===1;for(let f=0;f<n[s];f++){let g;if(l)g=e[f].toString();else{let b=[];for(let v=0;v<a[0];v++)for(let y=0;y<a[2];y++)b.push(u.get(v,f,y));g=b.join(",")}let m=o.get(g);if(m!=null)i[f]=m;else{let b=o.size;o.set(g,b),i[f]=b,c.push(f)}}let p=a.slice();p[1]=o.size;let d=new Vt(p,r);c.forEach((f,g)=>{for(let m=0;m<a[0];m++)for(let b=0;b<a[2];b++)d.set(u.get(m,f,b),m,g,b)});let h=n.slice();return h[s]=p[1],{outputValues:d.values,outputShape:h,indices:i}}var J8="4.9.0";tm("cpu",()=>new Qm,1);var pE=it(Yo,e=>e>=0?e:Math.exp(e)-1),Q8={kernelName:Yo,backendName:"cpu",kernelFunc:pE};function hE(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{alpha:a}=r;be([s],"leakyRelu");let o=w.sizeFromShape(s.shape),i=n.data.get(s.dataId).values,u=w.getTypedArrayFromDType("float32",o);for(let c=0;c<i.length;c++)u[c]=i[c]<0?a*i[c]:i[c];return n.makeTensorInfo(s.shape,"float32",u)}var eK={kernelName:ui,backendName:"cpu",kernelFunc:hE},tK=Lt((e,t)=>e<0?t*e:e);function fE(e){let{inputs:t,backend:n}=e,{x:r,alpha:s}=t;be([r,s],"prelu");let a=n.data.get(r.dataId).values,o=n.data.get(s.dataId).values,[i,u]=tK(r.shape,s.shape,a,o,"float32");return n.makeTensorInfo(u,"float32",i)}var nK={kernelName:Si,backendName:"cpu",kernelFunc:fE},mE=it(Ni,e=>Math.max(0,e)),rK={kernelName:Ni,backendName:"cpu",kernelFunc:mE},gE=it(Ai,e=>Math.min(Math.max(0,e),6)),sK={kernelName:Ai,backendName:"cpu",kernelFunc:gE};function Ef(e,t,n,r,s){if(n==="linear")return hs({inputs:{x:t},backend:e});if(n==="relu")return mE({inputs:{x:t},backend:e});if(n==="elu")return pE({inputs:{x:t},backend:e});if(n==="relu6")return gE({inputs:{x:t},backend:e});if(n==="prelu")return fE({inputs:{x:t,alpha:r},backend:e});if(n==="leakyrelu")return hE({inputs:{x:t},backend:e,attrs:{alpha:s}});if(n==="sigmoid")return nE({inputs:{x:t},backend:e});throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}function yt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{shape:a}=r,o=w.sizeFromShape(s.shape),i=w.inferFromImplicitShape(a,o),u=w.sizeFromShape(i);w.assert(o===u,()=>`The new shape (${i}) has ${u} elements and the old shape (${s.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`),n.incRef(s.dataId);let c=n.data.get(s.dataId);if(c.complexTensorInfos!=null){let l=c.complexTensorInfos.real,p=c.complexTensorInfos.imag;l.shape=i,p.shape=i}return{dataId:s.dataId,shape:i,dtype:s.dtype}}var aK={kernelName:qc,backendName:"cpu",kernelFunc:yt};function bE(e){let{inputs:t,backend:n,attrs:r}=e,{a:s,b:a}=t,{transposeA:o,transposeB:i}=r;be([s,a],"matMul");let u=s.shape.length,c=a.shape.length,l=o?s.shape[u-2]:s.shape[u-1],p=i?a.shape[c-1]:a.shape[c-2],d=o?s.shape[u-1]:s.shape[u-2],h=i?a.shape[c-2]:a.shape[c-1],f=s.shape.slice(0,-2),g=a.shape.slice(0,-2),m=w.sizeFromShape(f),b=w.sizeFromShape(g),y=dl.assertAndGetBroadcastShape(s.shape.slice(0,-2),a.shape.slice(0,-2)).concat([d,h]);w.assert(l===p,()=>`Error in matMul: inner shapes (${l}) and (${p}) of Tensors with shapes ${s.shape} and ${a.shape} and transposeA=${o} and transposeB=${i} must match.`);let x=o?[m,l,d]:[m,d,l],k=i?[b,h,p]:[b,p,h],S=yt({inputs:{x:s},backend:n,attrs:{shape:x}}),N=yt({inputs:{x:a},backend:n,attrs:{shape:k}}),E=o?S.shape[1]:S.shape[2],$=o?S.shape[2]:S.shape[1],R=i?N.shape[1]:N.shape[2],D=Math.max(m,b),F=n.data.get(S.dataId).values,C=n.data.get(N.dataId).values,L=w.computeStrides(S.shape),U=w.computeStrides(N.shape),[H,K,q]=o?[L[0],1,L[1]]:[L[0],L[1],1],[Z,J,ee]=i?[1,U[1],U[0]]:[U[1],1,U[0]],se=$*R,te=ze([D,$,R],S.dtype),oe=te.values,ne=n.blockSize;for(let le=0;le<D;le++){let ce=le%m,we=le%b;for(let ye=0;ye<$;ye+=ne){let Ce=Math.min(ye+ne,$);for(let Ae=0;Ae<R;Ae+=ne){let qe=Math.min(Ae+ne,R);for(let at=0;at<E;at+=ne){let ht=Math.min(at+ne,E);for(let st=ye;st<Ce;st++)for(let Je=Ae;Je<qe;Je++){let Be=0;for(let ot=at;ot<ht;ot++){let qn=F[ce*H+st*K+ot*q],$t=C[ot*Z+Je*J+we*ee];Be+=qn*$t}oe[le*se+(st*R+Je)]+=Be}}}}}return n.disposeIntermediateTensorInfo(S),n.disposeIntermediateTensorInfo(N),n.makeTensorInfo(y,te.dtype,te.values)}var oK={kernelName:Lo,backendName:"cpu",kernelFunc:bE};function iK(e){let{inputs:t,backend:n,attrs:r}=e,{a:s,b:a,bias:o,preluActivationWeights:i}=t,{transposeA:u,transposeB:c,activation:l,leakyreluAlpha:p}=r,d,h,f,g=[];d=bE({inputs:{a:s,b:a},attrs:{transposeA:u,transposeB:c},backend:n}),o&&(h=ac({inputs:{a:d,b:o},backend:n}),g.push(d),d=h),l&&(f=Ef(n,d,l,i,p),g.push(d),d=f);for(let b of g)n.disposeIntermediateTensorInfo(b);return d}var uK={kernelName:co,backendName:"cpu",kernelFunc:iK},cK=it(Eo,e=>Math.acos(e)),lK={kernelName:Eo,backendName:"cpu",kernelFunc:cK},dK=it(Ao,e=>Math.acosh(e)),pK={kernelName:Ao,backendName:"cpu",kernelFunc:dK};function hK(e){let{inputs:t,backend:n}=e,r=t;be(t,"addN");let s=r.map(i=>n.data.get(i.dataId).values),a=ze(r[0].shape,r[0].dtype),o=a.values;for(let i=0;i<r.length;i++){let u=s[i];for(let c=0;c<o.length;c++)o[c]+=u[c]}return n.makeTensorInfo(a.shape,a.dtype,a.values)}var fK={kernelName:Do,backendName:"cpu",kernelFunc:hK};function mK(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:o}=r;be(s,"all");let i=w.parseAxisParam(a,s.shape),u=i,c=T.getAxesPermutation(u,s.shape.length),l=s;c!=null&&(l=Un({inputs:{x:s},backend:n,attrs:{perm:c}}),u=T.getInnerMostAxes(u.length,s.shape.length)),T.assertAxesAreInnerMostDims("all",u,l.shape.length);let[p,d]=T.computeOutAndReduceShapes(l.shape,u),h=w.sizeFromShape(d),f=w.makeZerosTypedArray(w.sizeFromShape(p),l.dtype),g=n.data.get(l.dataId).values;for(let b=0;b<f.length;++b){let v=b*h,y=g[v];for(let x=0;x<h;++x){let k=g[v+x];y=y&&k}f[b]=y}c!=null&&n.disposeIntermediateTensorInfo(l);let m=n.makeTensorInfo(p,l.dtype,f);if(o){let b=T.expandShapeToKeepDim(p,i),v=yt({inputs:{x:m},backend:n,attrs:{shape:b}});return n.disposeIntermediateTensorInfo(m),v}return m}var gK={kernelName:lc,backendName:"cpu",kernelFunc:mK};function bK(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:o}=r;be(s,"any");let i=w.parseAxisParam(a,s.shape),u=i,c=T.getAxesPermutation(u,s.shape.length),l=s;c!=null&&(l=Un({inputs:{x:s},backend:n,attrs:{perm:c}}),u=T.getInnerMostAxes(u.length,s.shape.length)),T.assertAxesAreInnerMostDims("any",u,l.shape.length);let[p,d]=T.computeOutAndReduceShapes(l.shape,u),h=w.sizeFromShape(d),f=w.makeZerosTypedArray(w.sizeFromShape(p),l.dtype),g=n.data.get(l.dataId).values;for(let b=0;b<f.length;++b){let v=b*h,y=g[v];for(let x=0;x<h;++x){let k=g[v+x];y=y||k}f[b]=y}c!=null&&n.disposeIntermediateTensorInfo(l);let m=n.makeTensorInfo(p,l.dtype,f);if(o){let b=T.expandShapeToKeepDim(p,i),v=yt({inputs:{x:m},backend:n,attrs:{shape:b}});return n.disposeIntermediateTensorInfo(m),v}return m}var yK={kernelName:dc,backendName:"cpu",kernelFunc:bK};function vK(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r;be(s,"argMax");let o=w.parseAxisParam(a,s.shape),i=T.getAxesPermutation(o,s.shape.length),u=s,c=[];i!=null&&(u=Un({inputs:{x:s},backend:n,attrs:{perm:i}}),c.push(u),o=T.getInnerMostAxes(o.length,u.shape.length)),o=[o[0]],T.assertAxesAreInnerMostDims("argMax",o,u.shape.length);let[l,p]=T.computeOutAndReduceShapes(u.shape,o),d=w.sizeFromShape(l),h=w.makeZerosTypedArray(d,"int32"),f=w.sizeFromShape(p),g=n.data.get(u.dataId).values;for(let m=0;m<h.length;++m){let b=m*f,v=g[b],y=0;for(let x=0;x<f;++x){let k=g[b+x];k>v&&(v=k,y=x)}h[m]=y}return c.forEach(m=>n.disposeIntermediateTensorInfo(m)),n.makeTensorInfo(l,"int32",h)}var xK={kernelName:pc,backendName:"cpu",kernelFunc:vK};function wK(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r;be(s,"argMin");let o=w.parseAxisParam(a,s.shape),i=T.getAxesPermutation(o,s.shape.length),u=s,c=[];i!=null&&(u=Un({inputs:{x:s},backend:n,attrs:{perm:i}}),c.push(u),o=T.getInnerMostAxes(o.length,u.shape.length)),o=[o[0]],T.assertAxesAreInnerMostDims("argMin",o,u.shape.length);let[l,p]=T.computeOutAndReduceShapes(u.shape,o),d=w.sizeFromShape(l),h=w.makeZerosTypedArray(d,"int32"),f=w.sizeFromShape(p),g=n.data.get(u.dataId).values;for(let m=0;m<h.length;++m){let b=m*f,v=g[b],y=0;for(let x=0;x<f;++x){let k=g[b+x];k<v&&(v=k,y=x)}h[m]=y}return c.forEach(m=>n.disposeIntermediateTensorInfo(m)),n.makeTensorInfo(l,"int32",h)}var IK={kernelName:hc,backendName:"cpu",kernelFunc:wK},kK=it($o,e=>Math.asin(e)),SK={kernelName:$o,backendName:"cpu",kernelFunc:kK},CK=it(Fo,e=>Math.asinh(e)),TK={kernelName:Fo,backendName:"cpu",kernelFunc:CK},NK=it(Ro,e=>Math.atan(e)),_K={kernelName:Ro,backendName:"cpu",kernelFunc:NK},EK=Lt((e,t)=>Math.atan2(e,t)),AK=Qt(Oo,EK),DK={kernelName:Oo,backendName:"cpu",kernelFunc:AK},$K=it(Po,e=>Math.atanh(e)),FK={kernelName:Po,backendName:"cpu",kernelFunc:$K};function Yk(e,t,n,r,s,a){let o=s.strideHeight,i=s.strideWidth,u=s.dilationHeight,c=s.dilationWidth,l=s.effectiveFilterHeight,p=s.effectiveFilterWidth,d=s.padInfo.top,h=s.padInfo.left,f=a==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,g=ze(s.outShape,n),m=g.values,b=s.outShape[1]*s.outShape[2]*s.outShape[3],v=s.outShape[2]*s.outShape[3],y=s.outShape[3];for(let x=0;x<s.batchSize;++x){let k=x*b,S=x*r[0];for(let N=0;N<s.inChannels;++N)for(let E=0;E<s.outHeight;++E){let $=E*o-d,R=Math.max(0,$),D=Math.min(s.inHeight,l+$),F=k+E*v;for(let C=0;C<s.outWidth;++C){let L=C*i-h,U=Math.max(0,L),H=Math.min(s.inWidth,p+L),K=f,q=0,Z=0;for(let ee=R;ee<D;ee+=u){let se=S+ee*r[1];for(let te=U;te<H;te+=c){let oe=se+te*r[2],ne=e[oe+N];a==="max"&&ne>K?K=ne:a==="avg"&&(q+=ne,Z++)}if(isNaN(K))break}let J=F+C*y+N;m[J]=a==="avg"?q/Z:K}}}return g}function yE(e,t,n,r,s=!1,a=!1){let o=ze(r.outShape,"int32"),i=r.strideHeight,u=r.strideWidth,c=r.dilationHeight,l=r.dilationWidth,p=r.effectiveFilterHeight,d=r.effectiveFilterWidth,h=r.padInfo.top,f=r.padInfo.left,g=ze(t,n,e);for(let m=0;m<r.batchSize;++m)for(let b=0;b<r.inChannels;++b)for(let v=0;v<r.outHeight;++v){let y=v*i-h,x=y;for(;x<0;)x+=c;let k=Math.min(r.inHeight,p+y);for(let S=0;S<r.outWidth;++S){let N=S*u-f,E=N;for(;E<0;)E+=l;let $=Math.min(r.inWidth,d+N),R=Number.NEGATIVE_INFINITY,D=-1;for(let F=x;F<k;F+=c){let C=F-y;for(let L=E;L<$;L+=l){let U=L-N,H=g.get(m,F,L,b);H>R&&(R=H,s?D=a?((m*r.inHeight+F)*r.inWidth+L)*r.inChannels+b:(F*r.inWidth+L)*r.inChannels+b:D=C*d+U)}}o.set(D,m,v,S,b)}}return o}function vE(e,t,n,r,s,a){let o=s.strideDepth,i=s.strideHeight,u=s.strideWidth,c=s.dilationDepth,l=s.dilationHeight,p=s.dilationWidth,d=s.effectiveFilterDepth,h=s.effectiveFilterHeight,f=s.effectiveFilterWidth,g=s.padInfo.front,m=s.padInfo.top,b=s.padInfo.left,v=a==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,y=ze(s.outShape,n),x=y.values,k=s.outShape[1]*s.outShape[2]*s.outShape[3]*s.outShape[4],S=s.outShape[2]*s.outShape[3]*s.outShape[4],N=s.outShape[3]*s.outShape[4],E=s.outShape[4];for(let $=0;$<s.batchSize;++$){let R=$*k,D=$*r[0];for(let F=0;F<s.inChannels;++F)for(let C=0;C<s.outDepth;++C){let L=C*o-g,U=L;for(;U<0;)U+=c;let H=Math.min(s.inDepth,d+L),K=R+C*S;for(let q=0;q<s.outHeight;++q){let Z=q*i-m,J=Z;for(;J<0;)J+=l;let ee=Math.min(s.inHeight,h+Z),se=K+q*N;for(let te=0;te<s.outWidth;++te){let oe=te*u-b,ne=oe;for(;ne<0;)ne+=p;let le=Math.min(s.inWidth,f+oe),ce=se+te*E,we=v,ye=0,Ce=0;for(let qe=U;qe<H;qe+=c){let at=D+qe*r[1];for(let ht=J;ht<ee;ht+=l){let st=at+ht*r[2];for(let Je=ne;Je<le;Je+=p){let Be=st+Je*r[3],ot=e[Be+F];if(a==="max"&&ot>we?we=ot:a==="avg"&&(ye+=ot,Ce++),isNaN(we))break}if(isNaN(we))break}if(isNaN(we))break}let Ae=ce+F;x[Ae]=a==="avg"?ye/Math.max(Ce,1):we}}}}return y}function RK(e,t){let n=ze(t.outShape,"int32"),r=t.strideDepth,s=t.strideHeight,a=t.strideWidth,o=t.dilationDepth,i=t.dilationHeight,u=t.dilationWidth,c=t.effectiveFilterDepth,l=t.effectiveFilterHeight,p=t.effectiveFilterWidth,d=t.padInfo.front,h=t.padInfo.top,f=t.padInfo.left;for(let g=0;g<t.batchSize;++g)for(let m=0;m<t.inChannels;++m)for(let b=0;b<t.outDepth;++b){let v=b*r-d,y=v;for(;y<0;)y+=o;let x=Math.min(t.inDepth,c+v);for(let k=0;k<t.outHeight;++k){let S=k*s-h,N=S;for(;N<0;)N+=i;let E=Math.min(t.inHeight,l+S);for(let $=0;$<t.outWidth;++$){let R=$*a-f,D=R;for(;D<0;)D+=u;let F=Math.min(t.inWidth,p+R),C=Number.NEGATIVE_INFINITY,L=-1;for(let U=y;U<x;U+=o){let H=U-v;for(let K=N;K<E;K+=i){let q=K-S;for(let Z=D;Z<F;Z+=u){let J=Z-R,ee=e.get(g,U,K,Z,m);ee>=C&&(C=ee,L=H*l*p+q*l+J)}}}n.set(L,g,b,k,$,m)}}}return n}function PK(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t;be(s,"avgPool");let{filterSize:a,strides:o,pad:i,dimRoundingMode:u}=r,c=1;w.assert(T.eitherStridesOrDilationsAreOne(o,c),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);let l=T.computePool2DInfo(s.shape,a,o,c,i,u),p;if(l.filterWidth===1&&l.filterHeight===1&&w.arraysEqual(l.inShape,l.outShape))p=hs({inputs:{x:s},backend:n});else{let d=n.data.get(s.dataId).values,h=w.computeStrides(s.shape),f=Yk(d,s.shape,s.dtype,h,l,"avg");p=n.makeTensorInfo(l.outShape,s.dtype,f.values)}return p}var OK={kernelName:Mo,backendName:"cpu",kernelFunc:PK};function MK(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:o,pad:i,dimRoundingMode:u,dataFormat:c}=r;be(s,"avgPool3d");let l=T.computePool3DInfo(s.shape,a,o,1,i,u,c),p=n.data.get(s.dataId).values,d=vE(p,s.shape,s.dtype,w.computeStrides(s.shape),l,"avg");return n.makeTensorInfo(d.shape,"float32",d.values)}var LK={kernelName:fc,backendName:"cpu",kernelFunc:MK};function zK(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,{filterSize:o,strides:i,pad:u,dimRoundingMode:c}=r;be([s,a],"avgPool3DGrad");let l=T.computePool3DInfo(a.shape,o,i,1,u,c),p=l.strideDepth,d=l.strideHeight,h=l.strideWidth,f=l.filterDepth,g=l.filterHeight,m=l.filterWidth,b=l.dilationDepth,v=l.dilationHeight,y=l.dilationWidth,x=l.effectiveFilterDepth,k=l.effectiveFilterHeight,S=l.effectiveFilterWidth,N=x-1-l.padInfo.front,E=S-1-l.padInfo.left,$=k-1-l.padInfo.top,R=ze(a.shape,"float32"),D=1/(f*g*m),F=n.bufferSync(s);for(let C=0;C<l.batchSize;++C)for(let L=0;L<l.inChannels;++L)for(let U=0;U<l.inDepth;++U)for(let H=0;H<l.inHeight;++H)for(let K=0;K<l.inWidth;++K){let q=U-N,Z=H-$,J=K-E,ee=0;for(let se=0;se<x;se+=b){let te=(q+se)/p;if(!(te<0||te>=l.outDepth||Math.floor(te)!==te))for(let oe=0;oe<k;oe+=v){let ne=(Z+oe)/d;if(!(ne<0||ne>=l.outHeight||Math.floor(ne)!==ne))for(let le=0;le<S;le+=y){let ce=(J+le)/h;if(ce<0||ce>=l.outWidth||Math.floor(ce)!==ce)continue;let we=F.get(C,te,ne,ce,L);ee+=we}}}R.set(ee*D,C,U,H,K,L)}return n.makeTensorInfo(R.shape,R.dtype,R.values)}var BK={kernelName:Bd,backendName:"cpu",kernelFunc:zK};function WK(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,o=a;be([s,a],"avgPoolGrad");let{filterSize:i,strides:u,pad:c}=r,l=T.computePool2DInfo(o.shape,i,u,1,c),p=l.strideHeight,d=l.strideWidth,h=l.filterHeight,f=l.filterWidth,g=l.dilationHeight,m=l.dilationWidth,b=l.effectiveFilterHeight,v=l.effectiveFilterWidth,y=v-1-l.padInfo.left,x=b-1-l.padInfo.top,k=ze(o.shape,"float32"),S=1/(h*f),N=n.data.get(s.dataId).values,E=ze(s.shape,"float32",N);for(let $=0;$<l.batchSize;++$)for(let R=0;R<l.inChannels;++R)for(let D=0;D<l.inHeight;++D)for(let F=0;F<l.inWidth;++F){let C=D-x,L=F-y,U=0;for(let H=0;H<b;H+=g){let K=(C+H)/p;if(!(K<0||K>=l.outHeight||Math.floor(K)!==K))for(let q=0;q<v;q+=m){let Z=(L+q)/d;if(Z<0||Z>=l.outWidth||Math.floor(Z)!==Z)continue;let J=E.get($,K,Z,R);U+=J}}k.set(U*S,$,D,F,R)}return n.makeTensorInfo(k.shape,k.dtype,k.values)}var VK={kernelName:zd,backendName:"cpu",kernelFunc:WK};function UK(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,scale:a,offset:o,mean:i,variance:u}=t;w.assert(i.shape.length===u.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),w.assert(o==null||i.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),w.assert(a==null||i.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),be([s,i,u,a,o],"batchNorm");let{varianceEpsilon:c}=r;c==null&&(c=.001);let l=n.data.get(s.dataId).values,p=n.data.get(i.dataId).values,d=n.data.get(u.dataId).values,h=a?n.data.get(a.dataId).values:new Float32Array([1]),f=o?n.data.get(o.dataId).values:new Float32Array([0]),g=new Float32Array(l.length),m=f.length,b=h.length,v=d.length,y=p.length,x=0,k=0,S=0,N=0;for(let E=0;E<l.length;++E)g[E]=f[x++]+(l[E]-p[k++])*h[S++]/Math.sqrt(d[N++]+c),x>=m&&(x=0),k>=y&&(k=0),S>=b&&(S=0),N>=v&&(N=0);return n.makeTensorInfo(s.shape,s.dtype,g)}var GK={kernelName:ni,backendName:"cpu",kernelFunc:UK};function HK(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,crops:o}=r;be([s],"batchToSpaceND");let i=a.reduce((b,v)=>b*v),u=T.getReshaped(s.shape,a,i),c=T.getPermuted(u.length,a.length),l=T.getReshapedPermuted(s.shape,a,i),p=T.getSliceBeginCoords(o,a.length),d=T.getSliceSize(l,o,a.length),h=yt({inputs:{x:s},backend:n,attrs:{shape:u}}),f=Un({inputs:{x:h},backend:n,attrs:{perm:c}}),g=yt({inputs:{x:f},backend:n,attrs:{shape:l}}),m=ko({inputs:{x:g},backend:n,attrs:{begin:p,size:d}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),m}var jK={kernelName:mc,backendName:"cpu",kernelFunc:HK};function qK(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:o}=r,i=n.data.get(s.dataId).values,u=n.data.get(a.dataId).values,c=zk(i,u,a.dtype,a.shape,o);return n.makeTensorInfo([o],a.dtype,c)}var KK={kernelName:gc,backendName:"cpu",kernelFunc:qK};function XK(e){let{inputs:t,backend:n}=e,{s0:r,s1:s}=t,a=n.data.get(r.dataId).values,o=n.data.get(s.dataId).values,i=T.assertAndGetBroadcastShape(Array.from(a),Array.from(o));return n.makeTensorInfo([i.length],"int32",Int32Array.from(i))}var YK={kernelName:Wd,backendName:"cpu",kernelFunc:XK},ZK=it(Ca,(e,t)=>{let n=t;return e>n.clipValueMax?n.clipValueMax:e<n.clipValueMin?n.clipValueMin:e}),JK={kernelName:Ca,backendName:"cpu",kernelFunc:ZK},QK=e=>{let{x:t}=e.inputs,n=e.backend,r=new Float32Array(w.sizeFromShape(t.shape)),s=n.data.get(t.dataId),a=s.complexTensorInfos.real,o=s.complexTensorInfos.imag,i=n.data.get(a.dataId).values,u=n.data.get(o.dataId).values;for(let c=0;c<i.length;c++){let l=i[c],p=u[c];r[c]=Math.hypot(l,p)}return n.makeOutput(r,t.shape,"float32")},eX={kernelName:Vd,backendName:"cpu",kernelFunc:QK};function oc(e){let{inputs:t,backend:n}=e,{input:r}=t,s=n.data.get(r.dataId).complexTensorInfos.imag,a=n.data.get(s.dataId).values;return n.makeTensorInfo(s.shape,s.dtype,a)}var tX={kernelName:Kf,backendName:"cpu",kernelFunc:oc};function ic(e){let{inputs:t,backend:n,attrs:r}=e,{axis:s}=r,a=w.parseAxisParam(s,t[0].shape)[0],o=t.map(g=>g.shape);T.assertParamsConsistent(o,a);let i=T.computeOutShape(t.map(g=>g.shape),a);if(w.sizeFromShape(i)===0)return n.makeTensorInfo(i,t[0].dtype,[]);let u=t.filter(g=>w.sizeFromShape(g.shape)>0);if(u.length===1)return hs({inputs:{x:u[0]},backend:n});if(u[0].dtype==="complex64"){let g=u.map(x=>Io({inputs:{input:x},backend:n})),m=u.map(x=>oc({inputs:{input:x},backend:n})),b=ic({inputs:g,backend:n,attrs:{axis:a}}),v=ic({inputs:m,backend:n,attrs:{axis:a}}),y=Qn({inputs:{real:b,imag:v},backend:n});return g.forEach(x=>n.disposeIntermediateTensorInfo(x)),m.forEach(x=>n.disposeIntermediateTensorInfo(x)),n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(v),y}let c=u.map(g=>{let b=[-1,w.sizeFromShape(g.shape.slice(a))];return yt({inputs:{x:g},backend:n,attrs:{shape:b}})}),l=c.map(g=>({vals:n.data.get(g.dataId).values,shape:g.shape}));i=T.computeOutShape(c.map(g=>g.shape),1);let p=c[0].shape[0]===1,d=Bk(l,i,t[0].dtype,p),h=T.computeOutShape(u.map(g=>g.shape),a),f=n.makeTensorInfo(h,t[0].dtype,d);return c.forEach(g=>n.disposeIntermediateTensorInfo(g)),f}var nX={kernelName:yc,backendName:"cpu",kernelFunc:ic};function xE(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:o,pad:i,dataFormat:u,dilations:c,dimRoundingMode:l}=r;be([s,a],"conv2d");let p=T.convertConv2DDataFormat(u),d=T.computeConv2DInfo(s.shape,a.shape,o,c,i,l,!1,p),h=d.filterHeight,f=d.filterWidth,g=d.dilationHeight,m=d.dilationWidth,b=d.padInfo.left,v=d.padInfo.top,y=d.dataFormat==="channelsLast",x=new Vt(d.outShape,s.dtype),k=w.computeStrides(s.shape),S=w.computeStrides(a.shape),N=k[0],E=y?k[1]:k[2],$=y?k[2]:1,R=y?1:k[1],D=x.strides[0],F=y?x.strides[1]:x.strides[2],C=y?x.strides[2]:1,L=y?1:x.strides[1],U=n.data.get(s.dataId).values,H=n.data.get(a.dataId).values,K=x.values;for(let q=0;q<d.batchSize;++q){let Z=q*N,J=q*D;for(let ee=0;ee<d.outHeight;++ee){let se=J+ee*F,te=ee*d.strideHeight-v;for(let oe=0;oe<h;++oe){let ne=te+oe*g;if(ne<0||ne>=d.inHeight)continue;let le=oe*S[0],ce=Z+ne*E;for(let we=0;we<d.outWidth;++we){let ye=se+we*C,Ce=we*d.strideWidth-b;for(let Ae=0;Ae<f;++Ae){let qe=Ce+Ae*m;if(qe<0||qe>=d.inWidth)continue;let at=le+Ae*S[1],ht=ce+qe*$,st=at;for(let Je=0;Je<d.inChannels;++Je){let Be=U[ht+Je*R];for(let ot=0;ot<d.outChannels;++ot)K[ye+ot*L]+=Be*H[st+ot];st+=d.outChannels}}}}}}return n.makeTensorInfo(x.shape,x.dtype,K)}var rX={kernelName:Wo,backendName:"cpu",kernelFunc:xE};function sX(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:o,pad:i,dataFormat:u,dimRoundingMode:c,filterShape:l}=r;be([s,a],"conv2dBackpropFilter");let p=T.convertConv2DDataFormat(u),d=T.computeConv2DInfo(s.shape,l,o,1,i,c,!1,p),{strideHeight:h,strideWidth:f,filterHeight:g,filterWidth:m}=d,b=d.dataFormat==="channelsLast",v=new Vt(d.filterShape,"float32"),y=d.padInfo.left,x=d.padInfo.top,k=n.data.get(s.dataId).values,S=n.data.get(a.dataId).values,N=new Vt(s.shape,s.dtype,k),E=new Vt(a.shape,a.dtype,S);for(let $=0;$<g;++$){let R=Math.max(0,Math.ceil((x-$)/h)),D=Math.min(d.outHeight,(d.inHeight+x-$)/h);for(let F=0;F<m;++F){let C=Math.max(0,Math.ceil((y-F)/f)),L=Math.min(d.outWidth,(d.inWidth+y-F)/f);for(let U=0;U<d.inChannels;++U)for(let H=0;H<d.outChannels;++H){let K=0;for(let q=0;q<d.batchSize;++q)for(let Z=R;Z<D;++Z){let J=$+Z*h-x;for(let ee=C;ee<L;++ee){let se=F+ee*f-y;b?K+=N.get(q,J,se,U)*E.get(q,Z,ee,H):K+=N.get(q,U,J,se)*E.get(q,H,Z,ee)}}v.set(K,$,F,U,H)}}}return n.makeTensorInfo(v.shape,v.dtype,v.values)}var aX={kernelName:Wf,backendName:"cpu",kernelFunc:sX};function oX(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{inputShape:o,strides:i,pad:u,dataFormat:c,dimRoundingMode:l}=r;be([s,a],"conv2dBackpropInput");let p=w.computeStrides(a.shape),d=w.computeStrides(s.shape),h=T.convertConv2DDataFormat(c),f=T.computeConv2DInfo(o,a.shape,i,1,u,l,!1,h),g=new Vt(f.inShape,"float32"),m=g.values,b=n.data.get(s.dataId).values,v=n.data.get(a.dataId).values,[y,x,k]=p,{batchSize:S,filterHeight:N,filterWidth:E,inChannels:$,inHeight:R,inWidth:D,outChannels:F,outHeight:C,outWidth:L,strideHeight:U,strideWidth:H}=f;h=f.dataFormat;let K=N-1-f.padInfo.top,q=E-1-f.padInfo.left,Z=h==="channelsLast",J=g.strides[0],ee=Z?g.strides[1]:g.strides[2],se=Z?g.strides[2]:1,te=Z?1:g.strides[1],oe=d[0],ne=Z?d[1]:d[2],le=Z?d[2]:1,ce=Z?1:d[1];for(let we=0;we<S;++we)for(let ye=0;ye<$;++ye)for(let Ce=0;Ce<R;++Ce){let Ae=Ce-K,qe=Math.max(0,Math.ceil(Ae/U)),at=Math.min(C,(N+Ae)/U);for(let ht=0;ht<D;++ht){let st=ht-q,Je=Math.max(0,Math.ceil(st/H)),Be=Math.min(L,(E+st)/H),ot=0;for(let $t=qe;$t<at;++$t){let kr=$t*U-Ae;for(let dn=Je;dn<Be;++dn){let Sr=dn*H-st,kn=oe*we+ne*$t+le*dn,Kn=y*(N-1-kr)+x*(E-1-Sr)+k*ye;for(let wt=0;wt<F;++wt){let Pn=b[kn+ce*wt],gn=v[Kn+wt];ot+=Pn*gn}}}let qn=J*we+ee*Ce+se*ht+te*ye;m[qn]=ot}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}var iX={kernelName:Vo,backendName:"cpu",kernelFunc:oX};function uX(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:o,pad:i,dilations:u}=r;be([s,a],"conv3d");let c=T.computeConv3DInfo(s.shape,a.shape,o,u,i),{filterDepth:l,filterHeight:p,filterWidth:d,dilationDepth:h,dilationHeight:f,dilationWidth:g,padInfo:m}=c,b=m.front,v=m.left,y=m.top,x=new Vt(c.outShape,s.dtype),k=n.data.get(s.dataId).values,S=n.data.get(a.dataId).values,N=x.values,E=w.computeStrides(s.shape),$=w.computeStrides(a.shape);for(let R=0;R<c.batchSize;++R){let D=R*E[0],F=R*x.strides[0];for(let C=0;C<c.outDepth;++C){let L=F+C*x.strides[1],U=C*c.strideDepth-b;for(let H=0;H<l;++H){let K=U+H*h;if(K<0||K>=c.inDepth)continue;let q=H*$[0],Z=D+K*E[1];for(let J=0;J<c.outHeight;++J){let ee=L+J*x.strides[2],se=J*c.strideHeight-y;for(let te=0;te<p;++te){let oe=se+te*f;if(oe<0||oe>=c.inHeight)continue;let ne=q+te*$[1],le=Z+oe*E[2];for(let ce=0;ce<c.outWidth;++ce){let we=ee+ce*c.outChannels,ye=ce*c.strideWidth-v;for(let Ce=0;Ce<d;++Ce){let Ae=ye+Ce*g;if(Ae<0||Ae>=c.inWidth)continue;let qe=ne+Ce*$[2],at=le+Ae*c.inChannels,ht=qe;for(let st=0;st<c.inChannels;++st){let Je=k[at+st];for(let Be=0;Be<c.outChannels;++Be)N[we+Be]+=Je*S[ht+Be];ht+=c.outChannels}}}}}}}}return n.makeTensorInfo(x.shape,x.dtype,x.values)}var cX={kernelName:Uo,backendName:"cpu",kernelFunc:uX};function lX(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:o,pad:i,filterShape:u}=r;be([s,a],"conv3dBackpropFilterV2");let c=w.computeStrides(s.shape),l=w.computeStrides(a.shape),p=T.computeConv3DInfo(s.shape,u,o,1,i),d=p.strideDepth,h=p.strideHeight,f=p.strideWidth,g=p.filterDepth,m=p.filterHeight,b=p.filterWidth,v=new Vt(p.filterShape,"float32"),y=v.values,[x,k,S,N]=v.strides,E=n.data.get(a.dataId).values,[$,R,D,F]=l,C=n.data.get(s.dataId).values,[L,U,H,K]=c,q=p.padInfo.front,Z=p.padInfo.left,J=p.padInfo.top;for(let ee=0;ee<g;++ee){let se=Math.max(0,Math.ceil((q-ee)/d)),te=Math.min(p.outDepth,(p.inDepth+q-ee)/d),oe=ee*x;for(let ne=0;ne<m;++ne){let le=Math.max(0,Math.ceil((J-ne)/h)),ce=Math.min(p.outHeight,(p.inHeight+J-ne)/h),we=ne*k+oe;for(let ye=0;ye<b;++ye){let Ce=Math.max(0,Math.ceil((Z-ye)/f)),Ae=Math.min(p.outWidth,(p.inWidth+Z-ye)/f),qe=ye*S+we;for(let at=0;at<p.inChannels;++at){let ht=at*N+qe;for(let st=0;st<p.outChannels;++st){let Je=0;for(let Be=0;Be<p.batchSize;++Be){let ot=Be*L,qn=Be*$;for(let $t=se;$t<te;++$t){let dn=(ee+$t*d-q)*U+ot,Sr=$t*R+qn;for(let kn=le;kn<ce;++kn){let wt=(ne+kn*h-J)*H+dn,Pn=kn*D+Sr;for(let gn=Ce;gn<Ae;++gn){let Zs=(ye+gn*f-Z)*K+wt,Cr=gn*F+Pn;Je+=C[Zs+at]*E[Cr+st]}}}}y[ht+st]=Je}}}}}return n.makeTensorInfo(v.shape,v.dtype,v.values)}var dX={kernelName:vc,backendName:"cpu",kernelFunc:lX};function pX(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{pad:o,strides:i,inputShape:u}=r;be([s],"conv3dBackpropInputV2");let c=w.computeStrides(s.shape),l=w.computeStrides(a.shape),p=T.computeConv3DInfo(u,a.shape,i,1,o),d=new Vt(p.inShape,"float32"),h=d.values,[f,g,m,b]=d.strides,v=n.data.get(s.dataId).values,[y,x,k,S]=c,N=n.data.get(a.dataId).values,[E,$,R,D]=l,{batchSize:F,filterDepth:C,filterHeight:L,filterWidth:U,inChannels:H,inDepth:K,inHeight:q,inWidth:Z,outChannels:J,outDepth:ee,outHeight:se,outWidth:te,strideDepth:oe,strideHeight:ne,strideWidth:le}=p,ce=C-1-p.padInfo.front,we=L-1-p.padInfo.top,ye=U-1-p.padInfo.left;for(let Ce=0;Ce<F;++Ce)for(let Ae=0;Ae<H;++Ae)for(let qe=0;qe<K;++qe){let at=qe-ce,ht=Math.max(0,Math.ceil(at/oe)),st=Math.min(ee,(C+at)/oe);for(let Je=0;Je<q;++Je){let Be=Je-we,ot=Math.max(0,Math.ceil(Be/ne)),qn=Math.min(se,(L+Be)/ne);for(let $t=0;$t<Z;++$t){let kr=$t-ye,dn=Math.max(0,Math.ceil(kr/le)),Sr=Math.min(te,(U+kr)/le),kn=0;for(let Kn=ht;Kn<st;++Kn){let wt=Kn*oe-at;for(let Pn=ot;Pn<qn;++Pn){let gn=Pn*ne-Be;for(let ns=dn;ns<Sr;++ns){let Zs=ns*le-kr,Cr=y*Ce+x*Kn+k*Pn+S*ns,Hl=E*(C-1-wt)+$*(L-1-gn)+R*(U-1-Zs)+D*Ae;for(let Tr=0;Tr<J;++Tr){let Js=v[Cr+Tr],en=N[Hl+Tr];kn+=Js*en}}}}h[f*Ce+g*qe+m*Je+b*$t+Ae]=kn}}}return n.makeTensorInfo(d.shape,d.dtype,d.values)}var hX={kernelName:xc,backendName:"cpu",kernelFunc:pX},fX=it(Go,e=>Math.cos(e)),mX={kernelName:Go,backendName:"cpu",kernelFunc:fX},gX=it(Ho,e=>Math.cosh(e)),bX={kernelName:Ho,backendName:"cpu",kernelFunc:gX};function yX(e){let{inputs:t,backend:n,attrs:r}=e,{image:s,boxes:a,boxInd:o}=t,{cropSize:i,method:u,extrapolationValue:c}=r,[l,p,d,h]=s.shape,f=a.shape[0],[g,m]=i,b=ze([f,g,m,h],"float32"),v=n.data.get(a.dataId).values,y=n.data.get(o.dataId).values,x=n.data.get(s.dataId).values,k=w.computeStrides(s.shape),S=w.computeStrides(b.shape);for(let N=0;N<f;N++){let E=N*4,$=v[E],R=v[E+1],D=v[E+2],F=v[E+3],C=y[N];if(C>=l)continue;let L=g>1?(D-$)*(p-1)/(g-1):0,U=m>1?(F-R)*(d-1)/(m-1):0;for(let H=0;H<g;H++){let K=g>1?$*(p-1)+H*L:.5*($+D)*(p-1);if(K<0||K>p-1){for(let q=0;q<m;q++)for(let Z=0;Z<h;Z++){let J=Z+q*S[2]+H*S[1]+N*S[0];b.values[J]=c}continue}if(u==="bilinear"){let q=Math.floor(K),Z=Math.ceil(K),J=K-q;for(let ee=0;ee<m;ee++){let se=m>1?R*(d-1)+ee*U:.5*(R+F)*(d-1);if(se<0||se>d-1){for(let le=0;le<h;le++){let ce=le+ee*S[2]+H*S[1]+N*S[0];b.values[ce]=c}continue}let te=Math.floor(se),oe=Math.ceil(se),ne=se-te;for(let le=0;le<h;le++){let ce=le+te*k[2]+q*k[1]+C*k[0],we=x[ce];ce=le+oe*k[2]+q*k[1]+C*k[0];let ye=x[ce];ce=le+te*k[2]+Z*k[1]+C*k[0];let Ce=x[ce];ce=le+oe*k[2]+Z*k[1]+C*k[0];let Ae=x[ce],qe=we+(ye-we)*ne,at=Ce+(Ae-Ce)*ne;ce=le+ee*S[2]+H*S[1]+N*S[0],b.values[ce]=qe+(at-qe)*J}}}else for(let q=0;q<m;++q){let Z=m>1?R*(d-1)+q*U:.5*(R+F)*(d-1);if(Z<0||Z>d-1){for(let se=0;se<h;se++){let te=se+q*S[2]+H*S[1]+N*S[0];b.values[te]=c}continue}let J=Math.round(Z),ee=Math.round(K);for(let se=0;se<h;se++){let te=se+J*k[2]+ee*k[1]+C*k[0],oe=se+q*S[2]+H*S[1]+N*S[0];b.values[oe]=x[te]}}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}var vX={kernelName:Ic,backendName:"cpu",kernelFunc:yX};function xX(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:o,reverse:i}=r;be(s,"cumprod");let u=T.getAxesPermutation([a],s.shape.length),c=s;u!=null&&(c=Un({inputs:{x:s},backend:n,attrs:{perm:u}}));let l=T.getInnerMostAxes(1,s.shape.length)[0];if(l!==c.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${l}`);let p=mr(c.dtype,"int32"),d=w.makeOnesTypedArray(w.sizeFromShape(c.shape),p),h=n.data.get(c.dataId).values,f=c.shape[c.shape.length-1],g=i?(b,v)=>b+f-v-1:(b,v)=>b+v;for(let b=0;b<h.length;b+=f)for(let v=0;v<f;v++){let y=g(b,v);if(v===0)d[y]=o?1:h[y];else{let x=g(b,v-1);d[y]=o?h[x]*d[x]:h[y]*d[x]}}let m=n.makeTensorInfo(c.shape,p,d);if(u!=null){let b=T.getUndoAxesPermutation(u),v=Un({inputs:{x:m},backend:n,attrs:{perm:b}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(c),v}return m}var wX={kernelName:wc,backendName:"cpu",kernelFunc:xX};function IX(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:o,reverse:i}=r;be(s,"cumsum");let u=T.getAxesPermutation([a],s.shape.length),c=s;u!=null&&(c=Un({inputs:{x:s},backend:n,attrs:{perm:u}}));let l=T.getInnerMostAxes(1,s.shape.length)[0];if(l!==c.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${l}`);let p=mr(c.dtype,"int32"),d=w.makeZerosTypedArray(w.sizeFromShape(c.shape),p),h=n.data.get(c.dataId).values,f=c.shape[c.shape.length-1],g=i?(b,v)=>b+f-v-1:(b,v)=>b+v;for(let b=0;b<h.length;b+=f)for(let v=0;v<f;v++){let y=g(b,v);if(v===0)d[y]=o?0:h[y];else{let x=g(b,v-1);d[y]=o?h[x]+d[x]:h[y]+d[x]}}let m=n.makeTensorInfo(c.shape,p,d);if(u!=null){let b=T.getUndoAxesPermutation(u),v=Un({inputs:{x:m},backend:n,attrs:{perm:b}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(c),v}return m}var kX={kernelName:jo,backendName:"cpu",kernelFunc:IX};function SX(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:o,binaryOutput:i}=r;if(s.shape.length===1){let u=n.data.get(s.dataId).values,c=n.data.get(a.dataId).values,l=zk(u,c,a.dtype,a.shape,o);return n.makeTensorInfo([o],a.dtype,l)}else if(s.shape.length===2){let u=n.bufferSync(s),c=n.bufferSync(a),l=_2(u,c,o,i);return n.makeTensorInfo(l.shape,a.dtype,l.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}var CX={kernelName:Ud,backendName:"cpu",kernelFunc:SX};function TX(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockSize:a,dataFormat:o}=r;w.assert(o==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${o}`);let i=s.shape[0],u=s.shape[1],c=s.shape[2],l=s.shape[3],p=u*a,d=c*a,h=l/(a*a),f=n.data.get(s.dataId).values,g=new Float32Array(i*p*d*h),m=0;for(let b=0;b<i;++b)for(let v=0;v<p;++v){let y=Math.floor(v/a),x=v%a;for(let k=0;k<d;++k){let S=Math.floor(k/a),N=k%a,E=(x*a+N)*h;for(let $=0;$<h;++$){let D=$+E+l*(S+c*(y+u*b));g[m++]=f[D]}}}return n.makeTensorInfo([i,p,d,h],s.dtype,g)}var NX={kernelName:kc,backendName:"cpu",kernelFunc:TX};function wE(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:o,pad:i,dilations:u,dimRoundingMode:c}=r;be([s,a],"depthwiseConv2DNative");let l=w.computeStrides(s.shape),p=w.computeStrides(a.shape),d=u;d==null&&(d=[1,1]),w.assert(T.eitherStridesOrDilationsAreOne(o,d),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${d}'`);let h=T.computeConv2DInfo(s.shape,a.shape,o,d,i,c,!0),{filterHeight:f,filterWidth:g,dilationHeight:m,dilationWidth:b,padInfo:v}=h,y=v.left,x=v.top,k=h.outChannels/h.inChannels,S=new Vt(h.outShape,s.dtype),N=n.data.get(s.dataId).values,E=n.data.get(a.dataId).values,$=S.values;for(let R=0;R<h.batchSize;++R){let D=R*l[0],F=R*S.strides[0];for(let C=0;C<h.outHeight;++C){let L=F+C*S.strides[1],U=C*h.strideHeight-x;for(let H=0;H<f;++H){let K=U+H*m;if(K<0||K>=h.inHeight)continue;let q=H*p[0],Z=D+K*l[1];for(let J=0;J<h.outWidth;++J){let ee=L+J*S.strides[2],se=J*h.strideWidth-y;for(let te=0;te<g;++te){let oe=se+te*b;if(oe<0||oe>=h.inWidth)continue;let ne=q+te*p[1],le=Z+oe*h.inChannels,ce=ee,we=ne;for(let ye=0;ye<h.inChannels;++ye){let Ce=N[le+ye];for(let Ae=0;Ae<k;++Ae)$[ce+Ae]+=Ce*E[we+Ae];ce+=k,we+=k}}}}}}return n.makeTensorInfo(S.shape,S.dtype,S.values)}var _X={kernelName:qo,backendName:"cpu",kernelFunc:wE};function EX(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:o,dilations:i,pad:u,dimRoundingMode:c,filterShape:l}=r;be([s,a],"depthwiseConv2dNativeBackpropFilter");let p=T.computeConv2DInfo(s.shape,l,o,i,u,c,!0),{strideHeight:d,strideWidth:h,filterHeight:f,filterWidth:g}=p,m=new Vt(p.filterShape,"float32"),b=p.padInfo.left,v=p.padInfo.top,y=p.outChannels/p.inChannels,x=n.data.get(s.dataId).values,k=new Vt(s.shape,s.dtype,x),S=n.data.get(a.dataId).values,N=new Vt(a.shape,a.dtype,S);for(let E=0;E<f;++E){let $=Math.max(0,Math.ceil((v-E)/d)),R=Math.min(p.outHeight,(p.inHeight+v-E)/d);for(let D=0;D<g;++D){let F=Math.max(0,Math.ceil((b-D)/h)),C=Math.min(p.outWidth,(p.inWidth+b-D)/h);for(let L=0;L<p.outChannels;++L){let U=Math.trunc(L/y),H=L%y,K=0;for(let q=0;q<p.batchSize;++q)for(let Z=$;Z<R;++Z){let J=E+Z*d-v;for(let ee=F;ee<C;++ee){let se=D+ee*h-b;K+=k.get(q,J,se,U)*N.get(q,Z,ee,L)}}m.set(K,E,D,U,H)}}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}var AX={kernelName:Vf,backendName:"cpu",kernelFunc:EX};function DX(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{strides:o,dilations:i,pad:u,dimRoundingMode:c,inputShape:l}=r;be([s,a],"depthwiseConv2DNativeBackpropInput");let p=w.computeStrides(s.shape),d=w.computeStrides(a.shape),h=T.computeConv2DInfo(l,a.shape,o,i,u,c,!0),f=new Vt(h.inShape,"float32"),g=f.values,[m,b,v]=f.strides,y=n.data.get(s.dataId).values,[x,k,S]=p,N=n.data.get(a.dataId).values,[E,$,R]=d,{batchSize:D,filterHeight:F,filterWidth:C,inChannels:L,inHeight:U,inWidth:H,outChannels:K,outHeight:q,outWidth:Z,strideHeight:J,strideWidth:ee}=h,se=F-1-h.padInfo.top,te=C-1-h.padInfo.left,oe=K/L;for(let ne=0;ne<D;++ne)for(let le=0;le<L;++le)for(let ce=0;ce<U;++ce){let we=ce-se,ye=Math.max(0,Math.ceil(we/J)),Ce=Math.min(q,(F+we)/J);for(let Ae=0;Ae<H;++Ae){let qe=Ae-te,at=Math.max(0,Math.ceil(qe/ee)),ht=Math.min(Z,(C+qe)/ee),st=0;for(let Je=ye;Je<Ce;++Je){let Be=Je*J-we;for(let ot=at;ot<ht;++ot){let qn=ot*ee-qe,$t=x*ne+k*Je+S*ot,kr=E*(F-1-Be)+$*(C-1-qn)+R*le;for(let dn=0;dn<oe;++dn){let Sr=le*oe+dn,kn=y[$t+Sr],Kn=N[kr+dn];st+=kn*Kn}}}g[m*ne+b*ce+v*Ae+le]=st}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}var $X={kernelName:Uf,backendName:"cpu",kernelFunc:DX};function FX(e){let{inputs:t,backend:n}=e,{x:r}=t,s=w.sizeFromShape(r.shape),a=n.data.get(r.dataId).values,o=ze([s,s],r.dtype),i=o.values;for(let c=0;c<a.length;c++)i[c*s+c]=a[c];let u=[...r.shape,...r.shape];return n.makeTensorInfo(u,o.dtype,o.values)}var RX={kernelName:Gd,backendName:"cpu",kernelFunc:FX},PX={kernelName:Ko,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:r,filter:s}=e,{strides:a,pad:o,dilations:i}=n,u=t,c=u.data.get(r.dataId).values,l=r.shape.length,p=u.data.get(s.dataId).values,d=s.shape.length,{batchSize:h,inHeight:f,inWidth:g,inChannels:m,outHeight:b,outWidth:v,padInfo:y,strideHeight:x,strideWidth:k,filterHeight:S,filterWidth:N,dilationHeight:E,dilationWidth:$,outShape:R}=T.computeDilation2DInfo(r.shape,s.shape,a,o,"NHWC",i),D=w.sizeFromShape(R),F=R.length,C=w.getArrayFromDType(r.dtype,D);for(let U=0;U<h;++U)for(let H=0;H<b;++H){let K=H*x-y.top;for(let q=0;q<v;++q){let Z=q*k-y.left;for(let J=0;J<m;++J){let ee=Number.MIN_SAFE_INTEGER;for(let te=0;te<S;++te){let oe=K+te*E;if(oe>=0&&oe<f)for(let ne=0;ne<N;++ne){let le=Z+ne*$;if(le>=0&&le<g){let ce=w.locToIndex([U,oe,le,J],l,w.computeStrides(r.shape)),we=w.locToIndex([te,ne,J],d,w.computeStrides(s.shape)),ye=c[ce]+p[we];ye>ee&&(ee=ye)}}}let se=w.locToIndex([U,H,q,J],F,w.computeStrides(R));C[se]=ee}}}return{dataId:u.write(w.toTypedArray(C,r.dtype),R,r.dtype),shape:R,dtype:r.dtype}}},OX={kernelName:Gu,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:r,filter:s,dy:a}=e,{strides:o,pad:i,dilations:u}=n,c=t,l=w.toNestedArray(r.shape,c.data.get(r.dataId).values),p=w.toNestedArray(s.shape,c.data.get(s.dataId).values),{batchSize:d,inHeight:h,inWidth:f,inChannels:g,outHeight:m,outWidth:b,padInfo:v,strideHeight:y,strideWidth:x,filterHeight:k,filterWidth:S,dilationHeight:N,dilationWidth:E,outShape:$}=T.computeDilation2DInfo(r.shape,s.shape,o,i,"NHWC",u);w.assert(a.rank===$.length,()=>`Error in ${Gu}, dy must have the same rank as output ${$.length}, but got ${a.rank}`);let R=w.toNestedArray($,c.data.get(a.dataId).values),D=w.makeZerosNestedTypedArray(s.shape,s.dtype);for(let C=0;C<d;++C)for(let L=0;L<m;++L){let U=L*y-v.top;for(let H=0;H<b;++H){let K=H*x-v.left;for(let q=0;q<g;++q){let Z=Number.MIN_SAFE_INTEGER,J=0,ee=0;for(let se=0;se<k;++se){let te=U+se*N;if(te>=0&&te<h)for(let oe=0;oe<S;++oe){let ne=K+oe*E;if(ne>=0&&ne<f){let le=l[C][te][ne][q]+p[se][oe][q];le>Z&&(Z=le,J=se,ee=oe)}}}D[J][ee][q]+=R[C][L][H][q]}}}return{dataId:c.write(w.toTypedArray(D,r.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},MX={kernelName:Uu,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:r,filter:s,dy:a}=e,{strides:o,pad:i,dilations:u}=n,c=t,l=w.toNestedArray(r.shape,c.data.get(r.dataId).values),p=w.toNestedArray(s.shape,c.data.get(s.dataId).values),{batchSize:d,inHeight:h,inWidth:f,inChannels:g,outHeight:m,outWidth:b,padInfo:v,strideHeight:y,strideWidth:x,filterHeight:k,filterWidth:S,dilationHeight:N,dilationWidth:E,outShape:$}=T.computeDilation2DInfo(r.shape,s.shape,o,i,"NHWC",u);w.assert(a.rank===$.length,()=>`Error in ${Uu}, dy must have the same rank as output ${$.length}, but got ${a.rank}`);let R=w.toNestedArray($,c.data.get(a.dataId).values),D=w.makeZerosNestedTypedArray(r.shape,r.dtype);for(let C=0;C<d;++C)for(let L=0;L<m;++L){let U=L*y-v.top;for(let H=0;H<b;++H){let K=H*x-v.left;for(let q=0;q<g;++q){let Z=Number.MIN_SAFE_INTEGER,J=U<0?0:U,ee=K<0?0:K;for(let se=0;se<k;++se){let te=U+se*N;if(te>=0&&te<h)for(let oe=0;oe<S;++oe){let ne=K+oe*E;if(ne>=0&&ne<f){let le=l[C][te][ne][q]+p[se][oe][q];le>Z&&(Z=le,J=te,ee=ne)}}}D[C][J][ee][q]+=R[C][L][H][q]}}}return{dataId:c.write(w.toTypedArray(D,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};function LX(e){let{inputs:t,backend:n,attrs:r}=e,{image:s}=t,{canvas:a,options:o}=r,{contextOptions:i,imageOptions:u}=o||{},c=u?.alpha||1,l=i?.contextType||"2d";if(l!=="2d")throw new Error(`Context type ${i.contextType} is not supported by the CPU backend.`);let p=a.getContext(l,i?.contextAttributes||{});if(p==null)throw new Error(`Could not get the context with ${l} type.`);let[d,h]=s.shape.slice(0,2),f=s.shape.length===2?1:s.shape[2],g=n.data.get(s.dataId).values,m=s.dtype==="float32"?255:1,b=new Uint8ClampedArray(h*d*4);for(let y=0;y<d*h;++y){let x=[0,0,0,255*c];for(let S=0;S<f;S++){let N=g[y*f+S];if(s.dtype==="float32"){if(N<0||N>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${N}.`)}else if(s.dtype==="int32"&&(N<0||N>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${N}.`);f===1?(x[0]=N*m,x[1]=N*m,x[2]=N*m):x[S]=N*m}let k=y*4;b[k+0]=Math.round(x[0]),b[k+1]=Math.round(x[1]),b[k+2]=Math.round(x[2]),b[k+3]=Math.round(x[3])}a.width=h,a.height=d;let v=new ImageData(b,h,d);return p.putImageData(v,0,0),s}var zX={kernelName:Gf,backendName:"cpu",kernelFunc:LX};function Op(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:o}=r;be(s,"sum");let i;s.dtype==="bool"?i=wa({inputs:{x:s},backend:n,attrs:{dtype:"int32"}}):i=hs({inputs:{x:s},backend:n});let u=i.shape.length,c=w.parseAxisParam(a,i.shape),l=T.getAxesPermutation(c,u),p=c,d=i;l!=null&&(d=Un({inputs:{x:i},backend:n,attrs:{perm:l}}),p=T.getInnerMostAxes(p.length,u)),T.assertAxesAreInnerMostDims("sum",p,d.shape.length);let[h,f]=T.computeOutAndReduceShapes(d.shape,p),g=T.upcastType(d.dtype,"int32"),m=Nf(n,h,g),b=w.sizeFromShape(f),v=n.data.get(m.dataId).values,y=n.data.get(d.dataId).values;for(let x=0;x<v.length;++x){let k=x*b,S=0;for(let N=0;N<b;++N)S+=y[k+N];v[x]=S}if(o){let x=T.expandShapeToKeepDim(m.shape,c),k=m;m=yt({inputs:{x:m},backend:n,attrs:{shape:x}}),n.disposeIntermediateTensorInfo(k)}return n.disposeIntermediateTensorInfo(i),l!=null&&n.disposeIntermediateTensorInfo(d),m}var BX={kernelName:Wi,backendName:"cpu",kernelFunc:Op};function WX(e){let{inputs:t,backend:n,attrs:r}=e,{equation:s}=r,a=t,{allDims:o,summedDims:i,idDims:u}=T.decodeEinsumEquation(s,a.length);T.checkEinsumDimSizes(o.length,u,a);let{path:c,steps:l}=T.getEinsumComputePath(i,u),p=l.length,d=null,h=o.length,f=[];for(let g=0;g<p;++g){for(let m of l[g]){let{permutationIndices:b,expandDims:v}=T.getEinsumPermutation(h,u[m]),y;T.isIdentityPermutation(b)?y=a[m]:(y=Un({inputs:{x:a[m]},backend:n,attrs:{perm:b}}),f.push(y));let x=y.shape.slice();for(let k=0;k<v.length;++k)x.splice(v[k],0,1);w.arraysEqual(y.shape,x)||(y=yt({inputs:{x:y},backend:n,attrs:{shape:x}}),f.push(y)),d===null?d=y:(d=eg({inputs:{a:y,b:d},backend:n}),f.push(d))}g<p-1&&(c[g]>=0&&(d=Op({inputs:{x:d},backend:n,attrs:{axis:c[g]-(o.length-h),keepDims:!1}}),f.push(d)),h--)}for(let g of f)g!==d&&n.disposeIntermediateTensorInfo(g);return d}var VX={kernelName:Hf,backendName:"cpu",kernelFunc:WX};function UX(e){let{inputs:t,backend:n}=e,{dy:r,y:s}=t;be([r,s],"eluGrad");let a=new Float32Array(w.sizeFromShape(s.shape)),o=n.data.get(s.dataId).values,i=n.data.get(r.dataId).values;for(let u=0;u<o.length;++u){let c=o[u];c>=0?a[u]=i[u]:a[u]=i[u]*(c+1)}return n.makeTensorInfo(s.shape,"float32",a)}var GX={kernelName:Sc,backendName:"cpu",kernelFunc:UX},HX=T.ERF_P,jX=T.ERF_A1,qX=T.ERF_A2,KX=T.ERF_A3,XX=T.ERF_A4,YX=T.ERF_A5,ZX=it(Zo,e=>{let t=Math.sign(e),n=Math.abs(e),r=1/(1+HX*n);return t*(1-((((YX*r+XX)*r+KX)*r+qX)*r+jX)*r*Math.exp(-n*n))}),JX={kernelName:Zo,backendName:"cpu",kernelFunc:ZX};function Af(e){let{inputs:t,backend:n,attrs:r}=e,{input:s}=t,{dim:a}=r,o=s.shape.length,i=s.shape.slice(),u=a;return a<0&&(w.assert(-(o+1)<=a,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),u=o+a+1),i.splice(u,0,1),yt({inputs:{x:s},backend:n,attrs:{shape:i}})}var QX={kernelName:Tc,backendName:"cpu",kernelFunc:Af},e7=Lt((e,t)=>e/t),Zk=Qt(Xo,e7),px={kernelName:Xo,backendName:"cpu",kernelFunc:Zk};function IE(e,t,n){let r=e.shape,s=r[0],a=r[1],o=n.data.get(e.dataId),i=o.complexTensorInfos.real,u=o.complexTensorInfos.imag,c=[s,a],l=w.sizeFromShape(c),p=w.getTypedArrayFromDType("float32",l),d=w.getTypedArrayFromDType("float32",l);for(let m=0;m<s;m++){let b=ko({inputs:{x:i},backend:n,attrs:{begin:[m,0],size:[1,a]}}),v=ko({inputs:{x:u},backend:n,attrs:{begin:[m,0],size:[1,a]}}),y=Qn({inputs:{real:b,imag:v},backend:n}),{real:x,imag:k}=t7(y,t,n),S=T.mergeRealAndImagArrays(x,k);for(let N=0;N<a;N++){let E=T.getComplexWithIndex(S,N);p[m*a+N]=E.real,d[m*a+N]=E.imag}n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(v),n.disposeIntermediateTensorInfo(y)}let h=n.makeTensorInfo(c,"float32",p),f=n.makeTensorInfo(c,"float32",d),g=Qn({inputs:{real:h,imag:f},backend:n});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(f),g}function t7(e,t,n){let r=w.sizeFromShape(e.shape),s=n.data.get(e.dataId),a=n.data.get(s.complexTensorInfos.real.dataId).values,o=n.data.get(s.complexTensorInfos.imag.dataId).values;if(n7(r)){let i=hx(a,o,r,t,n),u=[e.shape[0],e.shape[1]];if(t){let c=n.makeTensorInfo(u,"float32",i.real),l=n.makeTensorInfo(u,"float32",i.imag),p=n.makeTensorInfo([],"float32",w.createScalarValue(r,"float32")),d=hs({inputs:{x:p},backend:n}),h=px.kernelFunc({inputs:{a:c,b:p},backend:n}),f=px.kernelFunc({inputs:{a:l,b:d},backend:n}),g=n.data.get(h.dataId).values,m=n.data.get(f.dataId).values;return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(f),{real:g,imag:m}}return i}else{let i=T.mergeRealAndImagArrays(a,o),u=r7(i,r,t);return T.splitRealAndImagArrays(u)}}function n7(e){return(e&e-1)===0}function hx(e,t,n,r,s){if(n===1)return{real:e,imag:t};let a=T.mergeRealAndImagArrays(e,t),o=n/2,i=T.complexWithEvenIndex(a),u=i.real,c=i.imag,l=[u.length],p=s.makeTensorInfo(l,"float32",u),d=s.makeTensorInfo(l,"float32",c),h=Qn({inputs:{real:p,imag:d},backend:s}),f=T.complexWithOddIndex(a),g=f.real,m=f.imag,b=[g.length],v=s.makeTensorInfo(b,"float32",g),y=s.makeTensorInfo(b,"float32",m),x=Qn({inputs:{real:v,imag:y},backend:s}),k=hx(u,c,o,r,s),S=k.real,N=k.imag,E=[S.length],$=s.makeTensorInfo(E,"float32",S),R=s.makeTensorInfo(E,"float32",N),D=Qn({inputs:{real:$,imag:R},backend:s}),F=hx(g,m,o,r,s),C=F.real,L=F.imag,U=[C.length],H=s.makeTensorInfo(U,"float32",C),K=s.makeTensorInfo(U,"float32",L),q=Qn({inputs:{real:H,imag:K},backend:s}),Z=T.exponents(n,r),J=[Z.real.length],ee=s.makeTensorInfo(J,"float32",Z.real),se=s.makeTensorInfo(J,"float32",Z.imag),te=Qn({inputs:{real:ee,imag:se},backend:s}),oe=eg({inputs:{a:te,b:q},backend:s}),ne=ac({inputs:{a:D,b:oe},backend:s}),le=Kk({inputs:{a:D,b:oe},backend:s}),ce=Io({inputs:{input:ne},backend:s}),we=Io({inputs:{input:le},backend:s}),ye=oc({inputs:{input:ne},backend:s}),Ce=oc({inputs:{input:le},backend:s}),Ae=ic({inputs:[ce,we],backend:s,attrs:{axis:0}}),qe=ic({inputs:[ye,Ce],backend:s,attrs:{axis:0}}),at=s.data.get(Ae.dataId).values,ht=s.data.get(qe.dataId).values;return s.disposeIntermediateTensorInfo(p),s.disposeIntermediateTensorInfo(d),s.disposeIntermediateTensorInfo(h),s.disposeIntermediateTensorInfo(v),s.disposeIntermediateTensorInfo(y),s.disposeIntermediateTensorInfo(x),s.disposeIntermediateTensorInfo($),s.disposeIntermediateTensorInfo(R),s.disposeIntermediateTensorInfo(D),s.disposeIntermediateTensorInfo(H),s.disposeIntermediateTensorInfo(K),s.disposeIntermediateTensorInfo(q),s.disposeIntermediateTensorInfo(ee),s.disposeIntermediateTensorInfo(se),s.disposeIntermediateTensorInfo(te),s.disposeIntermediateTensorInfo(oe),s.disposeIntermediateTensorInfo(ne),s.disposeIntermediateTensorInfo(le),s.disposeIntermediateTensorInfo(ce),s.disposeIntermediateTensorInfo(ye),s.disposeIntermediateTensorInfo(we),s.disposeIntermediateTensorInfo(Ce),s.disposeIntermediateTensorInfo(Ae),s.disposeIntermediateTensorInfo(qe),{real:at,imag:ht}}function r7(e,t,n){let r=new Float32Array(t*2);for(let s=0;s<t;s++){let a=0,o=0;for(let i=0;i<t;i++){let u=T.exponent(s*i,t,n),c=T.getComplexWithIndex(e,i);a+=c.real*u.real-c.imag*u.imag,o+=c.real*u.imag+c.imag*u.real}n&&(a/=t,o/=t),T.assignToTypedArray(r,a,o,s)}return r}function s7(e){let{inputs:t,backend:n}=e,{input:r}=t,s=w.sizeFromShape(r.shape),a=r.shape[r.shape.length-1],o=s/a,i=yt({inputs:{x:r},backend:n,attrs:{shape:[o,a]}}),u=IE(i,!1,n),c=yt({inputs:{x:u},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(u),c}var a7={kernelName:jf,backendName:"cpu",kernelFunc:s7};function Jk(e){let{backend:t,attrs:n}=e,{shape:r,value:s,dtype:a}=n,o=a||w.inferDtype(s),i=w.getArrayFromDType(o,w.sizeFromShape(r));return i7(i,s,o),t.makeTensorInfo(r,o,i)}var o7={kernelName:Hd,backendName:"cpu",kernelFunc:Jk};function i7(e,t,n){e.fill(t)}var u7={kernelName:Nc,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{image:r}=e,s=n,a=w.getTypedArrayFromDType(r.dtype,w.sizeFromShape(r.shape)),[o,i,u,c]=r.shape,l=s.data.get(r.dataId).values;for(let d=0;d<o;d++){let h=d*u*i*c;for(let f=0;f<i;f++){let g=f*(u*c);for(let m=0;m<u;m++){let b=m*c;for(let v=0;v<c;v++){let y=Math.round(u-m-1),x=h+g+b+v,k=l[x];if(y>=0&&y<u){let S=y*c,N=h+g+S+v;k=l[N]}a[x]=k}}}}return{dataId:s.write(a,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};function c7(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:o,preluActivationWeights:i}=t,{strides:u,pad:c,dataFormat:l,dilations:p,dimRoundingMode:d,activation:h,leakyreluAlpha:f}=r,g=xE({inputs:{x:s,filter:a},backend:n,attrs:{strides:u,pad:c,dataFormat:l,dilations:p,dimRoundingMode:d}});if(o){let m=g;if(l==="NCHW"&&o.shape.length===1&&o.shape[0]!==1){let b=yt({inputs:{x:o},backend:n,attrs:{shape:[o.shape[0],1,1]}});g=ac({inputs:{a:g,b},backend:n}),n.disposeIntermediateTensorInfo(b)}else g=ac({inputs:{a:g,b:o},backend:n});n.disposeIntermediateTensorInfo(m)}if(h){let m=g;if(l==="NCHW"&&h==="prelu"&&i.shape.length===1&&i.shape[0]!==1){let b=yt({inputs:{x:i},backend:n,attrs:{shape:[i.shape[0],1,1]}});g=Ef(n,g,h,b,f),n.disposeIntermediateTensorInfo(b)}else g=Ef(n,g,h,i,f);n.disposeIntermediateTensorInfo(m)}return g}var l7={kernelName:lo,backendName:"cpu",kernelFunc:c7};function d7(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:o,preluActivationWeights:i}=t,{strides:u,pad:c,dataFormat:l,dilations:p,dimRoundingMode:d,activation:h,leakyreluAlpha:f}=r,g=wE({inputs:{x:s,filter:a},backend:n,attrs:{strides:u,pad:c,dataFormat:l,dilations:p,dimRoundingMode:d}});if(o){let m=g;g=ac({inputs:{a:g,b:o},backend:n}),n.disposeIntermediateTensorInfo(m)}if(h){let m=g;g=Ef(n,g,h,i,f),n.disposeIntermediateTensorInfo(m)}return g}var p7={kernelName:po,backendName:"cpu",kernelFunc:d7};function h7(e){let{inputs:t,backend:n}=e,{params:r,indices:s}=t,a=w.sizeFromShape(r.shape),o=s.shape,i=o[o.length-1],[u,c,l,p]=T.prepareAndValidate(r,s);if(c===0)return n.makeTensorInfo(u,r.dtype,[]);let d=n.data.get(s.dataId).values,h=n.bufferSync(r),f=L2(d,h,r.dtype,c,i,l,p,r.shape,a);return n.makeTensorInfo(u,r.dtype,f.values)}var f7={kernelName:Ec,backendName:"cpu",kernelFunc:h7};function m7(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,indices:a}=t,{axis:o,batchDims:i}=r;be([s,a],"gatherV2");let u=w.parseAxisParam(o,s.shape)[0],c=n.data.get(a.dataId).values,l=s.shape[u];for(let x=0;x<c.length;++x){let k=c[x];w.assert(k<=l-1&&k>=0,()=>`GatherV2: the index value ${k} is not in [0, ${l-1}]`)}let p=i;i==null&&(p=0);let d=w.sizeFromShape(a.shape),h=T.segment_util.collectGatherOpShapeInfo(s,a,u,p),f=yt({inputs:{x:s},backend:n,attrs:{shape:[h.batchSize,h.outerSize,h.dimSize,h.sliceSize]}}),g=yt({inputs:{x:a},backend:n,attrs:{shape:[h.batchSize,d/h.batchSize]}}),m=[h.batchSize,h.outerSize,d/h.batchSize,h.sliceSize],b=n.bufferSync(g),v=n.bufferSync(f),y=z2(v,b,m);return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),n.makeTensorInfo(h.outputShape,y.dtype,y.values)}var g7={kernelName:_c,backendName:"cpu",kernelFunc:m7};function b7(e){let{inputs:t,backend:n}=e,{input:r}=t,s=w.sizeFromShape(r.shape),a=r.shape[r.shape.length-1],o=s/a,i=yt({inputs:{x:r},backend:n,attrs:{shape:[o,a]}}),u=IE(i,!0,n),c=yt({inputs:{x:u},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(u),c}var y7={kernelName:qf,backendName:"cpu",kernelFunc:b7},v7=it(ai,e=>Number.isFinite(e)?1:0,"bool"),x7={kernelName:ai,backendName:"cpu",kernelFunc:v7},w7=it(oi,e=>Math.abs(e)===1/0?1:0,"bool"),I7={kernelName:oi,backendName:"cpu",kernelFunc:w7},k7=it(ii,e=>Number.isNaN(e)?1:0,"bool"),S7={kernelName:ii,backendName:"cpu",kernelFunc:k7};function C7(e){let{backend:t,attrs:n}=e,{start:r,stop:s,num:a}=n,o=G2(r,s,a);return t.makeTensorInfo([o.length],"float32",o)}var T7={kernelName:Fc,backendName:"cpu",kernelFunc:C7},N7=it(li,e=>Math.log1p(e)),_7={kernelName:li,backendName:"cpu",kernelFunc:N7},E7=Lt((e,t)=>e&&t),A7=Qt(Rc,E7,null,"bool"),D7={kernelName:Rc,backendName:"cpu",kernelFunc:A7},$7=it(Pc,e=>e?0:1,"bool"),F7={kernelName:Pc,backendName:"cpu",kernelFunc:$7},R7=Lt((e,t)=>e||t),P7=Qt(Oc,R7,null,"bool"),O7={kernelName:Oc,backendName:"cpu",kernelFunc:P7};function M7(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{depthRadius:a,bias:o,alpha:i,beta:u}=r;be(s,"LRN");let c=s.shape[3],l=c-1,p=n.data.get(s.dataId).values,d=w.sizeFromShape(s.shape),h=new Float32Array(d);function f(g){let m=g%c,b=g-m+Math.max(0,m-a),v=g-m+Math.min(m+a,l),y=0;for(;b<=v;b++){let x=p[b];y+=x*x}return y}for(let g=0;g<d;g++){let m=f(g),b=p[g]*Math.pow(o+i*m,-u);h[g]=b}return n.makeTensorInfo(s.shape,s.dtype,h)}var L7={kernelName:di,backendName:"cpu",kernelFunc:M7};function z7(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,y:a,dy:o}=t,{depthRadius:i,bias:u,alpha:c,beta:l}=r;be(o,"LRNGrad");let p=w.sizeFromShape(o.shape),d=o.shape[3],h=n.data.get(o.dataId).values,f=n.data.get(s.dataId).values,g=n.data.get(a.dataId).values,m=new Float32Array(p),b=p;for(let v=0;v<b;v++){let y=v%d,x=v-y+Math.max(0,y-i),k=v-y+Math.min(d,y+i+1),S=0;for(let N=x;N<k;N++)S+=Math.pow(f[N],2);S=c*S+u;for(let N=x;N<k;N++){let E=-2*c*l*f[N]*g[v]/S;v===N&&(E+=Math.pow(S,-l)),E*=h[v],m[N]+=E}}return n.makeTensorInfo(o.shape,s.dtype,m)}var B7={kernelName:Mc,backendName:"cpu",kernelFunc:z7};function kE(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reductionIndices:a,keepDims:o}=r,i=n,u=s.shape,c=u.length,l=w.parseAxisParam(a,u),p=l,d=T.getAxesPermutation(p,c),h=i.data.get(s.dataId).values;if(d!=null){let x=new Array(c);for(let k=0;k<x.length;k++)x[k]=u[d[k]];h=Vk(h,u,s.dtype,d,x),p=T.getInnerMostAxes(p.length,c),u=x}be(s,"max"),T.assertAxesAreInnerMostDims("max",p,c);let[f,g]=T.computeOutAndReduceShapes(u,p),m=w.sizeFromShape(g),b=j2(h,m,f,s.dtype),v=i.write(b,f,s.dtype),y=f;return o&&(y=T.expandShapeToKeepDim(f,l)),{dataId:v,shape:y,dtype:s.dtype}}var W7={kernelName:pi,backendName:"cpu",kernelFunc:kE};function V7(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t;be(s,"maxPool");let{filterSize:a,strides:o,pad:i,dimRoundingMode:u}=r,c=1;w.assert(T.eitherStridesOrDilationsAreOne(o,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);let l=T.computePool2DInfo(s.shape,a,o,c,i,u),p;if(l.filterWidth===1&&l.filterHeight===1&&w.arraysEqual(l.inShape,l.outShape))p=hs({inputs:{x:s},backend:n});else{let d=n.data.get(s.dataId).values,h=w.computeStrides(s.shape),f=Yk(d,s.shape,s.dtype,h,l,"max");p=n.makeTensorInfo(l.outShape,s.dtype,f.values)}return p}var U7={kernelName:fi,backendName:"cpu",kernelFunc:V7};function G7(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:o,pad:i,dimRoundingMode:u,dataFormat:c}=r;be(s,"maxPool3d");let l=T.computePool3DInfo(s.shape,a,o,1,i,u,c),p=n.data.get(s.dataId).values,d=vE(p,s.shape,s.dtype,w.computeStrides(s.shape),l,"max");return n.makeTensorInfo(d.shape,"float32",d.values)}var H7={kernelName:Lc,backendName:"cpu",kernelFunc:G7};function j7(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,{filterSize:o,strides:i,pad:u,dimRoundingMode:c}=r;be([s,a],"maxPool3DGrad");let l=T.computePool3DInfo(a.shape,o,i,1,u,c),p=n.bufferSync(a),d=RK(p,l),h=l.strideDepth,f=l.strideHeight,g=l.strideWidth,m=l.dilationDepth,b=l.dilationHeight,v=l.dilationWidth,y=l.effectiveFilterDepth,x=l.effectiveFilterHeight,k=l.effectiveFilterWidth,S=y-1-l.padInfo.front,N=k-1-l.padInfo.left,E=x-1-l.padInfo.top,$=ze(a.shape,"float32"),R=n.bufferSync(s);for(let D=0;D<l.batchSize;++D)for(let F=0;F<l.inChannels;++F)for(let C=0;C<l.inDepth;++C)for(let L=0;L<l.inHeight;++L)for(let U=0;U<l.inWidth;++U){let H=C-S,K=L-E,q=U-N,Z=0;for(let J=0;J<y;J+=m){let ee=(H+J)/h;if(!(ee<0||ee>=l.outDepth||Math.floor(ee)!==ee))for(let se=0;se<x;se+=b){let te=(K+se)/f;if(!(te<0||te>=l.outHeight||Math.floor(te)!==te))for(let oe=0;oe<k;oe+=v){let ne=(q+oe)/g;if(ne<0||ne>=l.outWidth||Math.floor(ne)!==ne)continue;let le=y*x*k-1-d.get(D,ee,te,ne,F),ce=J*x*k+se*k+oe,we=le===ce?1:0;if(we===0)continue;let ye=R.get(D,ee,te,ne,F);Z+=ye*we}}}$.set(Z,D,C,L,U,F)}return n.makeTensorInfo($.shape,$.dtype,$.values)}var q7={kernelName:qd,backendName:"cpu",kernelFunc:j7};function K7(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a,output:o}=t,i=a;be([a,o],"maxPoolGrad");let{filterSize:u,strides:c,pad:l,dimRoundingMode:p}=r,d=T.computePool2DInfo(i.shape,u,c,1,l,p),h=n.data.get(i.dataId).values,f=ze(d.outShape,i.dtype,yE(h,i.shape,i.dtype,d).values),g=d.strideHeight,m=d.strideWidth,b=d.dilationHeight,v=d.dilationWidth,y=d.effectiveFilterHeight,x=d.effectiveFilterWidth,k=x-1-d.padInfo.left,S=y-1-d.padInfo.top,N=ze(i.shape,"float32"),E=n.data.get(s.dataId).values,$=ze(s.shape,"float32",E);for(let R=0;R<d.batchSize;++R)for(let D=0;D<d.inChannels;++D)for(let F=0;F<d.inHeight;++F)for(let C=0;C<d.inWidth;++C){let L=F-S,U=C-k,H=0;for(let K=0;K<y;K+=b){let q=(L+K)/g;if(!(q<0||q>=d.outHeight||Math.floor(q)!==q))for(let Z=0;Z<x;Z+=v){let J=(U+Z)/m;if(J<0||J>=d.outWidth||Math.floor(J)!==J)continue;let ee=y*x-1-f.get(R,q,J,D),se=K*x+Z,te=ee===se?1:0;if(te===0)continue;let oe=$.get(R,q,J,D);H+=oe*te}}N.set(H,R,F,C,D)}return n.makeTensorInfo(N.shape,N.dtype,N.values)}var X7={kernelName:jd,backendName:"cpu",kernelFunc:K7};function Y7(e,t,n,r,s){let a=w.computeStrides(t),o=Yk(e,t,n,a,s,"max"),i=yE(e,t,n,s,!0,r);return[o.values,i.values]}var Z7={kernelName:Kd,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{x:r}=e,{filterSize:s,strides:a,pad:o,includeBatchInIndex:i}=t,u=n;be(r,"MaxPoolWithArgmax");let c=u.data.get(r.dataId).values,l=T.computePool2DInfo(r.shape,s,a,[1,1],o),[p,d]=Y7(c,r.shape,r.dtype,i,l),h=u.write(p,l.outShape,r.dtype),f=u.write(d,l.outShape,r.dtype);return[{dataId:h,shape:l.outShape,dtype:r.dtype},{dataId:f,shape:l.outShape,dtype:"int32"}]}};function J7(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:o}=r,i=w.parseAxisParam(a,s.shape),c=T.computeOutAndReduceShapes(s.shape,i)[1],l=w.sizeFromShape(c),p=[],d=n.makeTensorInfo([],"float32",new Float32Array([l]));p.push(d);let h=wa({inputs:{x:s},backend:n,attrs:{dtype:"float32"}});p.push(h);let f=Zk({inputs:{a:h,b:d},backend:n});p.push(f);let g=Op({inputs:{x:f},backend:n,attrs:{axis:a,keepDims:o}});return p.forEach(m=>n.disposeIntermediateTensorInfo(m)),g}var Q7={kernelName:mi,backendName:"cpu",kernelFunc:J7};function eY(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:o}=r;be(s,"min");let i=w.parseAxisParam(a,s.shape),u=i,c=T.getAxesPermutation(u,s.shape.length),l=s;c!=null&&(l=Un({inputs:{x:s},backend:n,attrs:{perm:c}}),u=T.getInnerMostAxes(u.length,s.shape.length)),T.assertAxesAreInnerMostDims("min",u,l.shape.length);let[p,d]=T.computeOutAndReduceShapes(l.shape,u),h=w.sizeFromShape(d),f=w.makeZerosTypedArray(w.sizeFromShape(p),l.dtype),g=n.data.get(l.dataId).values;for(let b=0;b<f.length;++b){let v=b*h,y=g[v];for(let x=0;x<h;++x){let k=g[v+x];(Number.isNaN(k)||k<y)&&(y=k)}f[b]=y}c!=null&&n.disposeIntermediateTensorInfo(l);let m=n.makeTensorInfo(p,l.dtype,f);if(o){let b=T.expandShapeToKeepDim(p,i),v=yt({inputs:{x:m},backend:n,attrs:{shape:b}});return n.disposeIntermediateTensorInfo(m),v}return m}var tY={kernelName:gi,backendName:"cpu",kernelFunc:eY};function nY(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{paddings:a,mode:o}=r;be(s,"mirrorPad");let i=a.map((y,x)=>y[0]+s.shape[x]+y[1]),u=a.map(y=>y[0]),c=a.map((y,x)=>y[0]+s.shape[x]),l=o==="reflect"?0:1,p=n.data.get(s.dataId).values,d=s.shape.length,h=w.computeStrides(s.shape),f=w.sizeFromShape(i),g=i.length,m=w.computeStrides(i),b=w.getTypedArrayFromDType(s.dtype,f);for(let y=0;y<f;y++){let x=w.indexToLoc(y,g,m);for(let S=0;S<g;S++)x[S]<u[S]?x[S]=u[S]*2-x[S]-l:x[S]>=c[S]&&(x[S]=(c[S]-1)*2-x[S]+l);x=x.map((S,N)=>S-u[N]);let k=w.locToIndex(x,d,h);b[y]=p[k]}return{dataId:n.write(b,i,s.dtype),shape:i,dtype:s.dtype}}var rY={kernelName:yi,backendName:"cpu",kernelFunc:nY},sY=Lt((e,t)=>{let n=e%t;return e<0&&t<0||e>=0&&t>=0?n:(n+t)%t}),aY=Qt(vi,sY),oY={kernelName:vi,backendName:"cpu",kernelFunc:aY},iY=ka(Of());function SE(e){let{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{dim:a}=r,o=s.shape.length,i=a;if(i===-1&&(i=o-1),i!==o-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${o} and dim was ${i}`);let u=w.parseAxisParam([i],s.shape),c=kE({inputs:{x:s},backend:n,attrs:{reductionIndices:u,keepDims:!1}}),l=T.expandShapeToKeepDim(c.shape,u),p=yt({inputs:{x:c},backend:n,attrs:{shape:l}}),d=Kk({inputs:{a:s,b:p},backend:n}),h=R2({inputs:{x:d},backend:n}),f=Op({inputs:{x:h},backend:n,attrs:{axis:u,keepDims:!1}}),g=yt({inputs:{x:f},backend:n,attrs:{shape:l}}),m=Zk({inputs:{a:h,b:g},backend:n});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),m}var uY={kernelName:Vi,backendName:"cpu",kernelFunc:SE};function cY(e){let{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{numSamples:a,seed:o,normalized:i}=r;be(s,"multinomial");let u=i?s:SE({inputs:{logits:s},backend:n,attrs:{dim:-1}}),c=u.shape[0],l=u.shape[1],p=n.data.get(u.dataId).values,d=[c,a],h=w.makeZerosTypedArray(w.sizeFromShape(d),"int32");for(let f=0;f<c;++f){let g=f*l,m=new Float32Array(l-1);m[0]=p[g];for(let y=1;y<m.length;++y)m[y]=m[y-1]+p[g+y];let b=iY.alea(o.toString()),v=f*a;for(let y=0;y<a;++y){let x=b();h[v+y]=m.length;for(let k=0;k<m.length;k++)if(x<m[k]){h[v+y]=k;break}}}return i||n.disposeIntermediateTensorInfo(u),n.makeTensorInfo(d,"int32",h)}var lY={kernelName:zc,backendName:"cpu",kernelFunc:cY},dY=bs.nonMaxSuppressionV3Impl;function pY(e){let{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:o,iouThreshold:i,scoreThreshold:u}=r;be(s,"NonMaxSuppression");let c=n.data.get(s.dataId).values,l=n.data.get(a.dataId).values,{selectedIndices:p}=dY(c,l,o,i,u);return n.makeTensorInfo([p.length],"int32",new Int32Array(p))}var hY={kernelName:Vc,backendName:"cpu",kernelFunc:pY},fY=bs.nonMaxSuppressionV4Impl;function mY(e){let{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:o,iouThreshold:i,scoreThreshold:u,padToMaxOutputSize:c}=r;be(s,"NonMaxSuppressionPadded");let l=n.data.get(s.dataId).values,p=n.data.get(a.dataId).values,{selectedIndices:d,validOutputs:h}=fY(l,p,o,i,u,c);return[n.makeTensorInfo([d.length],"int32",new Int32Array(d)),n.makeTensorInfo([],"int32",new Int32Array([h]))]}var gY={kernelName:Uc,backendName:"cpu",kernelFunc:mY},bY=bs.nonMaxSuppressionV5Impl;function yY(e){let{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:o,iouThreshold:i,scoreThreshold:u,softNmsSigma:c}=r;be(s,"NonMaxSuppressionWithScore");let l=n.data.get(s.dataId).values,p=n.data.get(a.dataId).values,d=o,h=i,f=u,g=c,{selectedIndices:m,selectedScores:b}=bY(l,p,d,h,f,g);return[n.makeTensorInfo([m.length],"int32",new Int32Array(m)),n.makeTensorInfo([b.length],"float32",new Float32Array(b))]}var vY={kernelName:Gc,backendName:"cpu",kernelFunc:yY};function xY(e){let{inputs:t,backend:n,attrs:r}=e,{indices:s}=t,{dtype:a,depth:o,onValue:i,offValue:u}=r;be(s,"oneHot");let c=w.sizeFromShape(s.shape),l=new Float32Array(c*o);l.fill(u);let p=n.data.get(s.dataId).values;for(let d=0;d<c;++d)p[d]>=0&&p[d]<o&&(l[d*o+p[d]]=i);return n.makeTensorInfo([...s.shape,o],a,l)}var wY={kernelName:wi,backendName:"cpu",kernelFunc:xY};function Df(e){let{inputs:t,backend:n}=e,{x:r}=t;if(r.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(r.dtype==="complex64"){let s=Io({inputs:{input:r},backend:n}),a=Df({inputs:{x:s},backend:n}),o=oc({inputs:{input:r},backend:n}),i=Df({inputs:{x:o},backend:n}),u=Qn({inputs:{real:a,imag:i},backend:n});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(i),u}else return Jk({backend:n,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}var IY={kernelName:cl,backendName:"cpu",kernelFunc:Df};function CE(e){let{inputs:t,backend:n}=e,{x:r}=t;if(r.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(r.dtype==="complex64"){let s=Io({inputs:{input:r},backend:n}),a=CE({inputs:{x:s},backend:n}),o=oc({inputs:{input:r},backend:n}),i=Df({inputs:{x:o},backend:n}),u=Qn({inputs:{real:a,imag:i},backend:n});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(i),u}else return Jk({backend:n,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}var kY={kernelName:Hc,backendName:"cpu",kernelFunc:CE};function TE(e){let{inputs:t,backend:n,attrs:r}=e,{axis:s}=r;if(t.length===1)return Af({inputs:{input:t[0]},backend:n,attrs:{dim:s}});let a=t[0].shape,o=t[0].dtype;t.forEach(l=>{w.assertShapesMatch(a,l.shape,"All tensors passed to stack must have matching shapes"),w.assert(o===l.dtype,()=>"All tensors passed to stack must have matching dtypes")});let i=[],u=t.map(l=>{let p=Af({inputs:{input:l},backend:n,attrs:{dim:s}});return i.push(p),p}),c=ic({inputs:u,backend:n,attrs:{axis:s}});return i.forEach(l=>n.disposeIntermediateTensorInfo(l)),c}var SY={kernelName:jc,backendName:"cpu",kernelFunc:TE};function CY(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{paddings:a,constantValue:o}=r;be(s,"pad");let i=a.map((v,y)=>v[0]+s.shape[y]+v[1]),u=a.map(v=>v[0]),c=n.data.get(s.dataId).values,l=w.sizeFromShape(s.shape),p=s.shape.length,d=w.computeStrides(s.shape),h=w.sizeFromShape(i),f=i.length,g=w.computeStrides(i),m=w.getTypedArrayFromDType(s.dtype,h);o!==0&&m.fill(o);for(let v=0;v<l;v++){let x=w.indexToLoc(v,p,d).map((S,N)=>S+u[N]),k=w.locToIndex(x,f,g);m[k]=c[v]}return{dataId:n.write(m,i,s.dtype),shape:i,dtype:s.dtype}}var NE={kernelName:Ii,backendName:"cpu",kernelFunc:CY},TY=Lt((e,t)=>Math.pow(e,t)),NY=Qt(ki,TY),_Y={kernelName:ki,backendName:"cpu",kernelFunc:NY};function EY(e){let{inputs:t,backend:n,attrs:r}=e,{paramsNestedSplits:s,paramsDenseValues:a,indices:o}=t,{outputRaggedRank:i}=r,u=s.map(b=>n.data.get(b.dataId).values),c=s.map(b=>b.shape),l=n.data.get(a.dataId).values,p=n.data.get(o.dataId).values,[d,h,f]=J2(u,c,l,a.shape,a.dtype,p,o.shape,i),g=d.map(b=>n.makeTensorInfo([b.length],"int32",b)),m=n.makeTensorInfo(f,a.dtype,h);return g.concat([m])}var AY={kernelName:Xf,backendName:"cpu",kernelFunc:EY};function DY(e){let{inputs:t,backend:n}=e,{starts:r,limits:s,deltas:a}=t,o=n.data.get(r.dataId).values,i=n.data.get(s.dataId).values,u=n.data.get(a.dataId).values,[c,l]=Q2(o,r.shape,r.dtype,i,s.shape,u,a.shape),p=n.makeTensorInfo([c.length],"int32",c),d=n.makeTensorInfo([l.length],r.dtype,l);return[p,d]}var $Y={kernelName:Yf,backendName:"cpu",kernelFunc:DY};function FY(e){let{inputs:t,backend:n,attrs:r}=e,{shape:s,values:a,defaultValue:o,rowPartitionTensors:i}=t,{rowPartitionTypes:u}=r,c=n.data.get(s.dataId).values,l=n.data.get(a.dataId).values,p=n.data.get(o.dataId).values,d=i.map(m=>n.data.get(m.dataId).values),h=i.map(m=>m.shape),[f,g]=eE(c,s.shape,l,a.shape,a.dtype,p,o.shape,d,h,u);return n.makeTensorInfo(f,a.dtype,g)}var RY={kernelName:Zf,backendName:"cpu",kernelFunc:FY};function PY(e){let{backend:t,attrs:n}=e,{start:r,stop:s,dtype:a,step:o}=n,i=Uk(r,s,o,a);return t.makeTensorInfo([i.length],a,i)}var OY={kernelName:Xd,backendName:"cpu",kernelFunc:PY},MY=it(Ti,e=>1/e),LY={kernelName:Ti,backendName:"cpu",kernelFunc:MY};function zY(e){let{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:o,size:i}=r;be(s,"resizeBilinear");let u=w.computeStrides(s.shape),[c,l]=i,[p,d,h,f]=s.shape,g=n.data.get(s.dataId).values,m=new Float32Array(w.sizeFromShape([p,c,l,f])),b=[a&&c>1?d-1:d,a&&l>1?h-1:h],v=[a&&c>1?c-1:c,a&&l>1?l-1:l],y=0,x=b[0]/v[0],k=b[1]/v[1];for(let S=0;S<p;S++)for(let N=0;N<c;N++){let E;o?E=x*(N+.5)-.5:E=x*N;let $=Math.max(0,Math.floor(E)),R=E-$,D=Math.min(d-1,Math.ceil(E)),F=S*u[0]+$*u[1],C=S*u[0]+D*u[1];for(let L=0;L<l;L++){let U;o?U=k*(L+.5)-.5:U=k*L;let H=Math.max(0,Math.floor(U)),K=U-H,q=Math.min(h-1,Math.ceil(U)),Z=F+H*u[2],J=C+H*u[2],ee=F+q*u[2],se=C+q*u[2];for(let te=0;te<f;te++){let oe=g[Z+te],ne=g[J+te],le=g[ee+te],ce=g[se+te],we=oe+(le-oe)*K,ye=ne+(ce-ne)*K,Ce=we+(ye-we)*R;m[y++]=Ce}}}return n.makeTensorInfo([p,c,l,f],"float32",m)}var BY={kernelName:Ei,backendName:"cpu",kernelFunc:zY};function WY(e){let{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:o}=r;be([a,s],"resizeBilinearGrad");let i=w.computeStrides(s.shape),[u,c,l,p]=s.shape,[,d,h]=a.shape,f=new Float32Array(u*c*l*p),g=[o&&d>1?c-1:c,o&&h>1?l-1:l],m=[o&&d>1?d-1:d,o&&h>1?h-1:h],b=g[0]/m[0],v=g[1]/m[1],y=n.data.get(a.dataId).values,x=0;for(let k=0;k<u;k++){let S=k*i[0];for(let N=0;N<d;N++){let E=N*b,$=Math.floor(E),R=Math.min(Math.ceil(E),c-1),D=S+$*i[1],F=S+R*i[1],C=E-$,L=1-C;for(let U=0;U<h;U++){let H=U*v,K=Math.floor(H),q=Math.min(Math.ceil(H),l-1),Z=H-K,J=1-Z,ee=D+K*i[2],se=D+q*i[2],te=F+K*i[2],oe=F+q*i[2],ne=L*J,le=L*Z,ce=C*J,we=C*Z;for(let ye=0;ye<p;ye++){let Ce=y[x++];f[ee+ye]+=Ce*ne,f[se+ye]+=Ce*le,f[te+ye]+=Ce*ce,f[oe+ye]+=Ce*we}}}}return n.makeTensorInfo([u,l,c,p],"float32",f)}var VY={kernelName:Xc,backendName:"cpu",kernelFunc:WY};function UY(e){let{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:o,size:i}=r;be(s,"resizeNearestNeighbor");let u=w.computeStrides(s.shape),[c,l]=i,[p,d,h,f]=s.shape,g=n.data.get(s.dataId).values,m=new Float32Array(p*c*l*f),b=[a&&c>1?d-1:d,a&&l>1?h-1:h],v=[a&&c>1?c-1:c,a&&l>1?l-1:l],y=b[0]/v[0],x=b[1]/v[1],k=0;for(let S=0;S<p;S++){let N=S*u[0];for(let E=0;E<c;E++){let $=o?y*(E+.5):y*E,R=Math.min(d-1,a?Math.round($):Math.floor($));o&&(R=Math.max(0,R));let D=N+R*u[1];for(let F=0;F<l;F++){let C=o?x*(F+.5):x*F,L=Math.min(h-1,a?Math.round(C):Math.floor(C));o&&(L=Math.max(0,L));let U=D+L*u[2];for(let H=0;H<f;H++){let K=g[U+H];m[k++]=K}}}}return n.makeTensorInfo([p,c,l,f],s.dtype,m)}var GY={kernelName:_i,backendName:"cpu",kernelFunc:UY};function HY(e){let{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:o}=r;be([a,s],"resizeNearestNeighborGrad");let i=w.computeStrides(s.shape),u=w.computeStrides(a.shape),[c,l,p,d]=s.shape,[,h,f]=a.shape,g=new Float32Array(c*l*p*d),m=n.data.get(a.dataId).values,b=[o&&h>1?l-1:l,o&&f>1?p-1:p],v=[o&&h>1?h-1:h,o&&f>1?f-1:f],y=b[0]/v[0],x=b[1]/v[1],k=1/y,S=1/x,N=Math.ceil(k)*2+2,E=Math.ceil(S)*2+2;for(let $=0;$<c;$++){let R=$*i[0];for(let D=0;D<l;D++){let F=R+D*i[1],C=Math.floor(D*k),L=Math.floor(C-N/2);for(let U=0;U<p;U++){let H=F+U*i[2],K=Math.floor(U*S),q=Math.floor(K-E/2);for(let Z=0;Z<d;Z++){let J=0;for(let ee=0;ee<N;ee++){let se=ee+L;if(se<0||se>=h)continue;let te=R+se*u[1],oe=se*y,ne=Math.min(l-1,o?Math.round(oe):Math.floor(oe));if(D===ne)for(let le=0;le<E;le++){let ce=le+q;if(ce<0||ce>=f)continue;let we=te+ce*u[2],ye=ce*x,Ce=Math.min(p-1,o?Math.round(ye):Math.floor(ye));U===Ce&&(J+=m[we+Z])}}g[H+Z]=J}}}}return n.makeTensorInfo(s.shape,s.dtype,g)}var jY={kernelName:Kc,backendName:"cpu",kernelFunc:HY};function qY(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dims:a}=r;be(s,"reverse");let o=s.shape.length,i=w.parseAxisParam(a,s.shape);if(o===0)return hs({inputs:{x:s},backend:n});let u=new Vt(s.shape,s.dtype),c=n.bufferSync(s);for(let l=0;l<u.size;l++){let p=u.indexToLoc(l),d=p.slice();i.forEach(h=>d[h]=s.shape[h]-1-d[h]),u.set(c.get(...d),...p)}return n.makeTensorInfo(u.shape,u.dtype,u.values)}var KY={kernelName:Di,backendName:"cpu",kernelFunc:qY},XY={kernelName:ll,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{image:r}=e,{radians:s,fillValue:a,center:o}=t,i=n,u=w.getTypedArrayFromDType(r.dtype,w.sizeFromShape(r.shape)),[c,l,p,d]=r.shape,[h,f]=T.getImageCenter(o,l,p),g=255,m=Math.sin(s),b=Math.cos(s),v=i.data.get(r.dataId).values;for(let x=0;x<c;x++){let k=x*p*l*d;for(let S=0;S<l;S++){let N=S*(p*d);for(let E=0;E<p;E++){let $=E*d;for(let R=0;R<d;R++){let D=[c,S,E,R],F=D[2],C=D[1],L=(F-h)*b-(C-f)*m,U=(F-h)*m+(C-f)*b;L=Math.round(L+h),U=Math.round(U+f);let H=a;if(typeof a!="number"&&(R===3?H=g:H=a[R]),L>=0&&L<p&&U>=0&&U<l){let q=U*(p*d),Z=L*d,J=k+q+Z+R;H=v[J]}let K=k+N+$+R;u[K]=H}}}}return{dataId:i.write(u,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},YY=it($i,e=>{let t=Math.floor(e);return e-t<.5?Math.floor(e):e-t>.5?Math.ceil(e):t%2===0?t:t+1}),ZY={kernelName:$i,backendName:"cpu",kernelFunc:YY};function JY(e){let{inputs:t,backend:n,attrs:r}=e,{indices:s,updates:a}=t,{shape:o}=r,{sliceRank:i,numUpdates:u,sliceSize:c,strides:l,outputSize:p}=T.calculateShapes(a,s,o),d=!0,h=n.bufferSync(s),f=n.bufferSync(a),g=ao(h,f,o,p,c,u,i,l,0,d);return n.makeTensorInfo(o,g.dtype,g.values)}var QY={kernelName:Yc,backendName:"cpu",kernelFunc:JY};function e9(e,t){let n=0,r=e.length,s=0;for(;n<r;)s=Math.floor((n+r)/2),e[s]<t?n=s+1:r=s;return r}function t9(e,t){let n=0,r=e.length,s=0;for(;n<r;)s=Math.floor((n+r)/2),e[s]<=t?n=s+1:r=s;return r}function n9(e,t,n,r,s,a){let o=w.getArrayFromDType("int32",n*s);for(let i=0;i<n;++i){let u=e.slice(i*r,(i+1)*r),c=i*s;for(let l=0;l<s;++l)o[c+l]=a==="left"?e9(u,t[l+c]):t9(u,t[l+c])}return o}function r9(e){let{inputs:t,backend:n,attrs:r}=e,{sortedSequence:s,values:a}=t,{side:o}=r,i=n.data.get(s.dataId).values,u=n.data.get(a.dataId).values,c=n9(i,u,s.shape[0],s.shape[1],a.shape[1],o);return n.makeTensorInfo(a.shape,"int32",c)}var s9={kernelName:Jc,backendName:"cpu",kernelFunc:r9};function a9(e){let{inputs:t,backend:n}=e,{condition:r,t:s,e:a}=t;be([r,s,a],"select");let o=r.shape.length,i=n.data.get(r.dataId).values,u=n.data.get(s.dataId).values,c=n.data.get(a.dataId).values,l=mr(s.dtype,a.dtype),p=w.makeZerosTypedArray(w.sizeFromShape(s.shape),l),d=0,h=o===0||o>1||s.shape.length===1?1:w.sizeFromShape(s.shape.slice(1));for(let f=0;f<i.length;f++)for(let g=0;g<h;g++)i[f]===1?p[d++]=u[f]:p[d++]=c[f];return n.makeTensorInfo(s.shape,l,p)}var o9={kernelName:Qc,backendName:"cpu",kernelFunc:a9},i9=T.SELU_SCALEALPHA,u9=T.SELU_SCALE,c9=it(Ri,e=>e>=0?u9*e:i9*(Math.exp(e)-1)),l9={kernelName:Ri,backendName:"cpu",kernelFunc:c9},d9=it(Mi,e=>e<0?-1:e>0?1:0),p9={kernelName:Mi,backendName:"cpu",kernelFunc:d9},h9=it(Pi,e=>Math.sin(e)),f9={kernelName:Pi,backendName:"cpu",kernelFunc:h9},m9=it(Oi,e=>Math.sinh(e)),g9={kernelName:Oi,backendName:"cpu",kernelFunc:m9},b9=11920928955078125e-23,g1=Math.log(b9)+2,y9=it(zi,e=>{let t=e>-g1,n=e<g1,r=Math.exp(e),s;return n?s=r:t?s=e:s=Math.log(1+r),s}),v9={kernelName:zi,backendName:"cpu",kernelFunc:y9};function x9(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,paddings:o}=r;be([s],"spaceToBatchND");let i=w.sizeFromShape(a),u=[[0,0]];u.push(...o);for(let S=1+a.length;S<s.shape.length;++S)u.push([0,0]);let c=NE.kernelFunc({inputs:{x:s},backend:n,attrs:{paddings:u,constantValue:0}}),l=T.getReshaped(c.shape,a,i,!1),p=T.getPermuted(l.length,a.length,!1),d=T.getReshapedPermuted(c.shape,a,i,!1),g=yt({inputs:{x:c},backend:n,attrs:{shape:l}}),v=Un({inputs:{x:g},backend:n,attrs:{perm:p}}),k=yt({inputs:{x:v},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(v),k}var w9={kernelName:tl,backendName:"cpu",kernelFunc:x9};function I9(e){let{inputs:t,backend:n}=e,{indices:r,values:s,denseShape:a,defaultValue:o}=t;if(a.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${a.shape}`);if(r.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${r.shape}`);if(s.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${s.shape}`);if(o.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${o.shape}`);let i=n.data.get(r.dataId).values,u=n.data.get(s.dataId).values,c=n.data.get(a.dataId).values,l=n.data.get(o.dataId).values[0],[p,d,h,f,g]=rE(i,r.shape,r.dtype,u,s.dtype,c,l);return[n.makeTensorInfo(d,r.dtype,p),n.makeTensorInfo([d[0]],s.dtype,h),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(m=>Number(m)))),n.makeTensorInfo([g.length],r.dtype,new Int32Array(g))]}var k9={kernelName:Yd,backendName:"cpu",kernelFunc:I9};function S9(e){let{inputs:t,backend:n}=e,{inputIndices:r,inputShape:s,newShape:a}=t;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${r.shape}`);if(s.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${s.shape}`);if(a.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${a.shape}`);let o=Array.from(n.data.get(s.dataId).values),i=n.data.get(r.dataId).values,u=Array.from(n.data.get(a.dataId).values),[c,l,p]=sE(i,r.shape,r.dtype,o,u);return[n.makeTensorInfo(l,r.dtype,c),n.makeTensorInfo([p.length],a.dtype,new Int32Array(p))]}var C9={kernelName:rl,backendName:"cpu",kernelFunc:S9};function T9(e){let{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${s.shape}`);if(a.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${a.shape}`);if(s.shape[0]!==a.shape[0])throw new Error("segmentIds and indices should have same size.");let o=n.data.get(r.dataId).values,i=n.data.get(s.dataId).values,u=n.data.get(a.dataId).values,[c,l]=Gk(o,r.shape,r.dtype,i,u,!0);return n.makeTensorInfo(l,r.dtype,c)}var N9={kernelName:Zd,backendName:"cpu",kernelFunc:T9};function _9(e){let{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${s.shape}`);if(a.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${a.shape}`);if(s.shape[0]!==a.shape[0])throw new Error("segmentIds and indices should have same size.");let o=n.data.get(r.dataId).values,i=n.data.get(s.dataId).values,u=n.data.get(a.dataId).values,[c,l]=Gk(o,r.shape,r.dtype,i,u);return n.makeTensorInfo(l,r.dtype,c)}var E9={kernelName:Jd,backendName:"cpu",kernelFunc:_9};function A9(e){let{inputs:t,backend:n,attrs:r}=e,{sparseIndices:s,sparseValues:a,defaultValue:o}=t,{outputShape:i}=r,{sliceRank:u,numUpdates:c,sliceSize:l,strides:p,outputSize:d}=T.calculateShapes(a,s,i),h=!1,f=n.bufferSync(s),g;switch(a.dtype){case"bool":{let m=n.bufferSync(a),b=!!n.data.get(o.dataId).values[0];g=ao(f,m,i,d,l,c,u,p,b,h);break}case"float32":{let m=n.bufferSync(a),b=n.data.get(o.dataId).values[0];g=ao(f,m,i,d,l,c,u,p,b,h);break}case"int32":{let m=n.bufferSync(a),b=n.data.get(o.dataId).values[0];g=ao(f,m,i,d,l,c,u,p,b,h);break}case"string":{let m=n.bufferSync(a),b=w.decodeString(n.data.get(o.dataId).values[0]);g=ao(f,m,i,d,l,c,u,p,b,h);break}default:throw new Error(`Unsupported type ${a.dtype}`)}return n.makeTensorInfo(i,g.dtype,g.values)}var D9={kernelName:sl,backendName:"cpu",kernelFunc:A9};function $9(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{numOrSizeSplits:a,axis:o}=r,i=w.parseAxisParam(o,s.shape)[0],u=T.prepareSplitSize(s,a,i),c=new Array(s.shape.length).fill(0),l=s.shape.slice();return u.map(p=>{let d=[...l];d[i]=p;let h=ko({inputs:{x:s},backend:n,attrs:{begin:c,size:d}});return c[i]+=p,h})}var F9={kernelName:nl,backendName:"cpu",kernelFunc:$9},R9={kernelName:Qd,backendName:"cpu",kernelFunc:({inputs:e,backend:t})=>{let{x:n}=e,r=t;be(n,"square");let s=r.data.get(n.dataId).values,a=new Float32Array(s.length);for(let i=0;i<s.length;++i){let u=s[i];a[i]=u*u}return{dataId:r.write(a,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}},P9=it(Na,(e,t)=>{let n=t;return isNaN(e)?NaN:e>0?1:n.alpha}),O9={kernelName:Na,backendName:"cpu",kernelFunc:P9};function M9(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,end:o,strides:i,beginMask:u,endMask:c,ellipsisMask:l,newAxisMask:p,shrinkAxisMask:d}=r;be(s,"stridedSlice");let{finalShapeSparse:h,finalShape:f,isIdentity:g,sliceDim0:m,isSimpleSlice:b,begin:v,end:y,strides:x}=Yt.sliceInfo(s.shape,a,o,i,u,c,l,p,d),k;if(g)k=yt({inputs:{x:s},backend:n,attrs:{shape:f}});else if(m||b){w.assert(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);let S=Yt.computeOutShape(v,y,x),N=ko({inputs:{x:s},backend:n,attrs:{begin:v,size:S}});k=yt({inputs:{x:N},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(N)}else{let S=n.bufferSync(s),N=iE(h,S,x,v);k=n.makeTensorInfo(f,N.dtype,N.values)}return k}var L9={kernelName:al,backendName:"cpu",kernelFunc:M9};function z9(e){let{inputs:t,backend:n,attrs:r}=e,{separator:s,nGramWidths:a,leftPad:o,rightPad:i,padWidth:u,preserveShortSequences:c}=r,{data:l,dataSplits:p}=t,d=n.data.get(l.dataId).values,h=n.data.get(p.dataId).values,[f,g]=Hk(d,h,s,a,o,i,u,c);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(p.shape,"int32",g)]}var B9={kernelName:tp,backendName:"cpu",kernelFunc:z9};function W9(e){let{inputs:t,backend:n,attrs:r}=e,{skipEmpty:s}=r,{input:a,delimiter:o}=t;if(a.dtype!=="string")throw new Error("Input must be of datatype string");if(a.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${a.shape}`);if(o.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);let i=n.data.get(a.dataId).values,u=n.data.get(o.dataId).values[0],[c,l,p]=jk(i,u,s),d=l.length;return[n.makeTensorInfo([d,2],"int32",c),n.makeTensorInfo([d],"string",l),n.makeTensorInfo([2],"int32",new Int32Array(p))]}var V9={kernelName:np,backendName:"cpu",kernelFunc:W9};function U9(e){let{inputs:t,backend:n,attrs:r}=e,{numBuckets:s}=r,{input:a}=t;if(a.dtype!=="string")throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");let o=n.data.get(a.dataId).values,i=qk(o,s);return n.makeTensorInfo(a.shape,"int32",i)}var G9={kernelName:rp,backendName:"cpu",kernelFunc:U9},H9=it(Hi,e=>Math.tan(e)),j9={kernelName:Hi,backendName:"cpu",kernelFunc:H9},q9=it(ji,e=>Math.tanh(e)),K9={kernelName:ji,backendName:"cpu",kernelFunc:q9};function X9(e){let{inputs:t,backend:n}=e,{tensor:r,indices:s,updates:a}=t,{sliceRank:o,numUpdates:i,sliceSize:u,strides:c,outputSize:l}=T.calculateShapes(a,s,r.shape),p=!1,d=n.bufferSync(s),h=n.bufferSync(a),f=n.bufferSync(r),g=ao(d,h,r.shape,l,u,i,o,c,f,p);return n.makeTensorInfo(r.shape,g.dtype,g.values)}var Y9={kernelName:Zc,backendName:"cpu",kernelFunc:X9};function Z9(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reps:a}=r;be(s,"tile");let o=cE(n.bufferSync(s),a);return n.makeTensorInfo(o.shape,o.dtype,o.values)}var J9={kernelName:Ta,backendName:"cpu",kernelFunc:Z9};function Q9(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{k:a,sorted:o}=r;be(s,"topk");let i=n.data.get(s.dataId).values,[u,c]=dE(i,s.shape,s.dtype,a,o);return[n.makeTensorInfo(u.shape,u.dtype,u.values),n.makeTensorInfo(c.shape,c.dtype,c.values)]}var eZ={kernelName:ol,backendName:"cpu",kernelFunc:Q9};function tZ(e){let{inputs:t,attrs:n,backend:r}=e,{image:s,transforms:a}=t,{interpolation:o,fillMode:i,fillValue:u,outputShape:c}=n,[l,p,d,h]=s.shape,[f,g]=c??[p,d],m=[l,f,g,h],b=w.computeStrides(s.shape),v=b[0],y=b[1],x=b[2],k=w.computeStrides(m),S=k[0],N=k[1],E=k[2],$=w.getTypedArrayFromDType(s.dtype,w.sizeFromShape(m));$.fill(u);let R=r.data.get(s.dataId).values,D=r.data.get(a.dataId).values;for(let C=0;C<l;++C){let L=a.shape[0]===1?D:D.subarray(C*8,C*8+8);for(let U=0;U<f;++U)for(let H=0;H<g;++H)for(let K=0;K<h;++K){let q,Z=L[6]*H+L[7]*U+1;if(Z===0)continue;let J=(L[0]*H+L[1]*U+L[2])/Z,ee=(L[3]*H+L[4]*U+L[5])/Z,se=b1(J,d,i),te=b1(ee,p,i);switch(o){case"nearest":q=iZ(R,p,d,v,y,x,C,te,se,K,u);break;case"bilinear":q=uZ(R,p,d,v,y,x,C,te,se,K,u);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${o}`)}let oe=C*S+U*N+H*E+K;$[oe]=q}return r.makeTensorInfo(m,s.dtype,$)}return{dataId:r.write($,m,s.dtype),shape:s.shape,dtype:s.dtype}}var nZ={kernelName:il,backendName:"cpu",kernelFunc:tZ};function b1(e,t,n){switch(n){case"reflect":return rZ(e,t);case"wrap":return sZ(e,t);case"nearest":return oZ(e,t);case"constant":default:return aZ(e,t)}}function rZ(e,t){let n=e;if(n<0)if(t<=1)n=0;else{let r=2*t;n<r&&(n=r*Math.trunc(-n/r)+n),n=n<-t?n+r:-n-1}else if(n>t-1)if(t<=1)n=0;else{let r=2*t;n-=r*Math.trunc(n/r),n>=t&&(n=r-n-1)}return w.clamp(0,n,t-1)}function sZ(e,t){let n=e;if(n<0)if(t<=1)n=0;else{let r=t-1;n+=t*(Math.trunc(-n/r)+1)}else if(n>t-1)if(t<=1)n=0;else{let r=t-1;n-=t*Math.trunc(n/r)}return w.clamp(0,n,t-1)}function aZ(e,t){return e}function oZ(e,t){return w.clamp(0,e,t-1)}function ud(e,t,n,r,s,a,o,i,u,c,l){let p=o*r+i*s+u*a+c;return 0<=i&&i<t&&0<=u&&u<n?e[p]:l}function iZ(e,t,n,r,s,a,o,i,u,c,l){let p=Math.round(i),d=Math.round(u);return ud(e,t,n,r,s,a,o,p,d,c,l)}function uZ(e,t,n,r,s,a,o,i,u,c,l){let p=Math.floor(i),d=Math.floor(u),h=p+1,f=d+1,g=(f-u)*ud(e,t,n,r,s,a,o,p,d,c,l)+(u-d)*ud(e,t,n,r,s,a,o,p,f,c,l),m=(f-u)*ud(e,t,n,r,s,a,o,h,d,c,l)+(u-d)*ud(e,t,n,r,s,a,o,h,f,c,l);return(h-i)*g+(i-p)*m}function cZ(e){let{inputs:t,attrs:n,backend:r}=e,{axis:s}=n,{x:a}=t;be(a,"unique");let o=r.data.get(a.dataId).values,{outputValues:i,outputShape:u,indices:c}=Xk(o,s,a.shape,a.dtype);return[r.makeTensorInfo(u,a.dtype,i),r.makeTensorInfo([c.length],"int32",c)]}var lZ={kernelName:sp,backendName:"cpu",kernelFunc:cZ};function dZ(e){let{inputs:t,backend:n,attrs:r}=e,{value:s}=t,{axis:a}=r;a<0&&(a+=s.shape.length);let o=s.shape.length,i=s.shape[a],u=new Array(o-1),c=0;for(let h=0;h<o;h++)h!==a&&(u[c++]=s.shape[h]);let l=new Array(o).fill(0),p=s.shape.slice();p[a]=1;let d=new Array(i);for(let h=0;h<d.length;h++){l[a]=h;let f=ko({inputs:{x:s},backend:n,attrs:{begin:l,size:p}});d[h]=yt({inputs:{x:f},backend:n,attrs:{shape:u}}),n.disposeIntermediateTensorInfo(f)}return d}var pZ={kernelName:ul,backendName:"cpu",kernelFunc:dZ};function hZ(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,segmentIds:a}=t,{numSegments:o}=r;be(s,"unsortedSegmentSum");let i=s.shape.length,u=a.shape.length,c=[],l=[],p=i-u,d=a;for(let f=0;f<p;++f){let g=Af({inputs:{input:d},backend:n,attrs:{dim:f+1}});d=g,l.push(g)}for(let f=0;f<o;++f){let g=w.createScalarValue(f,"int32"),m=n.makeTensorInfo([],"int32",g),b=$2({inputs:{a:m,b:d},backend:n}),v=wa({inputs:{x:b},backend:n,attrs:{dtype:"float32"}}),y=eg({inputs:{a:v,b:s},backend:n}),x=Op({inputs:{x:y},backend:n,attrs:{axis:0,keepDims:!1}});c.push(x),l.push(m),l.push(b),l.push(v),l.push(y),l.push(x)}let h=TE({inputs:c,backend:n,attrs:{axis:0}});return l.forEach(f=>n.disposeIntermediateTensorInfo(f)),h}var fZ={kernelName:ap,backendName:"cpu",kernelFunc:hZ},mZ=[uK,Vq,lK,pK,Kq,fK,gK,yK,xK,IK,SK,TK,_K,DK,FK,OK,LK,BK,VK,oK,GK,jK,KK,Yq,YK,jq,Jq,JK,Uq,eX,nX,rX,aX,iX,cX,dX,hX,mX,bX,vX,wX,kX,CX,NX,_X,AX,$X,RX,PX,OX,MX,zX,VX,Q8,GX,Qq,JX,e8,QX,n8,a7,o7,u7,s8,o8,l7,p7,f7,g7,u8,l8,Gq,y7,tX,x7,I7,S7,eK,p8,f8,T7,g8,_7,D7,F7,O7,L7,B7,W7,y8,U7,H7,q7,X7,Z7,Q7,tY,x8,rY,oY,lY,I8,S8,hY,gY,vY,T8,wY,kY,SY,NE,_Y,nK,E8,AY,$Y,RY,OY,Hq,px,LY,rK,sK,aK,BY,VY,GY,jY,KY,XY,ZY,M8,QY,s9,o9,l9,z8,p9,f9,g9,B8,uY,v9,w9,k9,C9,N9,E9,D9,F9,U8,R9,H8,q8,O9,L9,B9,V9,G9,Z8,BX,j9,K9,Y9,J9,eZ,nZ,N8,lZ,pZ,fZ,IY];for(let e of mZ)op(e);var _E={};Ee(_E,{assertNotComplex:()=>wl,bindCanvasToFramebuffer:()=>TZ,bindColorTextureToFramebuffer:()=>tf,bindTextureToProgramUniformSampler:()=>GE,bindTextureUnit:()=>WE,bindVertexBufferToProgramAttribute:()=>fx,callAndCheck:()=>he,canBeRepresented:()=>AE,createFragmentShader:()=>FE,createFramebuffer:()=>BE,createProgram:()=>RE,createStaticIndexBuffer:()=>ME,createStaticVertexBuffer:()=>OE,createTexture:()=>LE,createVertexShader:()=>$E,getBatchDim:()=>So,getExtensionOrThrow:()=>cd,getFramebufferErrorMessage:()=>HE,getMaxTexturesInShader:()=>XE,getNumChannels:()=>SZ,getProgramUniformLocation:()=>UE,getProgramUniformLocationOrThrow:()=>VE,getRowsCols:()=>Co,getShapeAs3D:()=>dd,getTextureShapeFromLogicalShape:()=>qE,getWebGLDisjointQueryTimerVersion:()=>YE,getWebGLErrorMessage:()=>DE,getWebGLMaxTextureSize:()=>KE,hasExtension:()=>pr,isCapableOfRenderingToFloatTexture:()=>ZE,isDownloadFloatTextureEnabled:()=>JE,isReshapeFree:()=>$d,isWebGLFenceEnabled:()=>QE,isWebGLVersionEnabled:()=>gx,linkProgram:()=>PE,logShaderSourceAndInfoLog:()=>e0,resetMaxTextureSize:()=>NZ,resetMaxTexturesInShader:()=>_Z,unbindColorTextureFromFramebuffer:()=>mx,unbindTextureUnit:()=>CZ,validateFramebuffer:()=>ld,validateProgram:()=>ef,validateTextureSize:()=>zE});var no={},jh={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function EE(e,t){no[e]=t}function Xr(e,t){if(!(e in no)||t!=null){let r=bZ(e,t);if(r!==null)no[e]=r;else return console.log("Could not get context for WebGL version",e),null}let n=no[e];return n==null||n.isContextLost()?(delete no[e],Xr(e)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),no[e])}function gZ(e){if(!G().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&e===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function bZ(e,t){if(e!==1&&e!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");let n=t??gZ(e);return n.addEventListener("webglcontextlost",r=>{r.preventDefault(),delete no[e]},!1),G().getBool("SOFTWARE_WEBGL_ENABLED")&&(jh.failIfMajorPerformanceCaveat=!1),e===1?n.getContext("webgl",jh)||n.getContext("experimental-webgl",jh):n.getContext("webgl2",jh)}var Dd;(function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"})(Dd||(Dd={}));var dr;(function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"})(dr||(dr={}));var hn;(function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(hn||(hn={}));function Mp(e,t){return[t,e]}function yZ(e,t){return e*t}function qh(e){let t=w.sizeFromShape(e),n=Math.ceil(t/4);return w.sizeToSquarishShape(n)}function xl(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function vZ(e,t){let[n,r]=xl(e,t);return n*r*4}function Qk(e,t){let n=e,r,s,a,o,i,u,c,l,p,d;return G().getNumber("WEBGL_VERSION")===2?(r=n.R32F,s=n.R16F,a=n.RGBA16F,o=n.RGBA32F,i=n.RED,c=4,l=1,p=n.HALF_FLOAT,d=n.FLOAT,u=n.RGBA8):(r=e.RGBA,s=e.RGBA,a=e.RGBA,o=n.RGBA,i=e.RGBA,c=4,l=4,p=t!=null?t.HALF_FLOAT_OES:null,d=e.FLOAT,u=e.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:s,internalFormatPackedHalfFloat:a,internalFormatPackedFloat:o,textureFormatFloat:i,downloadTextureFormat:u,downloadUnpackNumChannels:c,defaultNumChannels:l,textureTypeHalfFloat:p,textureTypeFloat:d}}function he(e,t){let n=t();return G().getBool("DEBUG")&&xZ(e),n}function xZ(e){let t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+DE(e,t))}var wZ=596e-10,IZ=65504;function AE(e){return!!(G().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||e===0||wZ<Math.abs(e)&&Math.abs(e)<IZ)}function DE(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}function cd(e,t){return Bs(e,()=>e.getExtension(t),'Extension "'+t+'" not supported on this browser.')}function $E(e,t){let n=Bs(e,()=>e.createShader(e.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(he(e,()=>e.shaderSource(n,t)),he(e,()=>e.compileShader(n)),e.getShaderParameter(n,e.COMPILE_STATUS)===!1)throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}function FE(e,t){let n=Bs(e,()=>e.createShader(e.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(he(e,()=>e.shaderSource(n,t)),he(e,()=>e.compileShader(n)),G().get("ENGINE_COMPILE_ONLY"))return n;if(e.getShaderParameter(n,e.COMPILE_STATUS)===!1)throw e0(t,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}var kZ=/ERROR: [0-9]+:([0-9]+):/g;function e0(e,t){let n=kZ.exec(t);if(n==null){console.log(`Couldn't parse line number in error: ${t}`),console.log(e);return}let r=+n[1],s=e.split(`
`),a=s.length.toString().length+2,o=s.map((p,d)=>w.rightPad((d+1).toString(),a)+p),i=0;for(let p=0;p<o.length;p++)i=Math.max(o[p].length,i);let u=o.slice(0,r-1),c=o.slice(r-1,r),l=o.slice(r);console.log(u.join(`
`)),console.log(t.split(`
`)[0]),console.log(`%c ${w.rightPad(c[0],i)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(l.join(`
`))}function RE(e){return Bs(e,()=>e.createProgram(),"Unable to create WebGLProgram.")}function PE(e,t){if(he(e,()=>e.linkProgram(t)),!G().get("ENGINE_COMPILE_ONLY")&&e.getProgramParameter(t,e.LINK_STATUS)===!1)throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}function ef(e,t){if(he(e,()=>e.validateProgram(t)),e.getProgramParameter(t,e.VALIDATE_STATUS)===!1)throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function OE(e,t){let n=Bs(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return he(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),he(e,()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW)),n}function ME(e,t){let n=Bs(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return he(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n)),he(e,()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW)),n}function SZ(){return G().getNumber("WEBGL_VERSION")===2?1:4}function LE(e){return Bs(e,()=>e.createTexture(),"Unable to create WebGLTexture.")}function zE(e,t){let n=G().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0){let r=`[${e}x${t}]`;throw new Error("Requested texture size "+r+" is invalid.")}if(e>n||t>n){let r=`[${e}x${t}]`,s=`[${n}x${n}]`;throw new Error("Requested texture size "+r+" greater than WebGL maximum on this browser / GPU "+s+".")}}function BE(e){return Bs(e,()=>e.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function fx(e,t,n,r,s,a,o){let i=e.getAttribLocation(t,n);return i===-1?!1:(he(e,()=>e.bindBuffer(e.ARRAY_BUFFER,r)),he(e,()=>e.vertexAttribPointer(i,s,e.FLOAT,!1,a,o)),he(e,()=>e.enableVertexAttribArray(i)),!0)}function WE(e,t,n){jE(e,n),he(e,()=>e.activeTexture(e.TEXTURE0+n)),he(e,()=>e.bindTexture(e.TEXTURE_2D,t))}function CZ(e,t){jE(e,t),he(e,()=>e.activeTexture(e.TEXTURE0+t)),he(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function VE(e,t,n){return Bs(e,()=>e.getUniformLocation(t,n),'uniform "'+n+'" not present in program.')}function UE(e,t,n){return e.getUniformLocation(t,n)}function GE(e,t,n,r){he(e,()=>WE(e,t,r)),he(e,()=>e.uniform1i(n,r))}function TZ(e){he(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),he(e,()=>e.viewport(0,0,e.canvas.width,e.canvas.height)),he(e,()=>e.scissor(0,0,e.canvas.width,e.canvas.height))}function tf(e,t,n){he(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,n)),he(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0))}function mx(e,t){he(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,t)),he(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0))}function ld(e){let t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+HE(e,t))}function HE(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}function Bs(e,t,n){let r=he(e,()=>t());if(r==null)throw new Error(n);return r}function jE(e,t){let n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=t+e.TEXTURE0;if(r<e.TEXTURE0||r>n){let s=`[gl.TEXTURE0, gl.TEXTURE${n}]`;throw new Error(`textureUnit must be in ${s}.`)}}function So(e,t=2){return w.sizeFromShape(e.slice(0,e.length-t))}function Co(e){if(e.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function dd(e){let t=[1,1,1];return e.length===0||e.length===1&&e[0]===1||(t=[So(e),...Co(e)]),t}function qE(e,t=!1){let n=G().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=G().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");r===1/0&&G().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=n/2),t&&(n=n*2,r=r*2,e=e.map((i,u)=>u>=e.length-2?w.nearestLargerEven(e[u]):e[u]),e.length===1&&(e=[2,e[0]])),e.length!==2&&(e=w.squeezeShape(e).newShape);let s=w.sizeFromShape(e),a=null;e.length<=1&&s<=n?a=[1,s]:e.length===2&&e[0]<=n&&e[1]<=n?a=e:e.length===3&&e[0]*e[1]<=n&&e[2]<=n?a=[e[0]*e[1],e[2]]:e.length===3&&e[0]<=n&&e[1]*e[2]<=n?a=[e[0],e[1]*e[2]]:e.length===4&&e[0]*e[1]*e[2]<=n&&e[3]<=n?a=[e[0]*e[1]*e[2],e[3]]:e.length===4&&e[0]<=n&&e[1]*e[2]*e[3]<=n&&(a=[e[0],e[1]*e[2]*e[3]]);let o=a!=null&&Math.max(...a)>r&&Math.min(...a)<=(t?2:1)&&Math.min(...a)>0;if(a==null||o)if(t){let i=So(e),u=2,c=2;e.length&&([u,c]=Co(e)),s=i*(u/2)*(c/2),a=w.sizeToSquarishShape(s).map(l=>l*2)}else a=w.sizeToSquarishShape(s);return a}function Kh(e){return e%2===0}function $d(e,t){if(e=e.slice(-2),t=t.slice(-2),w.arraysEqual(e,t)||!e.length||!t.length||e[0]===0||e[1]===0||t[0]===0||t[1]===0)return!0;if(e.length!==t.length){let n=e[e.length-1],r=t[t.length-1];if(n===r||Kh(n)&&Kh(r)&&(e[0]===1||t[0]===1))return!0}return e[1]===t[1]&&Kh(e[0])&&Kh(t[0])}var nf,rf;function KE(e){if(nf==null){let t=Xr(e);nf=t.getParameter(t.MAX_TEXTURE_SIZE)}return nf}function NZ(){nf=null}function _Z(){rf=null}function XE(e){if(rf==null){let t=Xr(e);rf=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,rf)}function YE(e){if(e===0)return 0;let t,n=Xr(e);return pr(n,"EXT_disjoint_timer_query_webgl2")&&e===2?t=2:pr(n,"EXT_disjoint_timer_query")?t=1:t=0,t}function pr(e,t){return e.getExtension(t)!=null}function gx(e){try{if(Xr(e)!=null)return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function ZE(e){if(e===0)return!1;let t=Xr(e);if(e===1){if(!pr(t,"OES_texture_float"))return!1}else if(!pr(t,"EXT_color_buffer_float"))return!1;return bx(t)}function JE(e){if(e===0)return!1;let t=Xr(e);if(e===1){if(!pr(t,"OES_texture_float")||!pr(t,"WEBGL_color_buffer_float"))return!1}else{if(pr(t,"EXT_color_buffer_float"))return bx(t);let r="EXT_color_buffer_half_float";if(pr(t,r)){let s=t.getExtension(r);return EZ(t,s)}return!1}return bx(t)}function bx(e){let t=Qk(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n);let r=1,s=1;e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,r,s,0,t.textureFormatFloat,t.textureTypeFloat,null);let a=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,a),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);let o=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(a),o}function EZ(e,t){let n=Qk(e,t),r=e.createTexture();e.bindTexture(e.TEXTURE_2D,r);let s=1,a=1;e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,s,a,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);let o=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,o),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0);let i=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(r),e.deleteFramebuffer(o),i}function QE(e){return e!==2?!1:Xr(e).fenceSync!=null}function wl(e,t){Array.isArray(e)||(e=[e]),e.forEach(n=>{n!=null&&w.assert(n.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the WebGL backend.`)})}var ve=G();ve.registerFlag("HAS_WEBGL",()=>ve.getNumber("WEBGL_VERSION")>0);ve.registerFlag("WEBGL_VERSION",()=>gx(2)?2:gx(1)?1:0);ve.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);ve.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>ve.get("WEBGL_VERSION")===2);ve.registerFlag("WEBGL_CPU_FORWARD",()=>!0);ve.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);ve.registerFlag("WEBGL_PACK",()=>ve.getBool("HAS_WEBGL"));ve.registerFlag("WEBGL_PACK_NORMALIZATION",()=>ve.getBool("WEBGL_PACK"));ve.registerFlag("WEBGL_PACK_CLIP",()=>ve.getBool("WEBGL_PACK"));ve.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>ve.getBool("WEBGL_PACK"));ve.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>ve.getBool("WEBGL_PACK"));ve.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>ve.getBool("WEBGL_PACK"));ve.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>ve.getBool("WEBGL_PACK"));ve.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>ve.getBool("WEBGL_PACK"));ve.registerFlag("WEBGL_PACK_REDUCE",()=>ve.getBool("WEBGL_PACK"));ve.registerFlag("WEBGL_LAZILY_UNPACK",()=>ve.getBool("WEBGL_PACK"));ve.registerFlag("WEBGL_CONV_IM2COL",()=>ve.getBool("WEBGL_PACK"));ve.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>KE(ve.getNumber("WEBGL_VERSION")));ve.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>XE(ve.getNumber("WEBGL_VERSION")));ve.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{let e=ve.getNumber("WEBGL_VERSION");return e===0?0:YE(e)});ve.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>ve.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!cp.isMobile());ve.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>ZE(ve.getNumber("WEBGL_VERSION")));ve.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>ve.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:ve.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));ve.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>JE(ve.getNumber("WEBGL_VERSION")));ve.registerFlag("WEBGL_FENCE_API_ENABLED",()=>QE(ve.getNumber("WEBGL_VERSION")));ve.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>ve.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);ve.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,e=>{if(e<0&&e!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`)});ve.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>cp.isMobile()?1:-1,e=>{if(e<0&&e!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e}.`)});ve.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);ve.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);ve.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);ve.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);ve.registerFlag("WEBGL_EXP_CONV",()=>!1);ve.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>ve.getBool("IS_TEST"));ve.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);ve.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);ve.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);ve.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);function $n(){let e,t,n,r,s,a,o,i,u,c;return G().getNumber("WEBGL_VERSION")===2?(e="#version 300 es",t="in",n="out",r="in",s="texture",a="outputColor",o="out vec4 outputColor;",i=G().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",u="",c=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(e="",t="attribute",n="varying",r="varying",s="texture2D",a="gl_FragColor",o="",i=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,u=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,c=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:e,attribute:t,varyingVs:n,varyingFs:r,texture2D:s,output:a,defineOutput:o,defineSpecialNaN:i,defineSpecialInf:u,defineRound:c}}function eu(e,t,n="index"){let r=w.computeStrides(t);return r.map((s,a)=>{let o=`int ${e[a]} = ${n} / ${s}`,i=a===r.length-1?`int ${e[a+1]} = ${n} - ${e[a]} * ${s}`:`index -= ${e[a]} * ${s}`;return`${o}; ${i};`}).join("")}function tg(e,t,n="index"){let r=w.computeStrides(t);return r.map((s,a)=>{let o=`int ${e[a]} = ${n} / outShapeStrides[${a}]`,i=a===r.length-1?`int ${e[a+1]} = ${n} - ${e[a]} * outShapeStrides[${a}]`:`index -= ${e[a]} * outShapeStrides[${a}]`;return`${o}; ${i};`}).join("")}function AZ(e,t){let n=e.length,r=e.map(a=>`${t}[${a}]`),s=new Array(n-1);s[n-2]=r[n-1];for(let a=n-3;a>=0;--a)s[a]=`(${s[a+1]} * ${r[a+1]})`;return s}function DZ(e,t,n="index"){let r=e.map((a,o)=>o),s=AZ(r,t);return s.map((a,o)=>{let i=`int ${e[o]} = ${n} / ${s[o]}`,u=o===s.length-1?`int ${e[o+1]} = ${n} - ${e[o]} * ${s[o]}`:`index -= ${e[o]} * ${s[o]}`;return`${i}; ${u};`}).join("")}function t0(e){let t=w.computeStrides(e).map(n=>n.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;
  }
`}function n0(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}var eA=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`,{getBroadcastDims:tA}=T;function $Z(e,t,n){let r=[];if(e.forEach(h=>{let f=w.sizeFromShape(h.shapeInfo.logicalShape);if(h.shapeInfo.isUniform?r.push(`uniform float ${h.name}${f>1?`[${f}]`:""};`):(r.push(`uniform sampler2D ${h.name};`),r.push(`uniform int offset${h.name};`)),n.enableShapeUniforms){let{uniformShape:g}=r0(n.packedInputs,h.shapeInfo.logicalShape,h.shapeInfo.texShape);switch(g.length){case 1:r.push(`uniform int ${h.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${h.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${h.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${h.name}Shape;`);break;default:break}r.push(`uniform ivec2 ${h.name}TexShape;`)}}),n.enableShapeUniforms){switch(t.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;");break;default:break}r.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach(h=>{r.push(`uniform ${h.type} ${h.name}${h.arrayIndex?`[${h.arrayIndex}]`:""};`)});let s=r.join(`
`),a=e.map(h=>FZ(h,t,n.packedInputs,n.enableShapeUniforms)).join(`
`),o=t.texShape,i=$n(),u=OZ(i),c,l,p=zZ(i);return t.isPacked?(c=RZ(t.logicalShape,o,n.enableShapeUniforms),l=LZ(i)):(c=PZ(t.logicalShape,o,n.enableShapeUniforms),l=MZ(i)),n.packedInputs&&(p+=UZ),[p,u,l,s,c,a,n.userCode].join(`
`)}function Il(e,t=!1){let n=e.shapeInfo.logicalShape;switch(n.length){case 0:return tJ(e,t);case 1:return rJ(e,t);case 2:return aJ(e,t);case 3:return iJ(e,t);case 4:return cJ(e,t);case 5:return lJ(e);case 6:return dJ(e);default:throw new Error(`${n.length}-D input sampling is not yet supported`)}}function nA(e,t){switch(e.shapeInfo.logicalShape.length){case 0:return eJ(e);case 1:return nJ(e,t);case 2:return sJ(e,t);case 3:return oJ(e,t);default:return uJ(e,t)}}function FZ(e,t,n=!1,r){let s="";n?s+=nA(e,r):s+=Il(e,r);let a=e.shapeInfo.logicalShape,o=t.logicalShape;return a.length<=o.length&&(n?s+=pJ(e,t):s+=hJ(e,t)),s}function RZ(e,t,n){switch(e.length){case 0:return rA();case 1:return GZ(e,t,n);case 2:return JZ(e,t,n);case 3:return jZ(e,t,n);default:return KZ(e,t,n)}}function PZ(e,t,n){switch(e.length){case 0:return rA();case 1:return HZ(e,t,n);case 2:return QZ(e,t,n);case 3:return qZ(e,t,n);case 4:return XZ(e,t,n);case 5:return YZ(e,t);case 6:return ZZ(e,t);default:throw new Error(`${e.length}-D output sampling is not yet supported`)}}function OZ(e){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${e.texture2D}(textureSampler, uv).r;
    }
  `}function MZ(e){return`
    void setOutput(float val) {
      ${e.output} = vec4(val, 0, 0, 0);
    }
  `}function LZ(e){return`
    void setOutput(vec4 val) {
      ${e.output} = val;
    }
  `}function zZ(e){return`${e.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${e.varyingFs} vec2 resultUV;
    ${e.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${e.defineSpecialNaN}
    ${e.defineSpecialInf}
    ${e.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${BZ}
    ${WZ}
    ${VZ}
  `}var BZ=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,WZ=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,VZ=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,UZ=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function rA(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function GZ(e,t,n){let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return r[0]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${r[1]}.0);
      }
    `:r[1]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${r[0]}.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);
    }
  `}function HZ(e,t,n){return t[0]===1?n?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${t[1]}.0);
      }
    `:t[1]===1?n?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${t[0]}.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      return resTexRC.x * ${t[1]} + resTexRC.y;
    }
  `}function jZ(e,t,n){if(n)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],s=Math.ceil(e[2]/2),a=s*Math.ceil(e[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      int b = index / ${a};
      index -= b * ${a};

      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec3(b, r, c);
    }
  `}function qZ(e,t,n){if(n)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${tg(["r","c","d"],e)}
    return ivec3(r, c, d);
  }
`;let r=eu(["r","c","d"],e);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${r}
      return ivec3(r, c, d);
    }
  `}function KZ(e,t,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],s=Math.ceil(e[e.length-1]/2),a=s*Math.ceil(e[e.length-2]/2),o=a,i="",u="b, r, c";for(let c=2;c<e.length-1;c++)o*=e[e.length-c-1],i=`
      int b${c} = index / ${o};
      index -= b${c} * ${o};
    `+i,u=`b${c}, `+u;return`
    ivec${e.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      ${i}

      int b = index / ${a};
      index -= b * ${a};

      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec${e.length}(${u});
    }
  `}function XZ(e,t,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${tg(["r","c","d","d2"],e)}
      return ivec4(r, c, d, d2);
    }
  `;let r=eu(["r","c","d","d2"],e);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${r}
      return ivec4(r, c, d, d2);
    }
  `}function YZ(e,t){let n=eu(["r","c","d","d2","d3"],e);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},
                             ${t[1]}));

      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${n}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function ZZ(e,t){let n=eu(["r","c","d","d2","d3","d4"],e);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${n}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function JZ(e,t,n){let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(w.arraysEqual(e,t))return n?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));
      }
    `;let s=Math.ceil(e[1]/2);return n?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));

      int index = resTexRC.x * ${r[1]} + resTexRC.y;
      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec2(r, c);
    }
  `}function QZ(e,t,n){return w.arraysEqual(e,t)?n?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));
      }
    `:e[1]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:e[0]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:n?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      int r = index / ${e[1]};
      int c = index - r * ${e[1]};
      return ivec2(r, c);
    }
  `}function tu(e){return`offset${e}`}function eJ(e){let t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),r=$n();return`
    vec4 ${n}() {
      return ${r.texture2D}(${t}, halfCR);
    }
  `}function tJ(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`float ${r}() {return ${n};}`;let[s,a]=e.shapeInfo.texShape;if(s===1&&a===1)return`
      float ${r}() {
        return sampleTexture(${n}, halfCR);
      }
    `;let o=tu(n);if(t)return`
    float ${r}() {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${o});
      return sampleTexture(${n}, uv);
    }
  `;let[i,u]=e.shapeInfo.texShape;return`
    float ${r}() {
      vec2 uv = uvFromFlat(${i}, ${u}, ${o});
      return sampleTexture(${n}, uv);
    }
  `}function nJ(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=e.shapeInfo.texShape,a=$n();if(t)return`
    vec4 ${r}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${a.texture2D}(${n}, uv);
    }
  `;let o=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];return`
    vec4 ${r}(int index) {
      vec2 uv = packedUVfrom1D(
        ${o[0]}, ${o[1]}, index);
      return ${a.texture2D}(${n}, uv);
    }
  `}function rJ(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`
      float ${r}(int index) {
        ${kl(e)}
      }
    `;let s=e.shapeInfo.texShape,a=s[0],o=s[1];if(o===1&&a===1)return`
      float ${r}(int index) {
        return sampleTexture(${n}, halfCR);
      }
    `;let i=tu(n);return o===1?t?`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${i}) + 0.5) / float(${n}TexShape[0]));
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${i}) + 0.5) / ${a}.0);
        return sampleTexture(${n}, uv);
      }
    `:a===1?t?`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${i}) + 0.5) / float(${n}TexShape[1]), 0.5);
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${i}) + 0.5) / ${o}.0, 0.5);
        return sampleTexture(${n}, uv);
      }
    `:t?`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${i});
      return sampleTexture(${n}, uv);
    }
  `:`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${a}, ${o}, index + ${i});
      return sampleTexture(${n}, uv);
    }
  `}function sJ(e,t){let n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=e.shapeInfo.texShape,o=a[0],i=a[1],u=$n();if(a!=null&&w.arraysEqual(n,a))return t?`
      vec4 ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);

        return ${u.texture2D}(${r}, uv);
      }
    `:`
      vec4 ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${i}.0, ${o}.0);

        return ${u.texture2D}(${r}, uv);
      }
    `;if(t)return`
    vec4 ${s}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${u.texture2D}(${r}, uv);
    }
  `;let c=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],l=Math.ceil(n[1]/2);return`
    vec4 ${s}(int row, int col) {
      vec2 uv = packedUVfrom2D(${l}, ${c[0]}, ${c[1]}, row, col);
      return ${u.texture2D}(${r}, uv);
    }
  `}function aJ(e,t){let n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=e.shapeInfo.texShape;if(a!=null&&w.arraysEqual(n,a)){if(t)return`
      float ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `;let d=a[0],h=a[1];return`
    float ${s}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${h}.0, ${d}.0);
      return sampleTexture(${r}, uv);
    }
  `}let{newShape:o,keptDims:i}=w.squeezeShape(n),u=o;if(u.length<n.length){let d=Sl(e,u),h=["row","col"];return`
      ${Il(d,t)}
      float ${s}(int row, int col) {
        return ${s}(${Cl(h,i)});
      }
    `}if(e.shapeInfo.isUniform)return`
      float ${s}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));
        ${kl(e)}
      }
    `;let c=a[0],l=a[1],p=tu(r);return l===1?t?`
      float ${s}(int row, int col) {
        float index = dot(vec3(row, col, ${p}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${s}(int row, int col) {
      float index = dot(vec3(row, col, ${p}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${c}.0);
      return sampleTexture(${r}, uv);
    }
  `:c===1?t?`
      float ${s}(int row, int col) {
        float index = dot(vec3(row, col, ${p}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${s}(int row, int col) {
      float index = dot(vec3(row, col, ${p}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${l}.0, 0.5);
      return sampleTexture(${r}, uv);
    }
  `:t?`
      float ${s}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${r}Shape[1] + col + ${p};
        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
        return sampleTexture(${r}, uv);
      }
    `:`
  float ${s}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${n[1]} + col + ${p};
    vec2 uv = uvFromFlat(${c}, ${l}, index);
    return sampleTexture(${r}, uv);
  }
`}function oJ(e,t){let n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=e.shapeInfo.texShape,o=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];if(n[0]===1){let d=n.slice(1),h=[1,2],f=Sl(e,d),g=["b","row","col"];return`
        ${nA(f,t)}
        vec4 ${s}(int b, int row, int col) {
          return ${s}(${Cl(g,h)});
        }
      `}let i=$n();if(t)return`
    vec4 ${s}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${i.texture2D}(${r}, uv);
    }
  `;let u=o[0],c=o[1],l=Math.ceil(n[2]/2),p=l*Math.ceil(n[1]/2);return`
    vec4 ${s}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${u}, ${c}, ${p}, ${l}, b, row, col);
      return ${i.texture2D}(${r}, uv);
    }
  `}function iJ(e,t){let n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=n[1]*n[2],o=n[2],{newShape:i,keptDims:u}=w.squeezeShape(n),c=i;if(c.length<n.length){let g=Sl(e,c),m=["row","col","depth"];return`
        ${Il(g,t)}
        float ${s}(int row, int col, int depth) {
          return ${s}(${Cl(m,u)});
        }
      `}if(e.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${a}, ${o}, 1)));
        ${kl(e)}
      }
    `;let l=e.shapeInfo.texShape,p=l[0],d=l[1],h=e.shapeInfo.flatOffset;if(d===a&&h==null)return t?`
      float ${s}(int row, int col, int depth) {
        int stride1 = ${r}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
        float ${s}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${o}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${d}.0, ${p}.0);
          return sampleTexture(${r}, uv);
        }
      `;if(d===o&&h==null)return t?`
      float ${s}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${s}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}.0, ${p}.0);
      return sampleTexture(${r}, uv);
    }
  `;let f=tu(r);return t?`
    float ${s}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${r}Shape[1] * ${r}Shape[2];
      int stride1 = ${r}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${f};
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
      return sampleTexture(${r}, uv);
    }
    `:`
      float ${s}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${a} + col * ${o} + depth + ${f};
        vec2 uv = uvFromFlat(${p}, ${d}, index);
        return sampleTexture(${r}, uv);
      }
  `}function uJ(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=$n();if(t)return`
    vec4 ${r}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${n}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${s.texture2D}(${n}, uv);
    }
  `;let a=e.shapeInfo.logicalShape,o=a.length,i=e.shapeInfo.texShape,u=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)],c=u[0],l=u[1],p=Math.ceil(a[o-1]/2),d=p*Math.ceil(a[o-2]/2),h="int b, int row, int col",f=`b * ${d} + (row / 2) * ${p} + (col / 2)`;for(let g=2;g<o-1;g++)h=`int b${g}, `+h,d*=a[o-g-1],f=`b${g} * ${d} + `+f;return`
    vec4 ${r}(${h}) {
      int index = ${f};
      int texR = index / ${l};
      int texC = index - texR * ${l};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${l}, ${c});
      return ${s.texture2D}(${n}, uv);
    }
  `}function cJ(e,t){let n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=n[3],o=n[2]*a,i=n[1]*o,{newShape:u,keptDims:c}=w.squeezeShape(n);if(u.length<n.length){let v=Sl(e,u),y=["row","col","depth","depth2"];return`
      ${Il(v,t)}
      float ${s}(int row, int col, int depth, int depth2) {
        return ${s}(${Cl(y,c)});
      }
    `}if(e.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${i}, ${o}, ${a}, 1)));
        ${kl(e)}
      }
    `;let l=e.shapeInfo.flatOffset,p=e.shapeInfo.texShape,d=p[0],h=p[1],f=`int stride2 = ${r}Shape[3];`,g=`int stride1 = ${r}Shape[2] * stride2;`,m=`int stride0 = ${r}Shape[1] * stride1;`;if(h===i&&l==null)return t?`
      float ${s}(int row, int col, int depth, int depth2) {
        ${f}
        ${g}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${o}, ${a}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${h}.0, ${d}.0);
        return sampleTexture(${r}, uv);
      }
    `;if(h===a&&l==null)return t?`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${n[1]*n[2]}, ${n[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${h}.0, ${d}.0);
        return sampleTexture(${r}, uv);
      }
    `;let b=tu(r);return t?`
    float ${s}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${f}
      ${g}
      ${m}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${b});
      return sampleTexture(${r}, uv);
    }
  `:`
    float ${s}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${i} + col * ${o} +
          depth * ${a} + depth2;
      vec2 uv = uvFromFlat(${d}, ${h}, index + ${b});
      return sampleTexture(${r}, uv);
    }
  `}function lJ(e){let t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=t[4],a=t[3]*s,o=t[2]*a,i=t[1]*o,{newShape:u,keptDims:c}=w.squeezeShape(t);if(u.length<t.length){let g=Sl(e,u),m=["row","col","depth","depth2","depth3"];return`
      ${Il(g)}
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        return ${r}(${Cl(m,c)});
      }
    `}if(e.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${i}, ${o}, ${a}, ${s})) +
          depth3;
        ${kl(e)}
      }
    `;let l=e.shapeInfo.flatOffset,p=e.shapeInfo.texShape,d=p[0],h=p[1];if(h===i&&l==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${o}, ${a}, ${s}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${h}.0, ${d}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(h===s&&l==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]},
               ${t[2]*t[3]}, ${t[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${h}.0, ${d}.0);
        return sampleTexture(${n}, uv);
      }
    `;let f=tu(n);return`
    float ${r}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${i} + col * ${o} + depth * ${a} +
          depth2 * ${s} + depth3 + ${f};
      vec2 uv = uvFromFlat(${d}, ${h}, index);
      return sampleTexture(${n}, uv);
    }
  `}function dJ(e){let t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:s,keptDims:a}=w.squeezeShape(t);if(s.length<t.length){let m=Sl(e,s),b=["row","col","depth","depth2","depth3","depth4"];return`
      ${Il(m)}
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${r}(${Cl(b,a)});
      }
    `}let o=t[5],i=t[4]*o,u=t[3]*i,c=t[2]*u,l=t[1]*c;if(e.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${l}, ${c}, ${u}, ${i})) +
          dot(
            vec2(depth3, depth4),
            vec2(${o}, 1)));
        ${kl(e)}
      }
    `;let p=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,h=d[0],f=d[1];if(f===l&&p==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${c}, ${u}, ${i}, ${o})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${h}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(f===o&&p==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]*t[4]},
               ${t[2]*t[3]*t[4]},
               ${t[3]*t[4]},
               ${t[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${h}.0);
        return sampleTexture(${n}, uv);
      }
    `;let g=tu(n);return`
    float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${l} + col * ${c} + depth * ${u} +
          depth2 * ${i} + depth3 * ${o} + depth4 + ${g};
      vec2 uv = uvFromFlat(${h}, ${f}, index);
      return sampleTexture(${n}, uv);
    }
  `}function kl(e){let t=e.name,n=w.sizeFromShape(e.shapeInfo.logicalShape);return n<2?`return ${t};`:`
    for (int i = 0; i < ${n}; i++) {
      if (i == index) {
        return ${t}[i];
      }
    }
  `}function pJ(e,t){let n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),s="get"+r+"AtOutCoords",a=e.shapeInfo.logicalShape.length,o=t.logicalShape.length,i=tA(e.shapeInfo.logicalShape,t.logicalShape),u=pt(o),c=o-a,l,p=["x","y","z","w","u","v"];a===0?l="":o<2&&i.length>=1?l="coords = 0;":l=i.map(v=>`coords.${p[v+c]} = 0;`).join(`
`);let d="";o<2&&a>0?d="coords":d=e.shapeInfo.logicalShape.map((v,y)=>`coords.${p[y+c]}`).join(", ");let h="return outputValue;",g=w.sizeFromShape(e.shapeInfo.logicalShape)===1,b=w.sizeFromShape(t.logicalShape)===1;if(a===1&&!g&&!b)h=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(g&&!b)o===1?h=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:h=`
        return vec4(outputValue.x);
      `;else if(i.length){let v=a-2,y=a-1;i.indexOf(v)>-1&&i.indexOf(y)>-1?h="return vec4(outputValue.x);":i.indexOf(v)>-1?h="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":i.indexOf(y)>-1&&(h="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${s}() {
      ${u} coords = getOutputCoords();
      ${l}
      vec4 outputValue = get${r}(${d});
      ${h}
    }
  `}function hJ(e,t){let n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),s="get"+r+"AtOutCoords",a=t.texShape,o=e.shapeInfo.texShape,i=e.shapeInfo.logicalShape.length,u=t.logicalShape.length;if(!e.shapeInfo.isUniform&&i===u&&e.shapeInfo.flatOffset==null&&w.arraysEqual(o,a))return`
      float ${s}() {
        return sampleTexture(${n}, resultUV);
      }
    `;let c=pt(u),l=tA(e.shapeInfo.logicalShape,t.logicalShape),p=u-i,d,h=["x","y","z","w","u","v"];i===0?d="":u<2&&l.length>=1?d="coords = 0;":d=l.map(g=>`coords.${h[g+p]} = 0;`).join(`
`);let f="";return u<2&&i>0?f="coords":f=e.shapeInfo.logicalShape.map((g,m)=>`coords.${h[m+p]}`).join(", "),`
    float ${s}() {
      ${c} coords = getOutputCoords();
      ${d}
      return get${r}(${f});
    }
  `}function pt(e){if(e<=1)return"int";if(e===2)return"ivec2";if(e===3)return"ivec3";if(e===4)return"ivec4";if(e===5)return"ivec5";if(e===6)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function r0(e,t,n){let{newShape:r,keptDims:s}=w.squeezeShape(t),a=t.length,o=e&&a===3&&t[0]===1,i=o?t.slice(1):r,u=!e&&a>1&&!w.arraysEqual(t,n)&&r.length<a||o;return{useSqueezeShape:u,uniformShape:u?i:t,keptDims:s}}function Sl(e,t){let n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function Cl(e,t){return t.map(n=>e[n]).join(", ")}function fJ(e,t,n,r){let s=n.map((l,p)=>{let d={logicalShape:l.shape,texShape:l.isUniform?null:l.texData.texShape,isUniform:l.isUniform,isPacked:l.isUniform?!1:l.texData.isPacked,flatOffset:null};return l.texData!=null&&l.texData.slice!=null&&l.texData.slice.flatOffset>0&&(d.flatOffset=l.texData.slice.flatOffset),{name:t.variableNames[p],shapeInfo:d}}),a=s.map(l=>l.shapeInfo),o={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},i=$Z(s,o,t),u=FE(e.gl,i),c=e.createProgram(u);return G().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:u,source:i,webGLProgram:c,inShapeInfos:a,outShapeInfo:o,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(e.buildVao(c),Object.assign({program:t,fragmentShader:u,source:i,webGLProgram:c,inShapeInfos:a,outShapeInfo:o},sA(e,t,c)))}function sA(e,t,n){let r=[],s=[],a,o,i,u=null,c=null;c=e.getUniformLocation(n,"NAN",!1),G().getNumber("WEBGL_VERSION")===1&&(u=e.getUniformLocation(n,"INFINITY",!1));let l=!1;for(let p of t.variableNames){let d={name:p,uniform:e.getUniformLocation(n,p,l),offset:e.getUniformLocation(n,`offset${p}`,l)};t.enableShapeUniforms&&(d.shape=e.getUniformLocation(n,`${p}Shape`,l),d.texShape=e.getUniformLocation(n,`${p}TexShape`,l)),r.push(d)}if(t.enableShapeUniforms&&(a=e.getUniformLocation(n,"outShape",l),i=e.getUniformLocation(n,"outShapeStrides",l),o=e.getUniformLocation(n,"outTexShape",l)),t.customUniforms)for(let p of t.customUniforms)s.push(e.getUniformLocation(n,p.name,l));return{variablesLocations:r,customUniformLocations:s,infLoc:u,nanLoc:c,outShapeLocation:a,outShapeStridesLocation:i,outTexShapeLocation:o}}function y1(e,t){if(e.length!==t.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);e.forEach((n,r)=>{let s=n.logicalShape,a=t[r],o=a.shape;if(!w.arraysEqual(s,o))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${s} and ${o} must match`);if(n.isUniform&&a.isUniform)return;let i=n.texShape,u=a.isUniform?null:a.texData.texShape;if(!w.arraysEqual(i,u))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${i} and ${u} must match`)})}function mJ(e,t,n,r,s){t.program.enableShapeUniforms||(y1(t.inShapeInfos,n),y1([t.outShapeInfo],[r]));let a=r.texData.texture,o=r.texData.texShape;r.texData.isPacked?e.setOutputPackedMatrixTexture(a.texture,o[0],o[1]):e.setOutputMatrixTexture(a.texture,o[0],o[1]),e.setProgram(t.webGLProgram),e.bindVertexArray(t.webGLProgram.vao),G().getNumber("WEBGL_VERSION")===1&&t.infLoc!==null&&e.gl.uniform1f(t.infLoc,1/0),t.nanLoc!==null&&e.gl.uniform1f(t.nanLoc,NaN);for(let u=0;u<n.length;++u){let c=n[u],{uniform:l,offset:p,shape:d,texShape:h}=t.variablesLocations[u];if(d){let{uniformShape:f}=r0(t.program.packedInputs,c.shape,c.texData.texShape);switch(f.length){case 1:e.gl.uniform1iv(d,new Int32Array(f));break;case 2:e.gl.uniform2iv(d,new Int32Array(f));break;case 3:e.gl.uniform3iv(d,new Int32Array(f));break;case 4:e.gl.uniform4iv(d,new Int32Array(f));break;default:break}}if(h&&e.gl.uniform2i(h,c.texData.texShape[0],c.texData.texShape[1]),l!=null){if(c.isUniform){if(w.sizeFromShape(c.shape)<2)e.gl.uniform1f(l,c.uniformValues[0]);else{let f=c.uniformValues;f instanceof Float32Array||(f=new Float32Array(f)),e.gl.uniform1fv(l,f)}continue}c.texData.slice!=null&&p!=null&&e.gl.uniform1i(p,c.texData.slice.flatOffset),e.setInputMatrixTexture(c.texData.texture.texture,l,u)}}let i=t.outShapeLocation;if(i)switch(r.shape.length){case 1:e.gl.uniform1iv(i,new Int32Array(r.shape));break;case 2:e.gl.uniform2iv(i,new Int32Array(r.shape));break;case 3:e.gl.uniform3iv(i,new Int32Array(r.shape));break;case 4:e.gl.uniform4iv(i,new Int32Array(r.shape));break;default:break}if(t.outShapeStridesLocation){let u=w.computeStrides(r.shape);switch(r.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(u));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(u));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(u));break;default:break}}if(t.outTexShapeLocation&&e.gl.uniform2i(t.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),t.program.customUniforms&&s)for(let u=0;u<t.program.customUniforms.length;++u){let c=t.program.customUniforms[u],l=t.customUniformLocations[u],p=s[u];if(c.type==="float")e.gl.uniform1fv(l,p);else if(c.type==="vec2")e.gl.uniform2fv(l,p);else if(c.type==="vec3")e.gl.uniform3fv(l,p);else if(c.type==="vec4")e.gl.uniform4fv(l,p);else if(c.type==="int")e.gl.uniform1iv(l,p);else if(c.type==="ivec2")e.gl.uniform2iv(l,p);else if(c.type==="ivec3")e.gl.uniform3iv(l,p);else if(c.type==="ivec4")e.gl.uniform4iv(l,p);else throw Error(`uniform type ${c.type} is not supported yet.`)}e.executeProgram()}function gJ(e,t,n){let r="";t.concat(n).forEach(o=>{let i=o.texData!=null&&o.texData.slice!=null&&o.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!o.isUniform){let u=o.texData.texShape,{useSqueezeShape:c,uniformShape:l,keptDims:p}=r0(e.packedInputs,o.shape,u),d="",h="",f="";if(l.length===1&&e.packedInputs){let k=[Math.ceil(u[0]/2),Math.ceil(u[1]/2)];d=`${k[0]>1}_${k[1]>1}`}else if(l.length===2&&!e.packedInputs)h=`${l[0]>1}_${l[1]>1}`;else if(l.length>2&&!e.packedInputs){let k=w.computeStrides(l);f=`${k[0]===u[1]}_${k[k.length-1]===u[1]}`}let g=o.shape.length,m=l.length===2&&w.arraysEqual(o.shape,u),b=w.sizeFromShape(o.shape)===1,v=T.getBroadcastDims(o.shape,n.shape),y=!e.packedInputs&&g===n.shape.length&&w.arraysEqual(u,n.texData.texShape),x=e.packedInputs||l.length>2?"":`${u[0]>1}_${u[1]>1}`;r+=`${g}_${y}_${c?p:""}_${l.length}_${b}_${v}_${m}_${d}_${h}_${f}_${x}_${i}`}else{let u=o.isUniform?"uniform":o.texData.texShape;r+=`${o.shape}_${u}_${i}`}});let s=e.userCode,a=e.constructor.name;return a+="_"+r+"_"+s+`${G().getNumber("WEBGL_VERSION")}`,a}function wn(e){return G().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}var bJ=class{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=Dd.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let t=$n();this.outputShape=e,this.enableShapeUniforms=wn(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?tg(["r","c","d"],e):eu(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${t.output} = result;
      }
    `}},yJ=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=Dd.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let t=$n();this.outputShape=e,this.enableShapeUniforms=wn(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?tg(["r","c","d"],e):eu(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${t.output} = result;
      }
    `}},vJ=class{constructor(e){this.variableNames=["A"],this.outTexUsage=dr.DOWNLOAD;let t=$n();this.outputShape=e,this.userCode=`
      ${eA}

      void main() {
        float x = getAAtOutCoords();
        ${t.output} = encode_float(x);
      }
    `}},xJ=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=dr.DOWNLOAD;let t=$n();this.outputShape=e,this.userCode=`
      ${eA}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${t.output} = encode_float(x);
      }
    `}},wJ={R:0,G:1,B:2,A:3},v1=class{constructor(e,t=!1,n="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];let r=$n();this.outputShape=e,this.enableShapeUniforms=wn(this.outputShape.length);let s="result";t&&(s="floor(result * 255. + 0.5)");let a="";for(let o=0;o<n.length;o++){let i=n[o];a+=`
          if(offset == ${o}) {
            result = values[${wJ[i]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?n0():t0(e)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${n.length});

        flatIndex = idiv(flatIndex, ${n.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${r.texture2D}(A, uv);
          ${a}
        }
        ${r.output} = vec4(${s}, 0., 0., 0.);
      }
    `}},IJ=class{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];let n=$n();this.outputShape=e,this.enableShapeUniforms=wn(this.outputShape.length);let r="",s="result";t&&(s="floor(result * 255. + 0.5)");for(let a=0;a<=1;a++)for(let o=0;o<=1;o++){let i=a*2+o;r+=`
          localCoords = coords;
          if(localCoords[2] + ${o} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {
          localCoords[2] += ${o};
          if (localCoords[1] + ${a} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {
            localCoords[1] += ${a};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${n.texture2D}(A, uv);

            if (offset == 0) {
              result[${i}] = values[0];
            } else if (offset == 1) {
              result[${i}] = values[1];
            } else if (offset == 2) {
              result[${i}] = values[2];
            } else {
              result[${i}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?n0():t0(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${r}

          ${n.output} = ${s};
        }
    `}},aA={};Ee(aA,{bindVertexProgramAttributeStreams:()=>fA,createBufferFromOutputTexture:()=>bA,createFloat16MatrixTexture:()=>lA,createFloat16PackedMatrixTexture:()=>hA,createFloat32MatrixTexture:()=>cA,createIndexBuffer:()=>uA,createPackedMatrixTexture:()=>pA,createUnsignedBytesMatrixTexture:()=>dA,createVertexBuffer:()=>iA,createVertexShader:()=>oA,downloadByteEncodedFloatMatrixFromOutputTexture:()=>vA,downloadFloat32MatrixFromBuffer:()=>yA,downloadMatrixFromPackedOutputTexture:()=>wA,downloadPackedMatrixFromBuffer:()=>xA,getInternalFormatForFloat16MatrixTexture:()=>a0,getInternalFormatForFloat16PackedMatrixTexture:()=>u0,getInternalFormatForFloat32MatrixTexture:()=>s0,getInternalFormatForPackedMatrixTexture:()=>i0,getInternalFormatForUnsignedBytesMatrixTexture:()=>o0,uploadDenseMatrixToTexture:()=>mA,uploadPixelDataToTexture:()=>gA});function oA(e){let t=$n(),n=`${t.version}
    precision highp float;
    ${t.attribute} vec3 clipSpacePos;
    ${t.attribute} vec2 uv;
    ${t.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return $E(e,n)}function iA(e){let t=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return OE(e,t)}function uA(e){let t=new Uint16Array([0,1,2,2,1,3]);return ME(e,t)}function Lp(e,t,n,r,s,a){zE(t,n);let o=LE(e),i=e.TEXTURE_2D;return he(e,()=>e.bindTexture(i,o)),he(e,()=>e.texParameteri(i,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE)),he(e,()=>e.texParameteri(i,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE)),he(e,()=>e.texParameteri(i,e.TEXTURE_MIN_FILTER,e.NEAREST)),he(e,()=>e.texParameteri(i,e.TEXTURE_MAG_FILTER,e.NEAREST)),G().getNumber("WEBGL_VERSION")===1?he(e,()=>e.texImage2D(i,0,r,t,n,0,s,a,null)):he(e,()=>e.texStorage2D(i,1,r,t,n)),he(e,()=>e.bindTexture(e.TEXTURE_2D,null)),{texture:o,texShape:[n,t]}}function s0(e){return e.internalFormatFloat}function cA(e,t,n,r){let[s,a]=Mp(t,n);return Lp(e,s,a,s0(r),r.textureFormatFloat,e.FLOAT)}function a0(e){return e.internalFormatHalfFloat}function lA(e,t,n,r){let[s,a]=Mp(t,n);return Lp(e,s,a,a0(r),r.textureFormatFloat,r.textureTypeHalfFloat)}function o0(e){return e.downloadTextureFormat}function dA(e,t,n,r){let[s,a]=Mp(t,n);return Lp(e,s,a,o0(r),e.RGBA,e.UNSIGNED_BYTE)}function i0(e){return e.internalFormatPackedFloat}function pA(e,t,n,r){let[s,a]=xl(t,n);return Lp(e,s,a,i0(r),e.RGBA,e.FLOAT)}function u0(e){return e.internalFormatPackedHalfFloat}function hA(e,t,n,r){let[s,a]=xl(t,n);return Lp(e,s,a,u0(r),e.RGBA,r.textureTypeHalfFloat)}function fA(e,t,n){return he(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),fx(e,t,"clipSpacePos",n,3,20,0)&&fx(e,t,"uv",n,2,20,12)}function mA(e,t,n,r,s,a){he(e,()=>e.bindTexture(e.TEXTURE_2D,t));let o,i,u;s instanceof Uint8Array?(o=new Uint8Array(n*r*4),i=e.UNSIGNED_BYTE,u=e.RGBA):(o=new Float32Array(n*r*4),i=e.FLOAT,u=a.internalFormatPackedFloat),o.set(s),G().getNumber("WEBGL_VERSION")===2?he(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n,r,e.RGBA,i,o)):he(e,()=>e.texImage2D(e.TEXTURE_2D,0,u,n,r,0,e.RGBA,i,o)),he(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function gA(e,t,n){he(e,()=>e.bindTexture(e.TEXTURE_2D,t)),n.data instanceof Uint8Array?G().getNumber("WEBGL_VERSION")===2?he(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n.width,n.height,e.RGBA,e.UNSIGNED_BYTE,n.data)):he(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data)):G().getNumber("WEBGL_VERSION")===2?he(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,e.RGBA,e.UNSIGNED_BYTE,n)):he(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n)),he(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function bA(e,t,n,r){let s=e.createBuffer();he(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,s));let i=4*4*t*n;return he(e,()=>e.bufferData(e.PIXEL_PACK_BUFFER,i,e.STREAM_READ)),he(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0)),he(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null)),s}function yA(e,t,n){let r=e,s=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,t),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,s),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),s}function vA(e,t,n,r){let[s,a]=Mp(t,n),o=4,i=new Uint8Array(yZ(t*n,o));return he(e,()=>e.readPixels(0,0,s,a,r.downloadTextureFormat,e.UNSIGNED_BYTE,i)),new Float32Array(i.buffer)}function xA(e,t,n,r,s,a,o,i){let u=e,c=new Float32Array(vZ(a,o));return u.bindBuffer(u.PIXEL_PACK_BUFFER,t),u.getBufferSubData(u.PIXEL_PACK_BUFFER,0,c),u.bindBuffer(u.PIXEL_PACK_BUFFER,null),c}function wA(e,t,n){let r=new Float32Array(t*n*4);return he(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,r)),r}var sf=class{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];let t=G().getNumber("WEBGL_VERSION");if(e!=null?(this.gl=e,EE(t,e)):this.gl=Xr(t),e=this.gl,G().getNumber("WEBGL_VERSION")===2){let s=e;this.createVertexArray=()=>he(s,()=>s.createVertexArray()),this.bindVertexArray=a=>he(s,()=>s.bindVertexArray(a)),this.deleteVertexArray=a=>he(s,()=>s.deleteVertexArray(a)),this.getVertexArray=()=>he(s,()=>s.getParameter(s.VERTEX_ARRAY_BINDING))}else if(e!=null){let s=e.getExtension("OES_vertex_array_object");if(s==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>he(e,()=>s.createVertexArrayOES()),this.bindVertexArray=a=>he(e,()=>s.bindVertexArrayOES(a)),this.deleteVertexArray=a=>he(e,()=>s.deleteVertexArrayOES(a)),this.getVertexArray=()=>he(e,()=>e.getParameter(s.VERTEX_ARRAY_BINDING_OES))}let n="WEBGL_color_buffer_float",r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),G().getNumber("WEBGL_VERSION")===1){let s="OES_texture_float",a="OES_texture_half_float";if(this.textureFloatExtension=cd(this.gl,s),pr(this.gl,a))this.textureHalfFloatExtension=cd(this.gl,a);else if(G().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),pr(this.gl,r))this.colorBufferHalfFloatExtension=cd(this.gl,r);else if(G().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",pr(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else if(pr(this.gl,r))this.colorBufferHalfFloatExtension=this.gl.getExtension(r);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=iA(this.gl),this.indexBuffer=uA(this.gl),this.framebuffer=BE(this.gl),this.textureConfig=Qk(this.gl,this.textureHalfFloatExtension)}get debug(){return G().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");let e=this.gl;he(e,()=>e.finish()),he(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),he(e,()=>e.deleteFramebuffer(this.framebuffer)),he(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),he(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),he(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),cA(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),lA(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),dA(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),gA(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,r){this.throwIfDisposed(),mA(this.gl,e,t,n,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),hA(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),pA(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(mx(this.gl,this.framebuffer),this.outputTexture=null),he(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,()=>vA(this.gl,t,n,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,n,r,s,a){return xA(this.gl,e,t,n,r,s,a,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return yA(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);let r=bA(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){let e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if(G().getBool("WEBGL_FENCE_API_ENABLED")){let r=e,s=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{let a=r.clientWaitSync(s,0,0);return a===r.ALREADY_SIGNALED||a===r.CONDITION_SATISFIED},t=s}else G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,()=>wA(this.gl,t,n))}createProgram(e){this.throwIfDisposed();let t=this.gl;this.vertexShader==null&&(this.vertexShader=oA(t));let n=RE(t);he(t,()=>t.attachShader(n,this.vertexShader)),he(t,()=>t.attachShader(n,e)),PE(t,n);let r=Object.assign(n,{vao:this.createVertexArray()});return this.debug&&ef(t,r),r}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);let t=this.gl;he(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),fA(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&(he(this.gl,()=>this.gl.deleteProgram(e)),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&this.debug&&ef(this.gl,this.program),he(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,n=!0){return this.throwIfDisposed(),n?VE(this.gl,e,t):UE(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),he(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),GE(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();let[r,s]=xl(t,n);this.setOutputMatrixTextureDriver(e,r,s)}setOutputMatrixWriteRegion(e,t,n,r){this.setOutputMatrixWriteRegionDriver(n,e,r,t)}setOutputPackedMatrixWriteRegion(e,t,n,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&ef(this.gl,this.program),ld(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();let e=this.gl;if(this.debug){let t=this.getVertexArray();console.assert(t===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}he(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),he(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=cd(this.gl,G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let n=this.gl,r=this.getQueryTimerExtensionWebGL2(),s=n.createQuery();return n.beginQuery(r.TIME_ELAPSED_EXT,s),s}let e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let t=this.gl,n=this.getQueryTimerExtensionWebGL2();t.endQuery(n.TIME_ELAPSED_EXT);return}let e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await w.repeatedTry(()=>this.disposed||this.isQueryAvailable(e,G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(t===0)return null;if(t===2){let n=this.gl;return n.getQueryParameter(e,n.QUERY_RESULT)/1e6}else{let n=this.getQueryTimerExtensionWebGL1();return n.getQueryObjectEXT(e,n.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(t===0)return!0;if(t===2){let n=this.gl,r=this.getQueryTimerExtensionWebGL2(),s=n.getQueryParameter(e,n.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),s&&!this.disjoint}else{let n=this.getQueryTimerExtensionWebGL1(),r=n.getQueryObjectEXT(e,n.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),r&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){let e=kJ(this.itemsToPoll.map(t=>t.isDoneFn));for(let t=0;t<=e;++t){let{resolveFn:n}=this.itemsToPoll[t];n()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let n;"setTimeoutCustom"in G().platform&&(n=G().platform.setTimeoutCustom.bind(G().platform)),w.repeatedTry(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,n)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),tf(this.gl,e,this.framebuffer),this.debug&&ld(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(tf(this.gl,this.outputTexture,this.framebuffer),this.debug&&ld(this.gl)):mx(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);let n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();let r=this.gl;tf(r,e,this.framebuffer),this.debug&&ld(r),this.outputTexture=e,he(r,()=>r.viewport(0,0,t,n)),he(r,()=>r.scissor(0,0,t,n))}setOutputMatrixWriteRegionDriver(e,t,n,r){this.throwIfDisposed(),he(this.gl,()=>this.gl.scissor(e,t,n,r))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}};function kJ(e){let t=0;for(;t<e.length&&e[t]();++t);return t-1}var{addImpl:SJ,bincountImpl:IA,bincountReduceImpl:CJ,bitwiseAndImpl:TJ,castImpl:NJ,ceilImpl:_J,concatImpl:EJ,equalImpl:AJ,expImpl:DJ,expm1Impl:$J,floorImpl:FJ,gatherNdImpl:RJ,gatherV2Impl:PJ,greaterImpl:OJ,greaterEqualImpl:MJ,lessImpl:LJ,lessEqualImpl:zJ,linSpaceImpl:BJ,logImpl:WJ,maxImpl:VJ,maximumImpl:UJ,minimumImpl:GJ,multiplyImpl:HJ,negImpl:jJ,notEqualImpl:qJ,prodImpl:KJ,raggedGatherImpl:XJ,raggedRangeImpl:YJ,raggedTensorToTensorImpl:ZJ,rangeImpl:JJ,rsqrtImpl:QJ,scatterImpl:eQ,sigmoidImpl:tQ,simpleAbsImpl:kA,sliceImpl:nQ,sparseFillEmptyRowsImpl:rQ,sparseReshapeImpl:sQ,sparseSegmentReductionImpl:SA,sqrtImpl:aQ,staticRegexReplaceImpl:oQ,stridedSliceImpl:iQ,stringNGramsImpl:uQ,stringSplitImpl:cQ,stringToHashBucketFastImpl:lQ,subImpl:dQ,tileImpl:pQ,topKImpl:hQ,transposeImpl:c0,uniqueImpl:fQ}=Mk;function CA(e,t){return["x","y","z","w","u","v"].slice(0,t).map(n=>`${e}.${n}`)}function Nn(e,t){return t===1?[e]:CA(e,t)}function mQ(e,t){if(e===1)return"rc";let n="";for(let r=0;r<e;r++)n+=t[r],r<e-1&&(n+=",");return n}var gQ=class{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=wn(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{let t=Nn("rc",this.rank),n=pt(this.rank),r=this.getOutOfBoundsCondition(t),s=this.getSetup(t),a=this.getOutput(t);this.userCode=`
        void main() {
          ${n} rc = getOutputCoords();

          if(${r}) {
            setOutput(vec4(0));
          } else {
            ${s}

            setOutput(vec4(${a}));
          }
        }
      `}}getSourceCoordsArr(e){let t=[];for(let n=0;n<=1;n++)for(let r=0;r<=1;r++){let s=`${n===0?"r":"rp1"}, ${r===0?"c":"cp1"}`;for(let a=2;a<this.rank;a++)s=`${e[e.length-1-a]},`+s;t.push(s)}return t}getOutOfBoundsCondition(e){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let n=this.rank-2;n<this.rank;n++)t+=`${e[n]} >= ${this.enableShapeUniforms?`outShape[${n}]`:this.outputShape[n]}`,n<this.rank-1&&(t+="||");return t}getSetup(e){if(this.rank===1)return"";let t=e.slice(-2),n=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],r=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${t[0]};
      int c = ${t[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${n};
      bool rEdge = rp1 >= ${r};
    `}getOutput(e){let t=this.getSourceCoordsArr(e);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${t[0]}),
            cEdge ? 0. : getA(${t[1]}),
            rEdge ? 0. : getA(${t[2]}),
            rEdge || cEdge ? 0. : getA(${t[3]})`}},TA=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=wn(this.outputShape.length);let n="";for(let r=0;r<4;r++){let s="thisRC = rc;";r%2===1&&(s+="thisRC.z += 1;"),r>1&&(s+="thisRC.y += 1;"),n+=`
        ${s}
        ${r>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${r}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${r>0?"}":""}
      `}this.userCode=`
      ${bQ(t,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?n0():t0(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};

        ${n}

        setOutput(result);
      }
    `}};function bQ(e,t){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${t?DZ(["r","c","d"],"inputShape"):eu(["r","c","d"],e)}
      return ivec3(r, c, d);
    }
  `}var yQ=class{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,n){let r=w1(t,n),s=I1(e,r,n);s in this.freeTextures||(this.freeTextures[s]=[]),s in this.usedTextures||(this.usedTextures[s]=[]);let a=x1(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[s].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=a,this.log();let i=this.freeTextures[s].pop();return this.usedTextures[s].push(i),i}let o;return r===hn.PACKED_2X2_FLOAT32?o=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===hn.PACKED_2X2_FLOAT16?o=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===hn.UNPACKED_FLOAT32?o=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===hn.UNPACKED_FLOAT16?o=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===hn.PACKED_4X1_UNSIGNED_BYTE&&(o=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[s].push(o),this.numUsedTextures++,this._numBytesAllocated+=a,this.log(),o}releaseTexture(e,t,n,r){if(this.freeTextures==null)return;let s=w1(n,r),a=I1(t,s,r);a in this.freeTextures||(this.freeTextures[a]=[]);let o=x1(t,s,this.gpgpu.gl,this.gpgpu.textureConfig,r),i=G().get("WEBGL_DELETE_TEXTURE_THRESHOLD");i!==-1&&this._numBytesAllocated>i?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=o):(this.freeTextures[a].push(e),this.numFreeTextures++,this._numBytesFree+=o),this.numUsedTextures--;let u=this.usedTextures[a],c=u&&u.indexOf(e);if(c==null||c<0)throw new Error("Cannot release a texture that was never provided by this texture manager");u[c]=u[u.length-1],u.pop(),this.log()}log(){if(!this.logEnabled)return;let e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);let t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(let e in this.freeTextures)this.freeTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});for(let e in this.usedTextures)this.usedTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}};function vQ(e,t){let n=e;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F)return 16;if(t===e.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}function x1(e,t,n,r,s){let a=xQ(t,r),o;if(s){let[u,c]=xl(e[0],e[1]);o=u*c}else{let[u,c]=Mp(e[0],e[1]);o=u*c}let i=vQ(n,a);return o*i}function xQ(e,t){switch(e){case hn.PACKED_2X2_FLOAT32:return i0(t);case hn.PACKED_2X2_FLOAT16:return u0(t);case hn.UNPACKED_FLOAT32:return s0(t);case hn.UNPACKED_FLOAT16:return a0(t);case hn.PACKED_4X1_UNSIGNED_BYTE:return o0(t);default:throw new Error(`Unknown physical texture type ${e}`)}}function wQ(e){return G().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?hn.PACKED_2X2_FLOAT32:hn.UNPACKED_FLOAT32:e?hn.PACKED_2X2_FLOAT16:hn.UNPACKED_FLOAT16}function w1(e,t){if(e===dr.UPLOAD)return hn.PACKED_2X2_FLOAT32;if(e===dr.RENDER||e==null)return wQ(t);if(e===dr.DOWNLOAD||e===dr.PIXELS)return hn.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${e}`)}function I1(e,t,n){return`${e[0]}_${e[1]}_${t}_${n}`}var is=class{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=wn(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${t}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}},Lr="if (isnan(x)) return x;",IQ="return x;",k1="return abs(x);",kQ="return (x >= 0.0) ? x : (exp(x) - 1.0);",SQ=Lr+`
  return (x < 0.0) ? 0.0 : x;
`,CQ=Lr+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,ra="return x;",TQ="return 1.0 / (1.0 + exp(-1.0 * x));",NQ="return x;",_Q=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,EQ=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,AQ=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,DQ="return 1.0 / (1.0 + exp(-1.0 * x));",ua=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=wn(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${t}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}},$Q=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=wn(this.outputShape.length);let t=e.length,n=Nn("rc",t),r=pt(t),s=mQ(t,n),a=n.slice(-2),o=t<=1?"rc":`vec2(${a.join(",")})`;this.userCode=`
      void main() {
        ${r} rc = getOutputCoords();
        vec4 packedInput = getA(${s});

        setOutput(getChannel(packedInput, ${o}));
      }
    `}},FQ=bs.whereImpl,RQ=1e-7,PQ=1e-4,Xh={};function OQ(e){return e in Xh||(Xh[e]={}),Xh[e]}var MQ=G().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),LQ=600;function zQ(){return G().global.screen==null?1024:G().global.screen.height*G().global.screen.width*window.devicePixelRatio*LQ/1024/1024}var ng=class extends Md{nextDataId(){return ng.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!G().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(e!=null){if(e instanceof sf)t=e;else{let n=Xr(G().getNumber("WEBGL_VERSION"),e);t=new sf(n)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{let n=Xr(G().getNumber("WEBGL_VERSION"));t=new sf(n),this.binaryCache=OQ(G().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new yQ(this.gpgpu),this.numMBBeforeWarning=zQ(),this.texData=new Mf(this,Dr())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,t,n,r,s,a){let o=this.makeTensorInfo(t,n),i=this.texData.get(o.dataId);i.isPacked=!1,i.texture={texture:e,texShape:[r,s]},i.texShape=[r,s];let u=dd(t),c=new v1(u,!1,a),l=this.runWebGLProgram(c,[o],n,[[r,s]]);return l.shape=t,i.texture=null,this.disposeIntermediateTensorInfo(o),l.dataId}write(e,t,n){if((G().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||G().getBool("DEBUG"))&&this.checkNumericalProblems(e),n==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");let r={id:this.nextDataId()};return this.texData.set(r,{shape:t,dtype:n,values:e,usage:dr.UPLOAD,refCount:1}),r}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){let t=this.texData.get(e);t.refCount++}decRef(e){if(this.texData.has(e)){let t=this.texData.get(e);t.refCount--}}move(e,t,n,r,s){if(G().getBool("DEBUG")&&this.checkNumericalProblems(t),r==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:n,dtype:r,values:t,usage:dr.UPLOAD,refCount:s})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){let t=this.texData.get(e),{values:n,dtype:r,complexTensorInfos:s,slice:a,shape:o,isPacked:i}=t;if(a!=null){let p;i?p=new ua(o,ra):p=new is(o,ra);let d=this.runWebGLProgram(p,[{dataId:e,shape:o,dtype:r}],r),h=this.readSync(d.dataId);return this.disposeIntermediateTensorInfo(d),h}if(n!=null)return this.convertAndCacheOnCPU(e);if(r==="string")return n;let u=this.activeTimers!=null,c;u&&(c=w.now());let l;if(r==="complex64"){let p=this.readSync(s.real.dataId),d=this.readSync(s.imag.dataId);l=T.mergeRealAndImagArrays(p,d)}else l=this.getValuesFromTexture(e);return u&&(this.downloadWaitMs+=w.now()-c),this.convertAndCacheOnCPU(e,l)}async read(e){if(this.pendingRead.has(e)){let h=this.pendingRead.get(e);return new Promise(f=>h.push(f))}let t=this.texData.get(e),{values:n,shape:r,slice:s,dtype:a,complexTensorInfos:o,isPacked:i}=t;if(s!=null){let h;i?h=new ua(r,ra):h=new is(r,ra);let f=this.runWebGLProgram(h,[{dataId:e,shape:r,dtype:a}],a),g=this.read(f.dataId);return this.disposeIntermediateTensorInfo(f),g}if(n!=null)return this.convertAndCacheOnCPU(e);if(G().getBool("DEBUG")&&!G().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&G().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let u=null,c;if(a!=="complex64"&&G().get("WEBGL_BUFFER_SUPPORTED")){c=this.decode(e);let h=this.texData.get(c.dataId);u=this.gpgpu.createBufferFromTexture(h.texture.texture,...qh(r))}this.pendingRead.set(e,[]),a!=="complex64"&&await this.gpgpu.createAndWaitForFence();let l;if(a==="complex64"){let h=await Promise.all([this.read(o.real.dataId),this.read(o.imag.dataId)]),f=h[0],g=h[1];l=T.mergeRealAndImagArrays(f,g)}else if(u==null)l=this.getValuesFromTexture(e);else{let h=w.sizeFromShape(r);l=this.gpgpu.downloadFloat32MatrixFromBuffer(u,h)}if(c!=null&&this.disposeIntermediateTensorInfo(c),u!=null){let h=this.gpgpu.gl;he(h,()=>h.deleteBuffer(u))}let p=this.convertAndCacheOnCPU(e,l),d=this.pendingRead.get(e);return this.pendingRead.delete(e),d.forEach(h=>h(p)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&Dr().removeDataId(e,this),this.pendingDeletes--),p}readToGPU(e,t={}){let n=this.texData.get(e),{values:r,shape:s,slice:a,dtype:o,isPacked:i,texture:u}=n;if(o==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(a!=null){let d;i?d=new ua(s,ra):d=new is(s,ra);let h=this.runWebGLProgram(d,[{dataId:e,shape:s,dtype:o}],o),f=this.readToGPU(h,t);return this.disposeIntermediateTensorInfo(h),f}if(u==null)throw r!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");let c=this.decode(e,t.customTexShape),l=Dr().makeTensorFromTensorInfo(c),p=this.texData.get(c.dataId);return Object.assign({tensorRef:l},p.texture)}bufferSync(e){let t=this.readSync(e.dataId);if(e.dtype==="string")try{let n=t.map(r=>w.decodeString(r));return ze(e.shape,e.dtype,n)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return ze(e.shape,e.dtype,t)}checkNumericalProblems(e){if(e!=null)for(let t=0;t<e.length;t++){let n=e[t];if(!AE(n))throw G().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${n} cannot be represented on this device.`)}}getValuesFromTexture(e){let{shape:t,dtype:n,isPacked:r}=this.texData.get(e),s=w.sizeFromShape(t);if(G().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){let p=this.decode(e),d=this.texData.get(p.dataId),h=this.gpgpu.downloadMatrixFromPackedTexture(d.texture.texture,...qh(t)).subarray(0,s);return this.disposeIntermediateTensorInfo(p),h}let a=G().getBool("WEBGL_PACK")&&r===!0,o=a?dd(t):t,i=a?new xJ(o):new vJ(o),u=this.runWebGLProgram(i,[{shape:o,dtype:n,dataId:e}],"float32"),c=this.texData.get(u.dataId),l=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(c.texture.texture,c.texShape[0],c.texShape[1]).subarray(0,s);return this.disposeIntermediateTensorInfo(u),l}timerAvailable(){return G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){let t=this.activeTimers,n=[],r=!1;this.programTimersStack==null?(this.programTimersStack=n,r=!0):this.activeTimers.push(n),this.activeTimers=n,e();let s=w.flatten(this.activeTimers.map(i=>i.query)).filter(i=>i!=null),a=w.flatten(this.activeTimers.map(i=>i.name)).filter(i=>i!=null);this.activeTimers=t,r&&(this.programTimersStack=null);let o={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){let i=await Promise.all(s);o.kernelMs=w.sum(i),o.getExtraProfileInfo=()=>i.map((u,c)=>({name:a[c],ms:u})).map(u=>`${u.name}: ${u.ms}`).join(", ")}else o.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,o})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:w.now(),endMs:null}}endTimer(e){return G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=w.now(),e)}async getQueryTime(e){if(G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);let t=e;return t.endMs-t.startMs}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);let{complexTensorInfos:n}=this.texData.get(e);return n!=null&&(this.disposeData(n.real.dataId,t),this.disposeData(n.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){let{texture:t,dtype:n,texShape:r,usage:s,isPacked:a,slice:o}=this.texData.get(e),i=o&&o.origDataId||e,u=this.dataRefCount.get(i);u>1?this.dataRefCount.set(i,u-1):(this.dataRefCount.delete(i),t!=null&&(this.numBytesInGPU-=this.computeBytes(r,n),this.textureManager.releaseTexture(t,r,s,a)));let c=this.texData.get(e);c.texture=null,c.texShape=null,c.isPacked=!1,c.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=MQ){return G().getBool("WEBGL_CPU_FORWARD")&&e.every(n=>this.texData.get(n.dataId).texture==null&&w.sizeFromShape(n.shape)<t)}getGPGPUContext(){return this.gpgpu}where(e){T.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");let t=e.dataSync();return FQ(e.shape,t)}packedUnaryOp(e,t,n){let r=new ua(e.shape,t),s=this.compileAndRun(r,[e],n);return Dr().makeTensorFromTensorInfo(s)}abs(e){if(this.shouldExecuteOnCPU([e])&&e.dtype!=="complex64"){let r=kA(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,r)}if(G().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,k1,e.dtype);let t=new is(e.shape,k1),n=this.compileAndRun(t,[e]);return Dr().makeTensorFromTensorInfo(n)}makeTensorInfo(e,t,n){let r;if(t==="string"&&n!=null&&n.length>0&&w.isString(n[0])){let s=n.map(a=>w.encodeString(a));r=this.write(s,e,t)}else r=this.write(n,e,t);return this.texData.get(r).usage=null,{dataId:r,shape:e,dtype:t}}makeOutput(e,t,n){return Dr().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,n),this)}unpackTensor(e){let t=new $Q(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){let t=new gQ(e.shape),n=!0;return this.runWebGLProgram(t,[e],e.dtype,null,n)}packedReshape(e,t){let n=[So(e.shape),...Co(e.shape)],r={dtype:e.dtype,shape:n,dataId:e.dataId},s=[So(t),...Co(t)],a=new TA(s,n),o=!0,i=[n],u=this.runWebGLProgram(a,[r],e.dtype,i,o);return{dataId:u.dataId,shape:t,dtype:u.dtype}}decode(e,t){let n=this.texData.get(e),{isPacked:r,shape:s,dtype:a}=n;if(t!=null){let p=w.sizeFromShape(s),d=t[0]*t[1]*4;w.assert(p<=d,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}let o=dd(s),i;r?i=new yJ(o):i=new bJ(o);let u=!0,c=[t??qh(o)],l=this.runWebGLProgram(i,[{shape:o,dtype:a,dataId:e}],a,c,u,t);return{dtype:a,shape:s,dataId:l.dataId}}runWebGLProgram(e,t,n,r,s=!1,a){let o=this.makeTensorInfo(e.outputShape,n),i=this.texData.get(o.dataId);if(e.packedOutput&&(i.isPacked=!0),e.outPackingScheme===Dd.DENSE){let m=a??qh(e.outputShape);i.texShape=m.map(b=>b*2)}if(e.outTexUsage!=null&&(i.usage=e.outTexUsage),w.sizeFromShape(o.shape)===0)return i.values=w.getTypedArrayFromDType(o.dtype,0),o;let u=[],c=t.map(m=>{if(m.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let b=this.texData.get(m.dataId);if(b.texture==null){if(!e.packedInputs&&w.sizeFromShape(m.shape)<=G().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:m.shape,texData:null,isUniform:!0,uniformValues:b.values};e.packedInputs&&(b.isPacked=!0,b.shape=m.shape)}if(this.uploadToGPU(m.dataId),!!b.isPacked!=!!e.packedInputs)m=b.isPacked?this.unpackTensor(m):this.packTensor(m),u.push(m),b=this.texData.get(m.dataId);else if(b.isPacked&&!$d(b.shape,m.shape)){let v=m,y=m.shape;m.shape=b.shape,m=this.packedReshape(m,y),u.push(m),b=this.texData.get(m.dataId),v.shape=y}return{shape:m.shape,texData:b,isUniform:!1}});this.uploadToGPU(o.dataId);let l={shape:o.shape,texData:i,isUniform:!1},p=gJ(e,c,l),d=this.getAndSaveBinary(p,()=>fJ(this.gpgpu,e,c,l)),h=this.activeTimers!=null,f;h&&(f=this.startTimer()),G().get("ENGINE_COMPILE_ONLY")||mJ(this.gpgpu,d,c,l,r),u.forEach(m=>this.disposeIntermediateTensorInfo(m)),h&&(f=this.endTimer(f),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(f)}));let g=G().get("WEBGL_FLUSH_THRESHOLD");if(g>0){let m=w.now();m-this.lastGlFlushTime>g&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=m)}if(!G().getBool("WEBGL_LAZILY_UNPACK")&&i.isPacked&&s===!1){let m=this.unpackTensor(o);return this.disposeIntermediateTensorInfo(o),m}return o}compileAndRun(e,t,n,r,s=!1){return n=n||t[0].dtype,this.runWebGLProgram(e,t,n,r,s)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(G().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram),delete this.binaryCache[t]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=O(()=>{if(!G().get("WEBGL_RENDER_FLOAT32_ENABLED")){let e=G().getBool("DEBUG");G().set("DEBUG",!1);let t=this.abs(xe(1e-8)).dataSync()[0];if(G().set("DEBUG",e),t>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?RQ:PQ}uploadToGPU(e){let t=this.texData.get(e),{shape:n,dtype:r,values:s,texture:a,usage:o,isPacked:i}=t;if(a!=null)return;let u=this.activeTimers!=null,c;u&&(c=w.now());let l=t.texShape;if(l==null&&(l=qE(n,i),t.texShape=l),s!=null){let p=dd(n),d,h=l[1],f=l[0],g=s instanceof Uint8Array||s instanceof Uint8ClampedArray;(i||!g)&&([h,f]=xl(l[0],l[1])),i?d=new IJ(p,g):d=new v1(p,g);let m=g?[f,h]:l,b=this.makeTensorInfo(m,r),v=this.texData.get(b.dataId);g?v.usage=dr.PIXELS:v.usage=dr.UPLOAD,v.texShape=m,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(b.dataId),h,f,s);let y=[[f,h]],x=!0,k=this.runWebGLProgram(d,[b],r,y,x),S=this.texData.get(k.dataId);t.texShape=S.texShape,t.isPacked=S.isPacked,t.usage=S.usage,G().get("ENGINE_COMPILE_ONLY")?this.disposeData(k.dataId):(t.texture=S.texture,t.values=null,this.texData.delete(k.dataId)),this.disposeIntermediateTensorInfo(b),u&&(this.uploadWaitMs+=w.now()-c)}else{let p=this.acquireTexture(l,o,r,i);t.texture=p}}convertAndCacheOnCPU(e,t){let n=this.texData.get(e),{dtype:r}=n;return t!=null&&(n.values=BQ(t,r)),n.values}acquireTexture(e,t,n,r){if(this.numBytesInGPU+=this.computeBytes(e,n),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){let s=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${s} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,r)}computeBytes(e,t){return e[0]*e[1]*w.bytesPerElement(t)}checkCompileCompletion(){for(let[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){let e=[];if(this.gpgpu.parallelCompilationExtension){for(let[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}else{for(let[,t]of Object.entries(this.binaryCache)){let n=new Promise(r=>{try{this.checkCompletion_(t),r(!0)}catch(s){throw s}});e.push(n)}return Promise.all(e)}}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await eI(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(e0(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(let e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);let{variablesLocations:t,customUniformLocations:n,infLoc:r,nanLoc:s,outShapeLocation:a,outShapeStridesLocation:o,outTexShapeLocation:i}=sA(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=t,e.customUniformLocations=n,e.infLoc=r,e.nanLoc=s,e.outShapeLocation=a,e.outShapeStridesLocation=o,e.outTexShapeLocation=i}}createTensorFromGPUData(e,t,n){e.channels=e.channels||"RGBA";let{texture:r,height:s,width:a,channels:o}=e,i=Dr().backend;if(!i.gpgpu.gl.isTexture(r))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");let u=i.writeTexture(r,t,n,s,a,o);return Dr().makeTensorFromDataId(u,t,n,i)}};ng.nextDataId=0;function BQ(e,t){if(t==="float32"||t==="complex64")return e;if(t==="int32"||t==="bool"){let n=t==="int32"?new Int32Array(e.length):new Uint8Array(e.length);for(let r=0;r<n.length;++r)n[r]=Math.round(e[r]);return n}else throw new Error(`Unknown dtype ${t}`)}var WQ="4.9.0";function NA(){G().set("WEBGL_FORCE_F16_TEXTURES",!0)}cp.isBrowser()&&tm("webgl",()=>new ng,2);var VQ={forceHalfFloat:NA},l0=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`,To=class{constructor(e,t,n){this.variableNames=["A","B"],this.outputShape=T.assertAndGetBroadcastShape(t,n),this.enableShapeUniforms=wn(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}},nu=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`,Tl=class{constructor(e,t,n,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=T.assertAndGetBroadcastShape(t,n);let s=this.outputShape.length;this.enableShapeUniforms=wn(s);let a="";if(r)if(s===0||w.sizeFromShape(this.outputShape)===1)a=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(a=`
          ${pt(s)} coords = getOutputCoords();
        `,s===1)this.enableShapeUniforms?a+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:a+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{let i=Nn("coords",s);this.enableShapeUniforms?a+=`
            bool nextRowOutOfBounds =
              (${i[s-2]} + 1) >= outShape[${s} - 2];
            bool nextColOutOfBounds =
              (${i[s-1]} + 1) >= outShape[${s} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:a+=`
            bool nextRowOutOfBounds =
              (${i[s-2]} + 1) >= ${this.outputShape[s-2]};
            bool nextColOutOfBounds =
              (${i[s-1]} + 1) >= ${this.outputShape[s-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${a}

        setOutput(result);
      }
    `}};function ar(e){let{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}var UQ={kernelName:si,backendName:"webgl",kernelFunc:ar};function Oa(e){let{inputs:t,backend:n}=e,{real:r,imag:s}=t,a=n.makeTensorInfo(r.shape,"complex64"),o=n.texData.get(a.dataId),i=ar({inputs:{x:r},backend:n}),u=ar({inputs:{x:s},backend:n});return o.complexTensorInfos={real:i,imag:u},a}var GQ={kernelName:Bf,backendName:"webgl",kernelFunc:Oa},_A="return (a < 0.) ? b * a : a;",EA=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function HQ(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{alpha:a}=r,o=n.makeTensorInfo([],"float32",w.createScalarValue(a,"float32")),i=G().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Tl(EA,s.shape,o.shape):new To(_A,s.shape,o.shape),u=n.runWebGLProgram(i,[s,o],"float32");return n.disposeIntermediateTensorInfo(o),u}var jQ={kernelName:ui,backendName:"webgl",kernelFunc:HQ},AA="return (a < 0.) ? b * a : a;",DA=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function qQ(e){let{inputs:t,backend:n}=e,{x:r,alpha:s}=t,a=G().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Tl(DA,r.shape,s.shape):new To(AA,r.shape,s.shape);return n.runWebGLProgram(a,[r,s],"float32")}var KQ={kernelName:Si,backendName:"webgl",kernelFunc:qQ},Nl="if (isnan(x)) return x;";function Ze({opSnippet:e,packedOpSnippet:t,cpuKernelImpl:n,dtype:r}){return({inputs:s,backend:a})=>{let{x:o}=s,i=a,u=r||o.dtype;if(i.shouldExecuteOnCPU([o])&&n!=null){let p=i.texData.get(o.dataId),d=n(p.values,u);return i.makeTensorInfo(o.shape,u,d)}let c=G().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&t!=null,l;return c?l=new ua(o.shape,t):l=new is(o.shape,e),i.runWebGLProgram(l,[o],u)}}function mn({opSnippet:e,packedOpSnippet:t,checkOutOfBounds:n=!1,supportsComplex:r=!1,cpuKernelImpl:s,dtype:a}){return({inputs:o,backend:i})=>{let{a:u,b:c}=o,l=i;if(r&&u.dtype==="complex64"){let f=l.texData.get(u.dataId),g=l.texData.get(c.dataId),[m,b]=[[f.complexTensorInfos.real,g.complexTensorInfos.real],[f.complexTensorInfos.imag,g.complexTensorInfos.imag]].map(y=>{let[x,k]=y,S={dataId:x.dataId,dtype:x.dtype,shape:u.shape},N={dataId:k.dataId,dtype:k.dtype,shape:c.shape},E=new To(e,u.shape,c.shape);return l.runWebGLProgram(E,[S,N],mr(x.dtype,k.dtype))}),v=Oa({inputs:{real:m,imag:b},backend:l});return l.disposeIntermediateTensorInfo(m),l.disposeIntermediateTensorInfo(b),v}let p=a||mr(u.dtype,c.dtype);if((u.dtype==="string"||c.dtype==="string"||l.shouldExecuteOnCPU([u,c]))&&s!=null){let f=l.texData.get(u.dataId).values,g=l.texData.get(c.dataId).values,m=u.dtype==="string"?T.fromUint8ToStringArray(f):f,b=u.dtype==="string"?T.fromUint8ToStringArray(g):g,[v,y]=s(u.shape,c.shape,m,b,p),x=l.makeTensorInfo(y,p),k=l.texData.get(x.dataId);return k.values=v,x}let d=G().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&t!=null,h;return d?h=new Tl(t,u.shape,c.shape,n):h=new To(e,u.shape,c.shape),l.runWebGLProgram(h,[u,c],p)}}function Fd(e,t=!1){if(e==="linear")return t?NQ:IQ;if(e==="relu")return t?EQ:SQ;if(e==="elu")return t?_Q:kQ;if(e==="relu6")return t?AQ:CQ;if(e==="prelu")return t?DA:AA;if(e==="leakyrelu")return t?EA:_A;if(e==="sigmoid")return t?DQ:TQ;throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)}var $A=class{constructor(e,t,n,r=!1,s=!1,a=!1,o=null,i=!1,u=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=wn(this.outputShape.length);let c=r?e[1]:e[2],l=Math.ceil(c/2),p=r?"i * 2, rc.y":"rc.y, i * 2",d=s?"rc.z, i * 2":"i * 2, rc.z",h=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],f=s?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"],g="",m="";o&&(i?g=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${o}
        }`:u?g=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${o}
        }`:g=`vec4 activation(vec4 x) {
          ${o}
        }`,m="result = activation(result);");let b=a?"result += getBiasAtOutCoords();":"";a&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),u&&this.variableNames.push("leakyreluAlpha");let v="rc.x",y="rc.x";e[0]<t[0]?v=`imod(rc.x, ${e[0]})`:t[0]<e[0]&&(y=`imod(rc.x, ${t[0]})`),this.userCode=`
      ${g}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${l}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${v};
        int batchB = ${y};
        for (int i = 0; i < ${l}; i++) {
          vec4 a = getMatrixA(batchA, ${p});
          vec4 b = getMatrixB(batchB, ${d});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${h[0]} * ${f[0]});
          result += (${h[1]} * ${f[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${b}

        ${m}

        setOutput(result);
      }
    `}},S1={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"},C1=class{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=T.assertAndGetBroadcastShape(t,n),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}},T1="return a * b;";function d0(e){let{inputs:t,backend:n}=e,{a:r,b:s}=t,a=T.upcastType(r.dtype,s.dtype);if(r.dtype==="complex64"){let i=n.texData.get(r.dataId),u=n.texData.get(s.dataId),c=new C1(S1.REAL,r.shape,s.shape),l=new C1(S1.IMAG,r.shape,s.shape),p=[{dataId:i.complexTensorInfos.real.dataId,dtype:i.complexTensorInfos.real.dtype,shape:r.shape},{dataId:i.complexTensorInfos.imag.dataId,dtype:i.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:u.complexTensorInfos.real.dataId,dtype:u.complexTensorInfos.real.dtype,shape:s.shape},{dataId:u.complexTensorInfos.imag.dataId,dtype:u.complexTensorInfos.imag.dtype,shape:s.shape}],d=n.runWebGLProgram(c,p,"float32"),h=n.runWebGLProgram(l,p,"float32"),f=Oa({inputs:{real:d,imag:h},backend:n});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),f}if(n.shouldExecuteOnCPU([r,s])){let i=n.texData.get(r.dataId),u=n.texData.get(s.dataId),[c,l]=HJ(r.shape,s.shape,i.values,u.values,a),p=n.makeTensorInfo(l,a),d=n.texData.get(p.dataId);return d.values=c,p}let o;return G().getBool("WEBGL_PACK_BINARY_OPERATIONS")?o=new Tl(T1,r.shape,s.shape):o=new To(T1,r.shape,s.shape),n.runWebGLProgram(o,[r,s],a)}var XQ={kernelName:xi,backendName:"webgl",kernelFunc:d0};function YQ(e,t,n){let r=[So(e.shape),...Co(e.shape)],s={dtype:e.dtype,shape:r,dataId:e.dataId},a=[So(t),...Co(t)],o=new TA(a,r),i=!0,u=[r],c=n.runWebGLProgram(o,[s],e.dtype,u,i);return{dataId:c.dataId,shape:t,dtype:c.dtype}}function pe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{shape:a}=r,o=n,i=w.sizeFromShape(s.shape),u=w.inferFromImplicitShape(a,i),c=w.sizeFromShape(u);w.assert(i===c,()=>`The new shape (${u}) has ${c} elements and the old shape (${s.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`);let l=o.texData.get(s.dataId);return l.isPacked&&!$d(s.shape,u)&&!(l.texture!==null&&$d(l.shape,u))?YQ(s,u,o):(o.incRef(s.dataId),{dataId:s.dataId,shape:u,dtype:s.dtype})}var ZQ={kernelName:qc,backendName:"webgl",kernelFunc:pe},N1=class{constructor(e,t){this.variableNames=["x"];let{windowSize:n,batchSize:r,inSize:s,outSize:a}=e;this.outputShape=[r,a];let o=Math.floor(n/4)*4,i=n%4,u="sumValue += dot(values, ones);";if(t!=null){let l=1/t;u=`sumValue += dot(values * ${w.isInt(l)?l.toPrecision(2):l}, ones);`}let c="";s%n>0&&(c=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${c}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        float sumValue = 0.0;

        for (int i = 0; i < ${o}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${u}
        }

        int inIdx = inOffset + ${o};
        if (${i===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${u}
        } else if (${i===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${u}
        } else if (${i===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${u}
        }
        setOutput(sumValue);
      }
    `}},JQ=class{constructor(e,t){this.variableNames=["x"];let{windowSize:n,batchSize:r,inSize:s,outSize:a}=e;this.outputShape=[r,a];let o="0.0",i="";t==="prod"?o="1.0":t==="min"?(o="1.0 / 1e-20",i="min"):t==="max"&&(o="-1.0 / 1e-20",i="max");let u=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="sum"?u="sumValue":t==="prod"?u="prodValue":t==="all"?u="allValue":t==="any"&&(u="anyValue");let c=Math.floor(n/4)*4,l=n%4,p=`
      if (${t==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${t==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${i}(values, minMaxValue);
        if (${t==="min"} || ${t==="max"}) {
          minMaxValue = ${i}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,d="vec4";t==="all"?(o="1.0",p=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,d="bvec4"):t==="any"&&(o="0.0",p=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,d="bvec4");let h="";s%n>0&&(h=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${o};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${h}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        vec4 minMaxValue = vec4(${o});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${p}
        }

        int inIdx = inOffset + ${c};
        if (${l===1}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${p}
        } else if (${l===2}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${p}
        } else if (${l===3}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${p}
        }
        setOutput(${u});
      }
    `}};function QQ(e){let t=[];for(;t.length===0||t[t.length-1].outSize!==1;){let n=t.length?t[t.length-1].outSize:e[1],r=T.computeOptimalWindowSize(n);t.push({inSize:n,windowSize:r,outSize:Math.ceil(n/r)})}return t}function ru(e,t,n,r){let s=QQ(e.shape),a=e;for(let o=0;o<s.length;o++){let{inSize:i,windowSize:u,outSize:c}=s[o],l,p;n==="mean"?l=o===0?new N1({windowSize:u,inSize:i,batchSize:e.shape[0],outSize:c},i):new N1({windowSize:u,inSize:i,batchSize:e.shape[0],outSize:c}):l=new JQ({windowSize:u,inSize:i,batchSize:e.shape[0],outSize:c},n),p=a,a=r.runWebGLProgram(l,[a],t),p.dataId!==e.dataId&&r.disposeIntermediateTensorInfo(p)}return a}var eee=class{constructor(e,t){this.variableNames=["A"];let n=new Array(e.length);for(let a=0;a<n.length;a++)n[a]=e[t[a]];this.outputShape=n,this.rank=n.length;let r=pt(this.rank),s=tee(t);this.userCode=`
    void main() {
      ${r} resRC = getOutputCoords();
      setOutput(getA(${s}));
    }
    `}};function tee(e){let t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);let n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(t);for(let s=0;s<e.length;s++)r[e[s]]=n[s];return r.join()}var nee=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;let n=new Array(e.length);for(let c=0;c<n.length;c++)n[c]=e[t[c]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);let r=pt(this.rank),s=CA("rc",this.rank),a=new Array(this.rank);for(let c=0;c<t.length;c++)a[t[c]]=s[c];let o=`vec2(${a.slice(-2).join()})`,i=`++${s[this.rank-1]} < ${n[this.rank-1]}`,u=`getChannel(getA(${a.join()}), ${o})`;this.userCode=`
    void main() {
      ${r} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${u};
      if(${i}) {
        result[1] = ${u};
      }
      --${s[this.rank-1]};
      if(++${s[this.rank-2]} < ${n[this.rank-2]}) {
        result[2] = ${u};
        if(${i}) {
          result[3] = ${u};
        }
      }
      setOutput(result);
    }
    `}};function rg(e,t,n){let r=G().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new nee(e.shape,t):new eee(e.shape,t);return n.runWebGLProgram(r,[e],e.dtype)}function ree(e,t,n,r){let s=t,a=e.shape.length,o=w.parseAxisParam(s,e.shape),i=o,u=T.getAxesPermutation(i,a),c=u!=null,l=e;c&&(l=rg(e,u,r),i=T.getInnerMostAxes(i.length,a)),T.assertAxesAreInnerMostDims("sum",i,a);let[p,d]=T.computeOutAndReduceShapes(l.shape,i),h=p;n&&(h=T.expandShapeToKeepDim(p,o));let f=w.sizeFromShape(d),m=w.sizeFromShape(e.shape)/f,b=pe({inputs:{x:l},attrs:{shape:[m,f]},backend:r}),v=em(e.dtype),y=ru(b,v,"sum",r),x=pe({inputs:{x:y},attrs:{shape:h},backend:r});return r.disposeIntermediateTensorInfo(b),r.disposeIntermediateTensorInfo(y),c&&r.disposeIntermediateTensorInfo(l),x}function sg(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:o}=r;return ree(s,a,o,n)}var see={kernelName:Wi,backendName:"webgl",kernelFunc:sg};function _n(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{perm:a}=r,o=n,i=s.shape.length,u=new Array(i);for(let l=0;l<u.length;l++)u[l]=s.shape[a[l]];let c;if(o.shouldExecuteOnCPU([s])){let p=o.texData.get(s.dataId).values,d=c0(p,s.shape,s.dtype,a,u);c=o.makeTensorInfo(u,s.dtype);let h=o.texData.get(c.dataId);h.values=d}else c=rg(s,a,o);return c}var aee={kernelName:$s,backendName:"webgl",kernelFunc:_n},FA=1e3;function $f({a:e,b:t,transposeA:n,transposeB:r,backend:s,bias:a=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:u=null}){let c=e.shape.length,l=t.shape.length,p=n?e.shape[c-2]:e.shape[c-1],d=r?t.shape[l-1]:t.shape[l-2],h=n?e.shape[c-1]:e.shape[c-2],f=r?t.shape[l-2]:t.shape[l-1],g=e.shape.slice(0,-2),m=t.shape.slice(0,-2),b=w.sizeFromShape(g),v=w.sizeFromShape(m),x=dl.assertAndGetBroadcastShape(e.shape.slice(0,-2),t.shape.slice(0,-2)).concat([h,f]);w.assert(p===d,()=>`Error in matMul: inner shapes (${p}) and (${d}) of Tensors with shapes ${e.shape} and ${t.shape} and transposeA=${n} and transposeB=${r} must match.`);let k=n?[b,p,h]:[b,h,p],S=r?[v,f,d]:[v,d,f],N=pe({inputs:{x:e},backend:s,attrs:{shape:k}}),E=pe({inputs:{x:t},backend:s,attrs:{shape:S}}),$=[N,E],R=Math.max(b,v),D=n?N.shape[1]:N.shape[2],F=a!=null,C=o!=null,L=u==="leakyrelu",U=u!=null?Fd(u,!0):null,H=F||C||L||U!=null,K;if((h===1||f===1)&&D>FA&&H===!1){let Z=N,J=E;n&&(Z=_n({inputs:{x:N},backend:s,attrs:{perm:[0,2,1]}}),$.push(Z)),r&&(J=_n({inputs:{x:E},backend:s,attrs:{perm:[0,2,1]}}),$.push(J));let ee=f!==1,se=f===1,te=Z;ee&&(te=pe({inputs:{x:Z},backend:s,attrs:{shape:[R,D,1]}}),$.push(te));let oe=f===1?2:1,ne=J;se&&(ne=pe({inputs:{x:J},backend:s,attrs:{shape:[R,1,D]}}),$.push(ne));let le=d0({inputs:{a:te,b:ne},backend:s});K=sg({inputs:{x:le},backend:s,attrs:{axis:oe,keepDims:!0}}),$.push(le)}else{let Z=mr(e.dtype,t.dtype),J=new $A(k,S,[R,h,f],n,r,F,U,C,L),ee=[N,E];if(a!=null&&ee.push(a),C&&ee.push(o),L){let se=s.makeTensorInfo([],"float32",w.createScalarValue(i,"float32"));ee.push(se),$.push(se)}K=s.runWebGLProgram(J,ee,Z)}let q=pe({inputs:{x:K},backend:s,attrs:{shape:x}});$.push(K);for(let Z of $)s.disposeIntermediateTensorInfo(Z);return q}function oee(e){let{inputs:t,backend:n,attrs:r}=e,{a:s,b:a,bias:o,preluActivationWeights:i}=t,{transposeA:u,transposeB:c,activation:l,leakyreluAlpha:p}=r;return $f({a:s,b:a,transposeA:u,transposeB:c,backend:n,bias:o,preluActivationWeights:i,leakyreluAlpha:p,activation:l})}var iee={kernelName:co,backendName:"webgl",kernelFunc:oee},_1="return abs(x);";function uee(e){let{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])&&r.dtype!=="complex64"){let a=n.texData.get(r.dataId),o=kA(a.values);return n.makeTensorInfo(r.shape,r.dtype,o)}let s;return G().getBool("WEBGL_PACK_UNARY_OPERATIONS")?s=new ua(r.shape,_1):s=new is(r.shape,_1),n.runWebGLProgram(s,[r],r.dtype)}var cee={kernelName:cc,backendName:"webgl",kernelFunc:uee},lee=Lr+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,dee=Ze({opSnippet:lee}),pee={kernelName:Eo,backendName:"webgl",kernelFunc:dee},hee=Lr+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,fee=Ze({opSnippet:hee}),mee={kernelName:Ao,backendName:"webgl",kernelFunc:fee},E1="return a + b;",gee=mn({opSnippet:E1,packedOpSnippet:E1,supportsComplex:!0,cpuKernelImpl:SJ}),bee={kernelName:Sa,backendName:"webgl",kernelFunc:gee},yee=class{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((s,a)=>`T${a}`);let n=[];this.variableNames.forEach(s=>{n.push(`float v${s} = get${s}AtOutCoords();`)});let r=this.variableNames.map(s=>`v${s}`).join(" + ");this.userCode=`
      void main() {
        ${n.join(`
        `)}

        float result = ${r};
        setOutput(result);
      }
    `}},vee=class{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((s,a)=>`T${a}`);let n=[];this.variableNames.forEach(s=>{n.push(`vec4 v${s} = get${s}AtOutCoords();`)});let r=this.variableNames.map(s=>`v${s}`).join(" + ");this.userCode=`
      void main() {
        ${n.join(`
        `)}

        vec4 result = ${r};
        setOutput(result);
      }
    `}};function af(e){let{inputs:t,backend:n}=e,r=t;if(r.length===1)return ar({inputs:{x:r[0]},backend:n});if(r.length>G().get("WEBGL_MAX_TEXTURES_IN_SHADER")){let u=Math.floor(r.length/2),c=af({inputs:r.slice(0,u),backend:n}),l=af({inputs:r.slice(u),backend:n});return af({inputs:[c,l],backend:n})}let s=r.map(u=>u.dtype).reduce((u,c)=>mr(u,c)),a=r.map(u=>u.shape),i=G().getBool("WEBGL_PACK")?new vee(r[0].shape,a):new yee(r[0].shape,a);return n.runWebGLProgram(i,r,s)}var xee={kernelName:Do,backendName:"webgl",kernelFunc:af};function wee(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:o}=r,i=s.shape.length,u=w.parseAxisParam(a,s.shape),c=u,l=T.getAxesPermutation(c,i),p=s;l!=null&&(p=_n({inputs:{x:s},backend:n,attrs:{perm:l}}),c=T.getInnerMostAxes(c.length,i)),T.assertAxesAreInnerMostDims("all",c,i);let[d,h]=T.computeOutAndReduceShapes(p.shape,c),f=w.sizeFromShape(h),g=pe({inputs:{x:p},backend:n,attrs:{shape:[-1,f]}}),m=ru(g,g.dtype,"all",n),b;if(o){let v=T.expandShapeToKeepDim(d,u);b=pe({inputs:{x:m},backend:n,attrs:{shape:v}})}else b=pe({inputs:{x:m},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(m),l!=null&&n.disposeIntermediateTensorInfo(p),b}var Iee={kernelName:lc,backendName:"webgl",kernelFunc:wee};function kee(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:o}=r,i=s.shape.length,u=w.parseAxisParam(a,s.shape),c=u,l=T.getAxesPermutation(c,i),p=s;l!=null&&(p=_n({inputs:{x:s},backend:n,attrs:{perm:l}}),c=T.getInnerMostAxes(c.length,i)),T.assertAxesAreInnerMostDims("any",c,i);let[d,h]=T.computeOutAndReduceShapes(p.shape,c),f=w.sizeFromShape(h),g=pe({inputs:{x:p},backend:n,attrs:{shape:[-1,f]}}),m=ru(g,g.dtype,"any",n),b;if(o){let v=T.expandShapeToKeepDim(d,u);b=pe({inputs:{x:m},backend:n,attrs:{shape:v}})}else b=pe({inputs:{x:m},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(m),l!=null&&n.disposeIntermediateTensorInfo(p),b}var See={kernelName:dc,backendName:"webgl",kernelFunc:kee},Cee=class{constructor(e,t,n){this.variableNames=["A"];let{windowSize:r,batchSize:s,outSize:a}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[s,a];let o=t==="max"?">":"<",i=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${r}; i++) {
          int inIdx = ${i};
          float candidate = getA(batch, inIdx);
          if (candidate ${o} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}},Tee=class{constructor(e,t,n,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,w.assert(e.length>2,()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`);let s=e[e.length-1],a=Math.ceil(s/t);this.outputShape=e.slice(0,-1),a>1&&this.outputShape.push(a),r||this.variableNames.push("bestIndicesA");let o=this.outputShape,i=o.length,u=pt(i),c=Nn("coords",i),l,p;if(a===1){p=i+1;let N=pt(p);l=`
        ${N} sourceLocR = ${N}(${c.join()}, 0);
        ++${c[i-1]};
        ${N} sourceLocG = ${N}(${c.join()}, 0);
        ++${c[i-2]};
        ${N} sourceLocA = ${N}(${c.join()}, 0);
        --${c[i-1]};
        ${N} sourceLocB = ${N}(${c.join()}, 0);
        --${c[i-2]};`}else p=i,l=`
        ${u} sourceLocR = coords;
        ++${c[i-1]};
        ${u} sourceLocG = coords;
        ++${c[i-2]};
        ${u} sourceLocA = coords;
        --${c[i-1]};
        ${u} sourceLocB = coords;
        --${c[i-2]};`;let d=["x","y","z","w","u","v"].slice(0,p),h="."+d[p-1],f=d.map(N=>"int "+N),g=Nn("sourceLocR",p-1).concat("inIdx.r"),m=Nn("sourceLocG",p-1).concat("inIdx.g"),b=Nn("sourceLocB",p-1).concat("inIdx.b"),v=Nn("sourceLocA",p-1).concat("inIdx.a"),y=n==="max"?"greaterThan":"lessThan",x=r?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${g.join()}),
                             getBestIndicesAChannel(${m.join()}),
                             getBestIndicesAChannel(${b.join()}),
                             getBestIndicesAChannel(${v.join()})));`,k=`vec4(
            getAChannel(${g.join()}),
            hasNextCol ? getAChannel(${m.join()}) : 0.,
            hasNextRow ? getAChannel(${b.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${v.join()}) : 0.)`,S=r?"":`
      float getBestIndicesAChannel(${f.join()}) {
        return getChannel(getBestIndicesA(${d.join()}),
                                          vec2(${d.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${f.join()}) {
        return getChannel(getA(${d.join()}),
                               vec2(${d.slice(-2).join()}));
      }
      ${S}
      void main() {
        ${u} coords = getOutputCoords();
        bool hasNextCol = ${c[i-1]} < ${o[i-1]-1};
        bool hasNextRow = ${c[i-2]} < ${o[i-2]-1};
        ${l}
        ivec4 srcIdx = ivec4(sourceLocR${h}, sourceLocG${h},
          sourceLocB${h}, sourceLocA${h}) * ${t};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${k};

        for (int i = 0; i < ${t}; i++) {
          inIdx = srcIdx;
          ${x}
          vec4 candidate = ${k};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${y}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}};function RA(e,t,n,r=null){let s=t.shape[0],a=t.shape[1];r!=null&&(s=r.shape[0],a=r.shape[1]);let o=T.computeOptimalWindowSize(a),i={windowSize:o,inSize:a,batchSize:s,outSize:Math.ceil(a/o)},u=new Cee(i,n,r==null),c=[t];r!=null&&c.push(r);let l=e.runWebGLProgram(u,c,"int32");if(l.shape[1]===1)return l;let p=RA(e,t,n,l);return e.disposeIntermediateTensorInfo(l),p}function PA(e,t,n,r=null){let s=r!=null?r.shape:t.shape,a=s[s.length-1],o=T.computeOptimalWindowSize(a),i=new Tee(s,o,n,r==null),u=r==null?[t]:[t,r],c=e.runWebGLProgram(i,u,"int32");if(c.shape.length===t.shape.length){let l=PA(e,t,n,c);return e.disposeIntermediateTensorInfo(c),l}return c}function OA(e,t,n,r){let s=[n];if(T.assertAxesAreInnerMostDims("arg"+r.charAt(0).toUpperCase()+r.slice(1),s,t.shape.length),!G().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){let a=[],o=e.texData.get(t.dataId),i=o!==null&&o.isPacked,u=t;i&&(u=e.unpackTensor(t),a.push(u));let[c,l]=T.computeOutAndReduceShapes(u.shape,s),p=w.sizeFromShape(l),d=pe({inputs:{x:u},backend:e,attrs:{shape:[-1,p]}});a.push(d);let h=RA(e,d,r);a.push(h);let f=pe({inputs:{x:h},backend:e,attrs:{shape:c}});return a.forEach(g=>e.disposeIntermediateTensorInfo(g)),f}return PA(e,t,r)}function Nee(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r,o=w.parseAxisParam(a,s.shape),i=T.getAxesPermutation(o,s.shape.length),u=s,c=[];i!=null&&(u=_n({inputs:{x:s},backend:n,attrs:{perm:i}}),c.push(u),o=T.getInnerMostAxes(o.length,u.shape.length)),T.assertAxesAreInnerMostDims("argMax",[o[0]],u.shape.length);let l=OA(n,u,o[0],"max");return c.forEach(p=>n.disposeIntermediateTensorInfo(p)),l}var _ee={kernelName:pc,backendName:"webgl",kernelFunc:Nee};function Eee(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r,o=w.parseAxisParam(a,s.shape),i=T.getAxesPermutation(o,s.shape.length),u=s,c=[];i!=null&&(u=_n({inputs:{x:s},backend:n,attrs:{perm:i}}),c.push(u),o=T.getInnerMostAxes(o.length,u.shape.length)),T.assertAxesAreInnerMostDims("argMin",[o[0]],u.shape.length);let l=OA(n,u,o[0],"min");return c.forEach(p=>n.disposeIntermediateTensorInfo(p)),l}var Aee={kernelName:hc,backendName:"webgl",kernelFunc:Eee},Dee=Lr+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,$ee=Ze({opSnippet:Dee}),Fee={kernelName:$o,backendName:"webgl",kernelFunc:$ee},Ree=Lr+"return log(x + sqrt(x * x + 1.0));",Pee=Ze({opSnippet:Ree}),Oee={kernelName:Fo,backendName:"webgl",kernelFunc:Pee},Mee=Lr+`
  return atan(x);
`,Lee=Ze({opSnippet:Mee}),zee={kernelName:Ro,backendName:"webgl",kernelFunc:Lee},Bee=l0+`
  return atan(a, b);
`,Wee=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+nu+`
  return result;
`,Vee=mn({opSnippet:Bee,packedOpSnippet:Wee}),Uee={kernelName:Oo,backendName:"webgl",kernelFunc:Vee},Gee=Lr+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,Hee=Ze({opSnippet:Gee}),jee={kernelName:Po,backendName:"webgl",kernelFunc:Hee},Rd=class{constructor(e,t,n,r=!1,s=!1){if(this.variableNames=["x"],t==="avg"&&n)throw new Error("Cannot compute positions for average pool.");let a=e.filterWidth,o=e.strideHeight,i=e.strideWidth,u=e.dilationHeight,c=e.dilationWidth,l=e.effectiveFilterHeight,p=e.effectiveFilterWidth,d=e.padInfo.top,h=e.padInfo.left;this.outputShape=e.outShape;let f=t==="avg",g=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,m=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`,b="0.0";if(f||(b="-1.0 / 1e-20"),n){let N=">=";this.userCode=`
        const ivec2 strides = ivec2(${o}, ${i});
        const ivec2 pads = ivec2(${d}, ${h});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${l};
              wR += ${u}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${p};
                wC += ${c}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${N} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${r?s?g:m:`wR * ${p} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let v="max",y=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(y="avgValue / max(count, 1.0)");let x=Math.floor(a/4)*4,k=a%4,S=`
      if (${f}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${v}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${o}, ${i});
      const ivec2 pads = ivec2(${d}, ${h});
      const float initializationValue = ${b};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${b});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${l};
            wR += ${u}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${x}; wC += 4) {
            int xC = xCCorner + wC * ${c};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              getValue(batch, xR, xC + 3 * ${c}, d)
            );

            ${S}
          }

          int xC = xCCorner + ${x};
          if (${k===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${S}
          } else if (${k===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              initializationValue,
              initializationValue
            );

            ${S}
          } else if (${k===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              initializationValue
            );

            ${S}
          }
        }
        setOutput(${y});
      }
    `}},p0=class{constructor(e,t,n,r=!1,s=!1){if(this.variableNames=["x"],t==="avg"&&n)throw new Error("Cannot compute positions for average pool.");let a=e.filterWidth,o=e.strideDepth,i=e.strideHeight,u=e.strideWidth,c=e.dilationDepth,l=e.dilationHeight,p=e.dilationWidth,d=e.effectiveFilterDepth,h=e.effectiveFilterHeight,f=e.effectiveFilterWidth,g=e.padInfo.front,m=e.padInfo.top,b=e.padInfo.left;this.outputShape=e.outShape;let v=t==="avg",y="0.0";if(v||(y="-1.0 / 1e-20"),n){let $=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${o}, ${i}, ${u});
        const ivec3 pads = ivec3(${g}, ${m}, ${b});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${d};
              wD += ${c}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${h};
                wR += ${l}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${f};
                  wC += ${p}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${$} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${r?s?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${h} * ${f} +
                      wR * ${f} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let x="max",k=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(k="avgValue / max(count, 1.0)");let S=Math.floor(a/4)*4,N=a%4,E=`
      if (${v}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${x}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${o}, ${i}, ${u});
      const ivec3 pads = ivec3(${g}, ${m}, ${b});
      const float initializationValue = ${y};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${y});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${d};
            wD += ${c}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${h};
            wR += ${l}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${S}; wC += 4) {
              int xC = xCCorner + wC * ${p};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${p}, ch),
                getValue(batch, xD, xR, xC + 2 * ${p}, ch),
                getValue(batch, xD, xR, xC + 3 * ${p}, ch)
              );

              ${E}
            }

            int xC = xCCorner + ${S};
            if (${N===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${E}
            } else if (${N===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${p}, ch),
                initializationValue,
                initializationValue
              );

              ${E}
            } else if (${N===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${p}, ch),
                getValue(batch, xD, xR, xC + 2 * ${p}, ch),
                initializationValue
              );

              ${E}
            }
          }
        }
        setOutput(${k});
      }
    `}};function qee(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t;wl(s,"avgPool");let{filterSize:a,strides:o,pad:i,dimRoundingMode:u}=r,c=1;w.assert(T.eitherStridesOrDilationsAreOne(o,c),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);let l=T.computePool2DInfo(s.shape,a,o,c,i,u);if(l.filterWidth===1&&l.filterHeight===1&&w.arraysEqual(l.inShape,l.outShape))return ar({inputs:{x:s},backend:n});let p=new Rd(l,"avg",!1);return n.runWebGLProgram(p,[s],"float32")}var Kee={kernelName:Mo,backendName:"webgl",kernelFunc:qee};function Xee(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:o,pad:i,dimRoundingMode:u,dataFormat:c}=r,l=[1,1,1],p=T.computePool3DInfo(s.shape,a,o,l,i,u,c),d=new p0(p,"avg",!1);return n.runWebGLProgram(d,[s],"float32")}var Yee={kernelName:fc,backendName:"webgl",kernelFunc:Xee},Zee=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,s=e.strideWidth,a=e.dilationHeight,o=e.dilationWidth,i=e.effectiveFilterHeight,u=e.effectiveFilterWidth,c=i-1-e.padInfo.top,l=u-1-e.padInfo.left,p=1/(t*n);this.userCode=`
      const ivec2 pads = ivec2(${c}, ${l});
      const float avgMultiplier = float(${p});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${i};
            wR += ${a}) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${u};
            wC+= ${o}) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}},Jee=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;let t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,s=e.strideDepth,a=e.strideHeight,o=e.strideWidth,i=e.dilationDepth,u=e.dilationHeight,c=e.dilationWidth,l=e.effectiveFilterDepth,p=e.effectiveFilterHeight,d=e.effectiveFilterWidth,h=l-1-e.padInfo.front,f=p-1-e.padInfo.top,g=d-1-e.padInfo.left,m=1/(t*n*r);this.userCode=`
      const ivec3 pads = ivec3(${h}, ${f}, ${g});
      const float avgMultiplier = float(${m});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${l};
            wD += ${i}) {
          float dyD = float(dyDCorner + wD) / ${s}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${p};
              wR += ${u}) {
            float dyR = float(dyRCorner + wR) / ${a}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${d};
                wC += ${c}) {
              float dyC = float(dyCCorner + wC) / ${o}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function Qee(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,o=a,{filterSize:i,strides:u,pad:c,dimRoundingMode:l}=r,p=[1,1,1],d=T.computePool3DInfo(o.shape,i,u,p,c,l),h=new Jee(d);return n.runWebGLProgram(h,[s],o.dtype)}var ete={kernelName:Bd,backendName:"webgl",kernelFunc:Qee};function tte(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,o=a;wl([s,a],"avgPoolGrad");let{filterSize:i,strides:u,pad:c}=r,l=T.computePool2DInfo(o.shape,i,u,1,c),p=new Zee(l);return n.runWebGLProgram(p,[s],o.dtype)}var nte={kernelName:zd,backendName:"webgl",kernelFunc:tte};function rte(e){let{inputs:t,backend:n,attrs:r}=e,{a:s,b:a}=t,{transposeA:o,transposeB:i}=r;return $f({a:s,b:a,transposeA:o,transposeB:i,backend:n})}var ste={kernelName:Lo,backendName:"webgl",kernelFunc:rte},ate=class{constructor(e,t,n,r,s,a){this.outputShape=[],this.variableNames=["x","mean","variance"],T.assertAndGetBroadcastShape(e,t),T.assertAndGetBroadcastShape(e,n);let o="0.0";r!=null&&(T.assertAndGetBroadcastShape(e,r),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let i="1.0";s!=null&&(T.assertAndGetBroadcastShape(e,s),this.variableNames.push("scale"),i="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${o};
        float scale = ${i};
        float inv = scale * inversesqrt(variance + float(${a}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}},ote=class{constructor(e,t,n,r,s,a){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],T.assertAndGetBroadcastShape(e,t),T.assertAndGetBroadcastShape(e,n);let o="vec4(0.0)";r!=null&&(T.assertAndGetBroadcastShape(e,r),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let i="vec4(1.0)";s!=null&&(T.assertAndGetBroadcastShape(e,s),this.variableNames.push("scale"),i="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${o};
        vec4 scale = ${i};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${a}));

        setOutput((x - mean) * inv + offset);
      }
    `}},ite=({inputs:e,backend:t,attrs:n})=>{let{x:r,mean:s,variance:a,offset:o,scale:i}=e;w.assert(s.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),w.assert(o==null||s.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),w.assert(i==null||s.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:u}=n;u==null&&(u=.001);let c=[r,s,a],l=null;o!=null&&(l=o.shape,c.push(o));let p=null;i!=null&&(p=i.shape,c.push(i));let d=G().getBool("WEBGL_PACK_NORMALIZATION")?new ote(r.shape,s.shape,a.shape,l,p,u):new ate(r.shape,s.shape,a.shape,l,p,u);return t.runWebGLProgram(d,c,c[0].dtype)},ute={kernelName:ni,backendName:"webgl",kernelFunc:ite},cte=class{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;let t=pt(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let n=lte(this.rank),r,s=e.map((a,o)=>`sourceLoc.${yx[o]} = start[${o}] + coords.${yx[o]};`);r=`
        ${t} sourceLoc;
        ${t} coords = getOutputCoords();
        ${s.join(`
`)}
      `,this.userCode=`
      void main() {
        ${r}
        setOutput(getSource(${n}));
      }
    `}},yx=["x","y","z","w","u","v"];function lte(e){if(e===1)return"sourceLoc";if(e<=6)return yx.slice(0,e).map(t=>"sourceLoc."+t).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}var dte=class{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let t=pt(this.rank),n=Nn("coords",this.rank),r=Nn("sourceLoc",this.rank),s=this.rank===1?"sourceLoc":`vec2(${r.slice(-2).join()})`,a=`getChannel(getSource(${r.join()}), ${s})`,o=`
      result.x = ${a};
      if (++${n[this.rank-1]} < ${e[this.rank-1]}) {
        ++${r[this.rank-1]};
        result.y = ${a};
        --${r[this.rank-1]};
      }
    `,i=this.rank===1?"":`
      --${n[this.rank-1]};
      if (++${n[this.rank-2]} < ${e[this.rank-2]}) {
        ++${r[this.rank-2]};
        result.z = ${a};
        if (++${n[this.rank-1]} < ${e[this.rank-1]}) {
          ++${r[this.rank-1]};
          result.w = ${a};
        }
      }
    `,u=this.rank<=4?`sourceLoc = coords +
            ${t}(${e.map((c,l)=>`start[${l}]`).join()});`:e.map((c,l)=>`${r[l]} = ${n[l]} + start[${l}];`).join(`
`);this.userCode=`
      void main() {
        ${t} coords = getOutputCoords();
        ${t} sourceLoc;
        ${u}
        vec4 result = vec4(0.);
        ${o}
        ${i}
        setOutput(result);
      }
    `}};function pte(e,t,n,r){let s=r.texData.get(e.dataId),a=r.makeTensorInfo(n,e.dtype),o=r.texData.get(a.dataId);Object.assign(o,s),o.refCount=1,o.shape=n,o.dtype=e.dtype;let i=Yt.computeFlatOffset(t,w.computeStrides(e.shape));s.slice&&(i+=s.slice.flatOffset),o.slice={flatOffset:i,origDataId:s.slice&&s.slice.origDataId||e.dataId};let u=r.dataRefCount.get(o.slice.origDataId)||1;return r.dataRefCount.set(o.slice.origDataId,u+1),a}function _l(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,size:o}=r,[i,u]=Yt.parseSliceParams(s,a,o);if(Yt.assertParamsValid(s,i,u),w.sizeFromShape(u)===0)return n.makeTensorInfo(u,s.dtype,[]);if(n.shouldExecuteOnCPU([s])||s.dtype==="string"){let p=n.texData.get(s.dataId),d=nQ(p.values,i,u,s.shape,s.dtype);return n.makeTensorInfo(u,s.dtype,d)}let{isPacked:c}=n.texData.get(s.dataId),l=Yt.isSliceContinous(s.shape,i,u);if(c||!l){let p=G().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new dte(u):new cte(u),d=[i];return n.runWebGLProgram(p,[s],s.dtype,d)}return n.uploadToGPU(s.dataId),pte(s,i,u,n)}var hte={kernelName:el,backendName:"webgl",kernelFunc:_l},fte=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,crops:o}=r;w.assert(s.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");let i=a.reduce((v,y)=>v*y),u=T.getReshaped(s.shape,a,i),c=T.getPermuted(u.length,a.length),l=T.getReshapedPermuted(s.shape,a,i),p=T.getSliceBeginCoords(o,a.length),d=T.getSliceSize(l,o,a.length),h=[],f=pe({inputs:{x:s},backend:n,attrs:{shape:u}}),g=_n({inputs:{x:f},backend:n,attrs:{perm:c}}),m=pe({inputs:{x:g},backend:n,attrs:{shape:l}}),b=_l({inputs:{x:m},backend:n,attrs:{begin:p,size:d}});return h.push(f),h.push(g),h.push(m),h.forEach(v=>n.disposeIntermediateTensorInfo(v)),b},mte={kernelName:mc,backendName:"webgl",kernelFunc:fte};function gte(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:o}=r,i=n.readSync(s.dataId),u=n.readSync(a.dataId),c=IA(i,u,a.dtype,a.shape,o);return n.makeTensorInfo([o],a.dtype,c)}var bte={kernelName:gc,backendName:"webgl",kernelFunc:gte},yte=`
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`,vte=`
  return float(int(a.r) & int(b.r));
`;function xte(e){let{inputs:t,backend:n}=e,{a:r,b:s}=t,a=G().getBool("WEBGL_PACK_BINARY_OPERATIONS"),o=G().getNumber("WEBGL_VERSION");if(n.shouldExecuteOnCPU([r,s])||o===1){let u=n.texData.get(r.dataId).values,c=n.texData.get(s.dataId).values,[l,p]=TJ(r.shape,s.shape,u,c,r.dtype),d=n.makeTensorInfo(p,r.dtype),h=n.texData.get(d.dataId);return h.values=l,d}let i;return a?i=new Tl(yte,r.shape,s.shape,!1):i=new To(vte,r.shape,s.shape),n.runWebGLProgram(i,[r,s],r.dtype)}var wte={kernelName:bc,backendName:"webgl",kernelFunc:xte};function Ite(e){let{inputs:t,backend:n}=e,{s0:r,s1:s}=t,a=n.readSync(r.dataId),o=n.readSync(s.dataId),i=T.assertAndGetBroadcastShape(Array.from(a),Array.from(o));return n.makeTensorInfo([i.length],"int32",Int32Array.from(i))}var kte={kernelName:Wd,backendName:"webgl",kernelFunc:Ite},Ste="return float(a != b);",MA=mn({opSnippet:Ste,cpuKernelImpl:qJ,dtype:"bool"}),Cte={kernelName:Wc,backendName:"webgl",kernelFunc:MA};function zp(e){let{inputs:t,backend:n}=e,{input:r}=t,s=n.texData.get(r.dataId);return ar({inputs:{x:s.complexTensorInfos.real},backend:n})}var Tte={kernelName:Jf,backendName:"webgl",kernelFunc:zp},Nte="return float(int(x));";function _te(e,t){let n=new is(e.shape,Nte),r=t.runWebGLProgram(n,[e],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}function vx(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dtype:a}=r;if(a==="complex64"){if(s.dtype==="complex64")return ar({inputs:{x:s},backend:n});let o=Ct(s.shape),i=vx({inputs:{x:s},backend:n,attrs:{dtype:"float32"}}),u=Oa({inputs:{real:i,imag:o},backend:n});return o.dispose(),n.disposeIntermediateTensorInfo(i),u}if(s.dtype==="complex64"){let o=zp({inputs:{input:s},backend:n}),i=vx({inputs:{x:o},backend:n,attrs:{dtype:a}});return n.disposeIntermediateTensorInfo(o),i}if(!w.hasEncodingLoss(s.dtype,a)){let o=ar({inputs:{x:s},backend:n});return{dataId:o.dataId,shape:o.shape,dtype:a}}if(n.shouldExecuteOnCPU([s])){let o=n.texData.get(s.dataId).values,[i,u,c]=NJ(o,s.shape,s.dtype,a);return n.makeTensorInfo(i,u,c)}if(a==="int32")return _te(s,n);if(a==="bool"){let o=n.makeTensorInfo([],"bool",w.getTypedArrayFromDType("bool",1)),u=MA({inputs:{a:s,b:o},backend:n});return n.disposeIntermediateTensorInfo(o),u}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${a}`)}var Ete={kernelName:zo,backendName:"webgl",kernelFunc:vx},A1="return ceil(x);",Ate=Ze({opSnippet:A1,packedOpSnippet:A1,cpuKernelImpl:_J}),Dte={kernelName:Bo,backendName:"webgl",kernelFunc:Ate},$te=class{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}},Fte=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}};function Rte(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{clipValueMin:a,clipValueMax:o}=r,i;G().getBool("WEBGL_PACK_CLIP")?i=new Fte(s.shape):i=new $te(s.shape);let u=[[a],[o]];return n.runWebGLProgram(i,[s],s.dtype,u)}var Pte={kernelName:Ca,backendName:"webgl",kernelFunc:Rte},Ote=class{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}};function D1(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}function Mte(e){let{inputs:t,backend:n}=e,{x:r}=t,s=n.texData.get(r.dataId),a=new Ote(r.shape),o=[D1(r,s.complexTensorInfos.real),D1(r,s.complexTensorInfos.imag)];return n.runWebGLProgram(a,o,o[0].dtype)}var Lte={kernelName:Vd,backendName:"webgl",kernelFunc:Mte},zte=class{constructor(e){this.outputShape=[],this.outputShape=T.computeOutShape(e,1),this.variableNames=e.map((a,o)=>`T${o}`);let t=new Array(e.length-1);t[0]=e[0][1];for(let a=1;a<t.length;a++)t[a]=t[a-1]+e[a][1];let n=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let a=1;a<t.length;a++){let o=t[a-1];n.push(`else if (yC < ${t[a]}) setOutput(getT${a}(yR, yC-${o}));`)}let r=t.length,s=t[t.length-1];n.push(`else setOutput(getT${r}(yR, yC-${s}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${n.join(`
        `)}
      }
    `}},Bte=class{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=T.computeOutShape(e,t);let n=this.outputShape,r=n.length,s=pt(r),a=Nn("coords",r),o=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map((f,g)=>`T${g}`);let i=new Array(e.length-1);i[0]=e[0][t];for(let f=1;f<i.length;f++)i[f]=i[f-1]+e[f][t];let u=o[t],c=o.slice(-2),l=o.join(),p=`if (${u} < ${i[0]}) {
        return getChannel(
            getT0(${l}), vec2(${c.join()}));
        }`;for(let f=1;f<i.length;f++){let g=i[f-1];p+=`
        if (${u} < ${i[f]}  && ${u} >= ${i[f-1]}) {
          return getChannel(
            getT${f}(${Yh(o,u,g)}),
            vec2(${Yh(c,u,g)}));
        }`}let d=i.length,h=i[i.length-1];p+=`
        return getChannel(
          getT${d}(${Yh(o,u,h)}),
          vec2(${Yh(c,u,h)}));`,this.userCode=`
      float getValue(${o.map(f=>"int "+f)}) {
        ${p}
      }

      void main() {
        ${s} coords = getOutputCoords();
        vec4 result = vec4(getValue(${a}), 0., 0., 0.);

        ${a[r-1]} = ${a[r-1]} + 1;
        if (${a[r-1]} < ${n[r-1]}) {
          result.g = getValue(${a});
        }

        ${a[r-2]} = ${a[r-2]} + 1;
        if (${a[r-2]} < ${n[r-2]}) {
          result.a = getValue(${a});
        }

        ${a[r-1]} = ${a[r-1]} - 1;
        if (${a[r-2]} < ${n[r-2]} &&
            ${a[r-1]} < ${n[r-1]}) {
          result.b = getValue(${a});
        }
        setOutput(result);
      }
    `}};function Yh(e,t,n){let r=e.indexOf(t);return e.map((a,o)=>o===r?`${a} - ${n}`:a).join()}function ag(e){let{inputs:t,backend:n}=e,{input:r}=t,s=n.texData.get(r.dataId);return ar({inputs:{x:s.complexTensorInfos.imag},backend:n})}var Wte={kernelName:Kf,backendName:"webgl",kernelFunc:ag};function pd(e,t,n){let r=e[0].dtype;if(r==="complex64"){let h=e.map(v=>zp({inputs:{input:v},backend:n})),f=e.map(v=>ag({inputs:{input:v},backend:n})),g=pd(h,t,n),m=pd(f,t,n),b=Oa({inputs:{real:g,imag:m},backend:n});return h.forEach(v=>n.disposeIntermediateTensorInfo(v)),f.forEach(v=>n.disposeIntermediateTensorInfo(v)),n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(m),b}let s=n.shouldExecuteOnCPU(e);if(r==="string"&&(s=!0),s){let h=e.map(x=>{let S=[-1,w.sizeFromShape(x.shape.slice(t))];return pe({inputs:{x},backend:n,attrs:{shape:S}})}),f=h.map(x=>({vals:n.readSync(x.dataId),shape:x.shape})),g=T.computeOutShape(h.map(x=>x.shape),1),m=h[0].shape[0]===1,b=EJ(f,g,r,m),v=T.computeOutShape(e.map(x=>x.shape),t),y=n.makeTensorInfo(v,r,b);return h.forEach(x=>n.disposeIntermediateTensorInfo(x)),y}let a=e.filter(h=>w.sizeFromShape(h.shape)>0),o=G().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&a[0].shape.length>1;if(a.length===1){let h=o?new is(e[0].shape,ra):new ua(e[0].shape,ra);return n.runWebGLProgram(h,e,r)}let i=G().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(a.length>i){let h=[];for(let g=0;g<a.length;g+=i){let m=a.slice(g,g+i);h.push(pd(m,t,n))}let f=pd(h,t,n);for(let g of h)n.disposeIntermediateTensorInfo(g);return f}if(o){let h=new Bte(a.map(f=>f.shape),t);return n.runWebGLProgram(h,a,r)}let{tensors2D:u,outShape:c}=Vte(a,t,n),l=new zte(u.map(h=>h.shape)),p=n.runWebGLProgram(l,u,r);u.forEach(h=>n.disposeIntermediateTensorInfo(h));let d=pe({inputs:{x:p},attrs:{shape:c},backend:n});return n.disposeIntermediateTensorInfo(p),d}function Vte(e,t,n){let r=T.computeOutShape(e.map(a=>a.shape),t);return{tensors2D:e.map(a=>pe({inputs:{x:a},attrs:{shape:[-1,w.sizeFromShape(a.shape.slice(t))]},backend:n})),outShape:r}}function LA(e){let{inputs:t,backend:n,attrs:r}=e,{axis:s}=r,a=w.parseAxisParam(s,t[0].shape)[0],o=t.map(c=>c.shape);T.assertParamsConsistent(o,a);let i=T.computeOutShape(t.map(c=>c.shape),a);if(w.sizeFromShape(i)===0)return n.makeTensorInfo(i,t[0].dtype,[]);let u=t.filter(c=>w.sizeFromShape(c.shape)>0);return u.length===1?ar({inputs:{x:u[0]},backend:n}):pd(u,a,n)}var Ute={kernelName:yc,backendName:"webgl",kernelFunc:LA},zA=class{constructor(e,t=!1,n=null,r=!1,s=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;let a=e.padInfo.top,o=e.padInfo.left,i=e.strideHeight,u=e.strideWidth,c=e.dilationHeight,l=e.dilationWidth,p=e.filterHeight,d=e.filterWidth,h=Math.floor(e.inChannels/4)*4,f=e.inChannels%4,g=e.dataFormat==="channelsLast",m=g?1:2,b=g?2:3,v=g?3:1,y="",x="";n&&(r?y=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:s?y=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:y=`
          float activation(float x) {
            ${n}
          }
        `,x="result = activation(result);");let k=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${y}

      const ivec2 strides = ivec2(${i}, ${u});
      const ivec2 pads = ivec2(${a}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${v}];

        ivec2 xRCCorner =
            ivec2(coords[${m}], coords[${b}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${p}; wR++) {
          int xR = xRCorner + wR * ${c};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${d}; wC++) {
            int xC = xCCorner + wC * ${l};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${h}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${g}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${f===1}) {

              if (${g}) {
                dotProd +=
                    getX(batch, xR, xC, ${h}) *
                    getW(wR, wC, ${h}, d2);
              } else {
                dotProd +=
                    getX(batch, ${h}, xR, xC) *
                    getW(wR, wC, ${h}, d2);
              }

            } else if (${f===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${h}, d2),
                getW(wR, wC, ${h} + 1, d2)
              );

              if (${g}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${h}),
                  getX(batch, xR, xC, ${h} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${h}, xR, xC),
                  getX(batch, ${h} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${f===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${h}, d2),
                getW(wR, wC, ${h} + 1, d2),
                getW(wR, wC, ${h} + 2, d2)
              );

              if (${g}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${h}),
                  getX(batch, xR, xC, ${h} + 1),
                  getX(batch, xR, xC, ${h} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${h}, xR, xC),
                  getX(batch, ${h} + 1, xR, xC),
                  getX(batch, ${h} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${k}
        ${x}
        setOutput(result);
      }
    `}},Gte=class{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;let t=e.padInfo.front,n=e.padInfo.top,r=e.padInfo.left,s=e.strideDepth,a=e.strideHeight,o=e.strideWidth,i=e.dilationDepth,u=e.dilationHeight,c=e.dilationWidth,l=e.filterDepth,p=e.filterHeight,d=e.filterWidth,h=Math.floor(e.inChannels/4)*4,f=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${s}, ${a}, ${o});
      const ivec3 pads = ivec3(${t}, ${n}, ${r});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${l}; wF++) {
          int xF = xFCorner + wF * ${i};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${p}; wR++) {
            int xR = xRCorner + wR * ${u};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${d}; wC++) {
              int xC = xCCorner + wC * ${c};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${h}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${f===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${h}) *
                  getW(wF, wR, wC, ${h}, d2);
              } else if (${f===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${h}),
                  getX(batch, xF, xR, xC, ${h} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${h}, d2),
                  getW(wF, wR, wC, ${h} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${f===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${h}),
                  getX(batch, xF, xR, xC, ${h} + 1),
                  getX(batch, xF, xR, xC, ${h} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${h}, d2),
                  getW(wF, wR, wC, ${h} + 1, d2),
                  getW(wF, wR, wC, ${h} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}},BA=class{constructor(e,t=!1,n=null,r=!1,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=wn(this.outputShape.length);let a=e.padInfo.left,o=e.strideWidth,i=e.dilationWidth,u=e.filterHeight,c=e.filterWidth,l=c,p=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let g=0;g<c;g++)p+=`
           vec4 xTexelC${g*2};
           int xTexelC${g*2}Ready;
           vec4 xTexelC${g*2+1};
           int xTexelC${g*2+1}Ready;
           vec4 xC${g};`;p+=`
     for (int r = 0; r < ${u}; r++) {
      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {
       `;for(let g=0;g<c;g++)p+=`
           xTexelC${g*2} = vec4(0.0);
           xTexelC${g*2}Ready = 0;
           xTexelC${g*2+1} = vec4(0.0);
           xTexelC${g*2+1}Ready = 0;
           xC${g} = vec4(0.0);`;p+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let g=0;g<(l+1)/2;g++){let m=g*2;if(p+=`
           xC = xCCorner + ${m*i};
           `,o===1){if(m<c&&(a%2===1?(p+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${m}Ready == 0) {
                   xTexelC${m} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${m}.zw = vec2(0.0);
                   }
                   xTexelC${m}Ready = 1;
                 }
               `,i===1&&m>0?p+=`
                 xC${m} = vec4(xTexelC${m-2}.zw, xTexelC${m}.xy);
                 `:p+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${m} = vec4(previous.zw, xTexelC${m}.xy);
                   } else {
                     xC${m} = vec4(0.0, 0.0, xTexelC${m}.xy);
                   }
                   `):p+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${m}Ready == 0) {
                   xTexelC${m} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${m}.zw = vec2(0.0);
                   }
                   xTexelC${m}Ready = 1;
                 }

                 xC${m} = xTexelC${m};
                 `,m+1<c)){let b=a%2===0?w.nearestLargerEven(i):i;i%2===0&&a%2===1||i%2!==0&&a%2!==1?(p+=`
                   xCOffset = xC + imod(pads[1], 2) + ${b};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${m+1}Ready == 0) {
                     xTexelC${m+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${m+1}.zw = vec2(0.0);
                     }
                     xTexelC${m+1}Ready = 1;
                   }
                   `,i>1?p+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${m+1} = vec4(previous.zw, xTexelC${m+1}.xy);
                     } else {
                      xC${m+1} = vec4(0.0, 0.0, xTexelC${m+1}.xy);
                     }
                     `:p+=`
                     xC${m+1} = vec4(xTexelC${m}.zw, xTexelC${m+1}.xy);
                     `):b===1?p+=`
                     xC${m+1} = xTexelC${m};
                     `:p+=`
                     xCOffset = xC + ${b};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${m+1}Ready == 0) {
                       xTexelC${m+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${m+1}.zw = vec2(0.0);
                       }
                       xTexelC${m+1}Ready = 1;
                     }

                     xC${m+1} = xTexelC${m+1};
                     `}}else m<c&&(a%2===1?(p+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${m}Ready == 0) {
                   xTexelC${m} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${m}.zw = vec2(0.0);
                   }
                   xTexelC${m}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${m+1}Ready == 0) {
                   xTexelC${m+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${m+1}.zw = vec2(0.0);
                   }
                   xTexelC${m+1}Ready = 1;
                 }

                 xC${m} = vec4(xTexelC${m}.zw, xTexelC${m+1}.zw);
               `,m+1<c&&(p+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${m+1} = vec4(xTexelC${m+1}.xy, final.xy);
                 `)):(p+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${m}Ready == 0) {
                   xTexelC${m} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${m}.zw = vec2(0.0);
                   }
                   xTexelC${m}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${m+1}Ready == 0) {
                   xTexelC${m+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${m+1}.zw = vec2(0.);
                   }
                   xTexelC${m+1}Ready = 1;
                 }

                 xC${m} = vec4(
                   xTexelC${m}.xy, xTexelC${m+1}.xy);
               `,m+1<c&&(p+=`
                   xC${m+1} = vec4(xTexelC${m}.zw, xTexelC${m+1}.zw);
                 `)));m<c&&(p+=`
             wTexel = getW(r, ${m}, d1, d2);
             dotProd += xC${m}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${e.inChannels}) {
               dotProd += xC${m}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,m+1<c&&(p+=`
               wTexel = getW(r, ${m+1}, d1, d2);
               dotProd += xC${m+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${e.inChannels}) {
                 dotProd += xC${m+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}p+=`
     }
   `,p+=`
     }
   `,p+=`
     }
   `;let d="",h="";n&&(r?d=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${n}
         }`:s?d=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${n}
         }`:d=`vec4 activation(vec4 x) {
           ${n}
         }`,h="result = activation(result);");let f=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${d}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${p}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${f}
         ${h}
         setOutput(result);
       }
     `}},Hte=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=wn(this.outputShape.length);let{dataFormat:n}=t,r=$n(),s=n==="channelsLast",a=s?1:2,o=s?2:3,i=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`,u="";for(let c=0;c<=1;c++)for(let l=0;l<=1;l++)u+=`
          blockIndex = rc.z + ${l};
          pos = rc.y + ${c};

          ${i}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${a}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${o}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${s}) {
                  innerDims = vec2(d1, ch);
                  result[${c*2+l}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${c*2+l}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${u}

        ${r.output} = result;
      }
    `}};function Ff(e,t){let n=e.length;return n>=3?t?[...e.slice(0,-3),e[n-3]*e[n-2],e[n-1]]:[...e.slice(0,-3),e[n-3],e[n-2]*e[n-1]]:!t&&n===1&&e[0]>1?[e[0],1]:null}function WA({x:e,filter:t,convInfo:n,backend:r,bias:s=null,preluActivationWeights:a=null,leakyreluAlpha:o=0,activation:i=null}){let u=e.shape,c=r.texData.get(e.dataId),l=n.inChannels,p=u[0]*u[1]*u[2],d=n.outChannels,h=n.dataFormat==="channelsLast",f=!1,g=!1,m,b=[];if(a!=null){let x=Ff(a.shape,h);x!=null&&(a=pe({inputs:{x:a},backend:r,attrs:{shape:x}}),b.push(a))}if(s!=null){let x=Ff(s.shape,h);x!=null&&(s=pe({inputs:{x:s},backend:r,attrs:{shape:x}}),b.push(s))}if(!((p===1||d===1)&&l>FA)&&c.isPacked&&h&&c.texture!=null&&u[2]%2!==0&&w.arraysEqual(c.shape.slice(-3),u.slice(-3))){let x=u[0]*u[1]*(u[2]+1),k={dataId:e.dataId,shape:[1,x,n.inChannels],dtype:e.dtype},S=c.shape;c.shape=c.shape.slice(),c.shape[c.shape.length-2]++,w.assert($d(c.shape,k.shape),()=>`packed reshape ${c.shape} to ${k.shape} isn't free`);let N=pe({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}});b.push(N);let E=$f({a:k,b:N,backend:r,transposeA:f,transposeB:g,bias:s,activation:i,preluActivationWeights:a,leakyreluAlpha:o}),$=r.texData.get(E.dataId);w.assert($.isPacked,()=>"batchMatMul result is expected to be packed"),c.shape=S,$.shape=n.outShape,m=ar({inputs:{x:E},backend:r}),m.shape=n.outShape,b.push(E)}else{let x=n.outHeight*n.outWidth,k=pe({inputs:{x:e},backend:r,attrs:{shape:h?[n.batchSize,x,n.inChannels]:[n.batchSize,n.inChannels,x]}}),S=pe({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}}),N=$f({a:h?k:S,b:h?S:k,transposeA:!h,transposeB:g,backend:r,bias:s,activation:i,preluActivationWeights:a,leakyreluAlpha:o});m=pe({inputs:{x:N},backend:r,attrs:{shape:n.outShape}}),b.push(k),b.push(S),b.push(N)}for(let x of b)r.disposeIntermediateTensorInfo(x);return m}function VA({x:e,filter:t,convInfo:n,backend:r,bias:s=null,preluActivationWeights:a=null,leakyreluAlpha:o=0,activation:i=null}){let{filterWidth:u,filterHeight:c,inChannels:l,outWidth:p,outHeight:d,dataFormat:h}=n,f=h==="channelsLast",g=u*c*l,m=d*p,b=[n.batchSize,g,m],v=!0,y=!1,x=[];if(a!=null){let q=Ff(a.shape,f);q!=null&&(a=pe({inputs:{x:a},backend:r,attrs:{shape:q}}),x.push(a))}if(s!=null){let q=Ff(s.shape,f);q!=null&&(s=pe({inputs:{x:s},backend:r,attrs:{shape:q}}),x.push(s))}let k=pe({inputs:{x:t},backend:r,attrs:{shape:[1,g,w.sizeFromShape(t.shape)/g]}});x.push(k);let S=new Hte(b,n),N=[e.shape,[n.padInfo.top,n.padInfo.left],[n.strideHeight,n.strideWidth],[n.dilationHeight,n.dilationWidth],[n.inChannels],[n.filterWidth*n.inChannels],[n.outWidth]],E=r.runWebGLProgram(S,[e],"float32",N),$=pe({inputs:{x:E},backend:r,attrs:{shape:b}});x.push(E),x.push($);let R=s!=null,D=a!=null,F=i==="leakyrelu",C=i?Fd(i,!0):null,L=new $A(f?$.shape:k.shape,f?k.shape:$.shape,f?[n.batchSize,m,n.outChannels]:[n.batchSize,n.outChannels,m],v,y,R,C,D,F),U=f?[$,k]:[k,$];if(s&&U.push(s),D&&U.push(a),F){let q=r.makeTensorInfo([],"float32",w.createScalarValue(o,"float32"));U.push(q),x.push(q)}let H=r.runWebGLProgram(L,U,"float32"),K=pe({inputs:{x:H},backend:r,attrs:{shape:n.outShape}});x.push(H);for(let q of x)r.disposeIntermediateTensorInfo(q);return K}function jte(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:o,pad:i,dataFormat:u,dilations:c,dimRoundingMode:l}=r,p=T.convertConv2DDataFormat(u),d=T.computeConv2DInfo(s.shape,a.shape,o,c,i,l,!1,p),h;if(d.filterHeight===1&&d.filterWidth===1&&d.dilationHeight===1&&d.dilationWidth===1&&d.strideHeight===1&&d.strideWidth===1&&(d.padInfo.type==="SAME"||d.padInfo.type==="VALID"))h=WA({x:s,filter:a,convInfo:d,backend:n});else if(d.strideWidth<=2&&p==="channelsLast"&&G().getBool("WEBGL_EXP_CONV")){let g=new BA(d),m=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];h=n.runWebGLProgram(g,[s,a],"float32",m)}else if(G().getBool("WEBGL_CONV_IM2COL"))h=VA({x:s,filter:a,convInfo:d,backend:n});else{let g=new zA(d);h=n.runWebGLProgram(g,[s,a],"float32")}let f=pe({inputs:{x:h},backend:n,attrs:{shape:d.outShape}});return n.disposeIntermediateTensorInfo(h),f}var qte={kernelName:Wo,backendName:"webgl",kernelFunc:jte},Kte=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,s=e.padInfo.left,a=e.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${r};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${n} - ${s};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              ${a?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}},Xte=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,s=e.strideWidth,a=e.dataFormat==="channelsLast",o=t-1-e.padInfo.top,i=n-1-e.padInfo.left,u=a?1:2,c=a?2:3,l=a?3:1;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${l}];

        ivec2 dyCorner = ivec2(coords[${u}], coords[${c}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${a}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}},Yte=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,s=e.padInfo.front,a=e.padInfo.top,o=e.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${t} - ${s};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${n} - ${a};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${r} - ${o};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}},Zte=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,s=e.strideDepth,a=e.strideHeight,o=e.strideWidth,i=t-1-e.padInfo.front,u=n-1-e.padInfo.top,c=r-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${i}, ${u}, ${c});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${t}; wF++) {
          float dyF = float(dyFCorner + wF) / ${s}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${t} - 1 - wF;

          for (int wR = 0; wR < ${n}; wR++) {
            float dyR = float(dyRCorner + wR) / ${a}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${n} - 1 - wR;

            for (int wC = 0; wC < ${r}; wC++) {
              float dyC = float(dyCCorner + wC) / ${o}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${r} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function Jte(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:o,pad:i,dataFormat:u,dimRoundingMode:c,filterShape:l}=r,p=T.convertConv2DDataFormat(u),d=T.computeConv2DInfo(s.shape,l,o,1,i,c,!1,p),h=new Kte(d);return n.runWebGLProgram(h,[s,a],"float32")}var Qte={kernelName:Wf,backendName:"webgl",kernelFunc:Jte},ene=class{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=wn(this.outputShape.length);let t=e.filterHeight,n=e.filterWidth,r=t-1-e.padInfo.top,s=n-1-e.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${r}, ${s});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            int wCPerm = ${n} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}};function tne(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{inputShape:o,strides:i,pad:u,dataFormat:c,dimRoundingMode:l}=r,p=T.convertConv2DDataFormat(c),d=T.computeConv2DInfo(o,a.shape,i,1,u,l,!1,p);if(G().getBool("WEBGL_PACK")&&p==="channelsLast"){let h=[[d.strideHeight,d.strideWidth]],f=new ene(d);return n.runWebGLProgram(f,[s,a],"float32",h)}else{let h=new Xte(d);return n.runWebGLProgram(h,[s,a],"float32")}}var nne={kernelName:Vo,backendName:"webgl",kernelFunc:tne};function rne(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:o,pad:i,dilations:u}=r,c=T.computeConv3DInfo(s.shape,a.shape,o,u,i),l=new Gte(c);return n.runWebGLProgram(l,[s,a],"float32")}var sne={kernelName:Uo,backendName:"webgl",kernelFunc:rne};function ane(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:o,pad:i,filterShape:u}=r,c=T.computeConv3DInfo(s.shape,u,o,1,i),l=new Yte(c);return n.runWebGLProgram(l,[s,a],"float32")}var one={kernelName:vc,backendName:"webgl",kernelFunc:ane};function ine(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{pad:o,strides:i,inputShape:u}=r,c=T.computeConv3DInfo(u,a.shape,i,1,o),l=new Zte(c);return n.runWebGLProgram(l,[s,a],"float32")}var une={kernelName:xc,backendName:"webgl",kernelFunc:ine},cne=Nl+`
  return cos(x);
`,lne=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${nu}
  return result;
`,dne=Ze({opSnippet:cne,packedOpSnippet:lne}),pne={kernelName:Go,backendName:"webgl",kernelFunc:dne},hne=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,fne=Ze({opSnippet:hne}),mne={kernelName:Ho,backendName:"webgl",kernelFunc:fne},gne=class{constructor(e,t,n,r,s){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];let[a,o,i,u]=e,[c]=t,[l,p]=n;this.outputShape=[c,l,p,u];let d=r==="bilinear"?1:0,[h,f]=[`${o-1}.0`,`${i-1}.0`],[g,m,b]=l>1?[`${(o-1)/(l-1)}`,"(y2-y1) * height_ratio",`y1*${h} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${h}`],[v,y,x]=p>1?[`${(i-1)/(p-1)}`,"(x2-x1) * width_ratio",`x1*${f} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${f}`];this.userCode=`
      const float height_ratio = float(${g});
      const float width_ratio = float(${v});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${a}) {
          return;
        }

        float height_scale = ${m};
        float width_scale = ${y};

        float in_y = ${b};
        if( in_y < 0.0 || in_y > ${h} ) {
          setOutput(float(${s}));
          return;
        }
        float in_x = ${x};
        if( in_x < 0.0 || in_x > ${f} ) {
          setOutput(float(${s}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${d} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}},bne=e=>{let{inputs:t,backend:n,attrs:r}=e,{image:s,boxes:a,boxInd:o}=t,{cropSize:i,method:u,extrapolationValue:c}=r,l=new gne(s.shape,a.shape,i,u,c);return n.runWebGLProgram(l,[s,a,o],"float32")},yne={kernelName:Ic,backendName:"webgl",kernelFunc:bne},Pd;(function(e){e.Prod="*",e.Sum="+"})(Pd||(Pd={}));var $1=class{constructor(e,t,n,r){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];let s=this.outputShape.length,a=this.op===Pd.Prod?"1.0":"0.0",o=n?a:`getX(${F1(s,"coords",this.op)})`,i=this.outputShape[this.outputShape.length-1],u="",c="";n?(u=r?`end != ${i-1}`:"end != 0",c=r?"end + 1":"end - 1"):(u=r?`end + pow2 < ${i}`:"end >= pow2",c=r?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${pt(s)} coords = getOutputCoords();
        int end = ${R1(s,"coords",this.op)};
        float val = ${o};
        int pow2 = int(pow(2.0, index));
        if (${u}) {
          int idx = ${c};
          ${R1(s,"coords",this.op)} = idx;
          val ${this.op}= getX(${F1(s,"coords",this.op)});
        }
        setOutput(val);
      }
    `}};function F1(e,t,n){if(e===1)return`${t}`;if(e===2)return`${t}.x, ${t}.y`;if(e===3)return`${t}.x, ${t}.y, ${t}.z`;if(e===4)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function R1(e,t,n){if(e===1)return`${t}`;if(e===2)return`${t}.y`;if(e===3)return`${t}.z`;if(e===4)return`${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function UA(e,t,n,r,s,a){let o=t.shape.length,i=T.getAxesPermutation([r],o),u=t;i!=null&&(u=_n({inputs:{x:t},backend:n,attrs:{perm:i}}));let c=T.getInnerMostAxes(1,o)[0];if(c!==o-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${r}`);let l=u.shape[c],p=ar({inputs:{x:u},backend:n});for(let d=0;d<=Math.ceil(Math.log2(l))-1;d++){let h=new $1(e,u.shape,!1,a),f=[[d]],g=p;p=n.runWebGLProgram(h,[p],p.dtype,f),n.disposeIntermediateTensorInfo(g)}if(s){let d=new $1(e,u.shape,s,a),h=p;p=n.runWebGLProgram(d,[p],p.dtype),n.disposeIntermediateTensorInfo(h)}if(i!=null){let d=T.getUndoAxesPermutation(i),h=_n({inputs:{x:p},backend:n,attrs:{perm:d}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(u),h}return p}function vne(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:o,reverse:i}=r;return UA(Pd.Prod,s,n,a,o,i)}var xne={kernelName:wc,backendName:"webgl",kernelFunc:vne};function wne(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:o,reverse:i}=r;return UA(Pd.Sum,s,n,a,o,i)}var Ine={kernelName:jo,backendName:"webgl",kernelFunc:wne};function kne(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:o,binaryOutput:i}=r;if(s.shape.length===1){let u=n.readSync(s.dataId),c=n.readSync(a.dataId),l=IA(u,c,a.dtype,a.shape,o);return n.makeTensorInfo([o],a.dtype,l)}else if(s.shape.length===2){let u=n.bufferSync(s),c=n.bufferSync(a),l=CJ(u,c,o,i);return n.makeTensorInfo(l.shape,a.dtype,l.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}var Sne={kernelName:Ud,backendName:"webgl",kernelFunc:kne},Cne=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${t};
      int offset_h = imod(h, ${t});
      int in_w = w / ${t};
      int offset_w = imod(w, ${t});
      int offset_d = (offset_h * ${t} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}};function Tne(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockSize:a,dataFormat:o}=r,i=s.shape[0],u=o==="NHWC"?s.shape[1]:s.shape[2],c=o==="NHWC"?s.shape[2]:s.shape[3],l=o==="NHWC"?s.shape[3]:s.shape[1],p=u*a,d=c*a,h=l/(a*a),f=o==="NHWC"?[i,p,d,h]:[i,h,p,d],g=new Cne(f,a,o);return n.runWebGLProgram(g,[s],s.dtype)}var Nne={kernelName:kc,backendName:"webgl",kernelFunc:Tne},GA=class{constructor(e,t=!1,n=null,r=!1,s=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=wn(this.outputShape.length);let a=e.filterHeight,o=e.filterWidth,i=e.outChannels/e.inChannels,u="",c="";n&&(r?u=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:s?u=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:u=`
          float activation(float x) {
            ${n}
          }
        `,c="result = activation(result);");let l=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${u}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${i};
        int q = d2 - d1 * ${i};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${a}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${o}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${l}
        ${c}
        setOutput(result);
      }
    `}},HA=class{constructor(e,t=!1,n=null,r=!1,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=wn(this.outputShape.length);let a=e.outChannels/e.inChannels,o=e.padInfo.left,i=e.strideWidth,u=e.dilationWidth,c=e.filterHeight,l=e.filterWidth,p=l,d=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let m=0;m<l;m++)d+=`
          vec4 xTexelC${m*2};
          int xTexelC${m*2}Ready;
          vec4 xTexelC${m*2+1};
          int xTexelC${m*2+1}Ready;
          vec4 xC${m};`;d+=`
    for (int r = 0; r < ${c}; r++) {
      `;for(let m=0;m<l;m++)d+=`
          xTexelC${m*2} = vec4(0.0);
          xTexelC${m*2}Ready = 0;
          xTexelC${m*2+1} = vec4(0.0);
          xTexelC${m*2+1}Ready = 0;
          xC${m} = vec4(0.0);`;d+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let m=0;m<(p+1)/2;m++){let b=m*2;if(d+=`
          xC = xCCorner + ${b*u};
          `,i===1){if(b<l&&(o%2===1?(d+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }
              `,u===1&&b>0?d+=`
                xC${b} = vec4(xTexelC${b-2}.zw, xTexelC${b}.xy);
                `:d+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${b} = vec4(previous.zw, xTexelC${b}.xy);
                  } else {
                    xC${b} = vec4(0.0, 0.0, xTexelC${b}.xy);
                  }
                  `):d+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                xC${b} = xTexelC${b};
                `,b+1<l)){let v=o%2===0?w.nearestLargerEven(u):u;u%2===0&&o%2===1||u%2!==0&&o%2!==1?(d+=`
                  xCOffset = xC + imod(pads[1], 2) + ${v};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                    xTexelC${b+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${b+1}.zw = vec2(0.0);
                    }
                    xTexelC${b+1}Ready = 1;
                  }
                  `,u>1?d+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${b+1} = vec4(previous.zw, xTexelC${b+1}.xy);
                    } else {
                     xC${b+1} = vec4(0.0, 0.0, xTexelC${b+1}.xy);
                    }
                    `:d+=`
                    xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.xy);
                    `):v===1?d+=`
                    xC${b+1} = xTexelC${b};
                    `:d+=`
                    xCOffset = xC + ${v};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                      xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${b+1}.zw = vec2(0.0);
                      }
                      xTexelC${b+1}Ready = 1;
                    }

                    xC${b+1} = xTexelC${b+1};
                    `}}else b<l&&(o%2===1?(d+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${b+1}Ready == 0) {
                  xTexelC${b+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${b+1}.zw = vec2(0.0);
                  }
                  xTexelC${b+1}Ready = 1;
                }

                xC${b} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
              `,b+1<l&&(d+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${b+1} = vec4(xTexelC${b+1}.xy, final.xy);
                `)):(d+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                  xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b+1}.zw = vec2(0.);
                  }
                  xTexelC${b+1}Ready = 1;
                }

                xC${b} = vec4(
                  xTexelC${b}.xy, xTexelC${b+1}.xy);
              `,b+1<l&&(d+=`
                  xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
                `)));b<l&&(d+=`
            wTexel = getW(r, ${b}, d1, q);
            dotProd += xC${b} * vec4(wTexel.xz, wTexel.xz);
          `,b+1<l&&(d+=`
              wTexel = getW(r, ${b+1}, d1, q);
              dotProd += xC${b+1} * vec4(wTexel.xz, wTexel.xz);
            `))}d+=`
    }
  `,d+=`
      }
    `;let h="",f="";n&&(r?h=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:s?h=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:h=`vec4 activation(vec4 x) {
          ${n}
        }`,f="result = activation(result);");let g=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${h}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${a};
        int q = d2 - d1 * ${a};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${d}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${g}
        ${f}
        setOutput(result);
      }
    `}};function _ne(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:o,pad:i,dilations:u,dimRoundingMode:c}=r,l=u;l==null&&(l=[1,1]),w.assert(T.eitherStridesOrDilationsAreOne(o,l),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${l}'`);let p=T.computeConv2DInfo(s.shape,a.shape,o,l,i,c,!0),d;G().getBool("WEBGL_PACK_DEPTHWISECONV")&&p.strideWidth<=2&&p.outChannels/p.inChannels===1?d=new HA(p):d=new GA(p);let h=[[p.padInfo.top,p.padInfo.left],[p.strideHeight,p.strideWidth],[p.dilationHeight,p.dilationWidth],[p.inHeight,p.inWidth]];return n.runWebGLProgram(d,[s,a],"float32",h)}var Ene={kernelName:qo,backendName:"webgl",kernelFunc:_ne},Ane=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,s=e.padInfo.left,a=e.outChannels/e.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${a} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${r};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${n} - ${s};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}},Dne=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,s=e.strideWidth,a=t-1-e.padInfo.top,o=n-1-e.padInfo.left,i=e.outChannels/e.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${i}; dm++) {
              int d2 = d1 * ${i} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function $ne(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:o,dilations:i,pad:u,dimRoundingMode:c,filterShape:l}=r,p=T.computeConv2DInfo(s.shape,l,o,i,u,c,!0),d=new Ane(p);return n.runWebGLProgram(d,[s,a],"float32")}var Fne={kernelName:Vf,backendName:"webgl",kernelFunc:$ne};function Rne(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{strides:o,dilations:i,pad:u,dimRoundingMode:c,inputShape:l}=r,p=T.computeConv2DInfo(l,a.shape,o,i,u,c,!0),d=new Dne(p);return n.runWebGLProgram(d,[s,a],"float32")}var Pne={kernelName:Uf,backendName:"webgl",kernelFunc:Rne},One=class{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}};function Mne(e){let{inputs:t,backend:n}=e,{x:r}=t,s=[...r.shape,...r.shape],a=w.sizeFromShape(r.shape),o=pe({inputs:{x:r},backend:n,attrs:{shape:[a]}}),i=new One(a),u=n.runWebGLProgram(i,[o],o.dtype),c=pe({inputs:{x:u},backend:n,attrs:{shape:s}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(u),c}var Lne={kernelName:Gd,backendName:"webgl",kernelFunc:Mne},zne=class{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;let{inHeight:t,inWidth:n,padInfo:r,strideHeight:s,strideWidth:a,filterHeight:o,filterWidth:i,dilationHeight:u,dilationWidth:c}=e,{top:l,left:p}=r;this.userCode=`
      const ivec2 strides = ivec2(${s}, ${a});
      const ivec2 pads = ivec2(${l}, ${p});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${o}; h++) {
          int hIn = hBeg + h * ${u};

          if (hIn >= 0 && hIn < ${t}) {
            for (int w = 0; w < ${i}; w++) {
              int wIn = wBeg + w * ${c};

              if (wIn >= 0 && wIn < ${n}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}};function Bne(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:o,pad:i,dilations:u}=r,c=T.computeDilation2DInfo(s.shape,a.shape,o,i,"NHWC",u),l,p=new zne(c);l=n.runWebGLProgram(p,[s,a],"float32");let d=pe({inputs:{x:l},backend:n,attrs:{shape:c.outShape}});return n.disposeIntermediateTensorInfo(l),d}var Wne={kernelName:Ko,backendName:"webgl",kernelFunc:Bne};function Vne(e){let{inputs:t,backend:n,attrs:r}=e,{equation:s}=r,a=t,{allDims:o,summedDims:i,idDims:u}=T.decodeEinsumEquation(s,a.length);T.checkEinsumDimSizes(o.length,u,a);let{path:c,steps:l}=T.getEinsumComputePath(i,u),p=l.length,d=null,h=o.length,f=[];for(let g=0;g<p;++g){for(let m of l[g]){let{permutationIndices:b,expandDims:v}=T.getEinsumPermutation(h,u[m]),y;T.isIdentityPermutation(b)?y=a[m]:(y=_n({inputs:{x:a[m]},backend:n,attrs:{perm:b}}),f.push(y));let x=y.shape.slice();for(let k=0;k<v.length;++k)x.splice(v[k],0,1);w.arraysEqual(y.shape,x)||(y=pe({inputs:{x:y},backend:n,attrs:{shape:x}}),f.push(y)),d===null?d=y:(d=d0({inputs:{a:y,b:d},backend:n}),f.push(d))}g<p-1&&(c[g]>=0&&(d=sg({inputs:{x:d},backend:n,attrs:{axis:c[g]-(o.length-h),keepDims:!1}}),f.push(d)),h--)}for(let g of f)g!==d&&n.disposeIntermediateTensorInfo(g);return d}var Une={kernelName:Hf,backendName:"webgl",kernelFunc:Vne},Gne="return (x >= 0.0) ? x : (exp(x) - 1.0);",Hne=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,jne=Ze({opSnippet:Gne,packedOpSnippet:Hne}),qne={kernelName:Yo,backendName:"webgl",kernelFunc:jne},Kne="return (b >= 0.0) ? a : a * (b + 1.0);",Xne=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,Yne=e=>{let{inputs:t,backend:n}=e,{dy:r,y:s}=t,a=G().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Tl(Xne,r.shape,s.shape):new To(Kne,r.shape,s.shape);return n.runWebGLProgram(a,[r,s],r.dtype)},Zne={kernelName:Sc,backendName:"webgl",kernelFunc:Yne},Jne=`
  return vec4(equal(a, b));
`,Qne="return float(a == b);",ere=mn({opSnippet:Qne,packedOpSnippet:Jne,dtype:"bool",cpuKernelImpl:AJ}),tre={kernelName:Cc,backendName:"webgl",kernelFunc:ere},nre=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${T.ERF_P};
  float a1 = ${T.ERF_A1};
  float a2 = ${T.ERF_A2};
  float a3 = ${T.ERF_A3};
  float a4 = ${T.ERF_A4};
  float a5 = ${T.ERF_A5};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,rre=Ze({opSnippet:nre}),sre={kernelName:Zo,backendName:"webgl",kernelFunc:rre},are=Nl+`
  return exp(x);
`,ore=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,jA=Ze({opSnippet:are,packedOpSnippet:ore,cpuKernelImpl:DJ,dtype:"float32"}),ire={kernelName:Jo,backendName:"webgl",kernelFunc:jA};function xx(e){let{inputs:t,attrs:n,backend:r}=e,{dim:s}=n,{input:a}=t,o=a.shape.length,i=a.shape.slice(),u=s;return s<0&&(w.assert(-(o+1)<=s,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),u=o+s+1),i.splice(u,0,1),pe({inputs:{x:a},backend:r,attrs:{shape:i}})}var ure={kernelName:Tc,backendName:"webgl",kernelFunc:xx},P1="return exp(x) - 1.0;",cre=Ze({opSnippet:P1,packedOpSnippet:P1,cpuKernelImpl:$J}),lre={kernelName:Qo,backendName:"webgl",kernelFunc:cre},O1=class{constructor(e,t,n){this.variableNames=["real","imag"];let r=t[1];this.outputShape=t;let s=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,a=n?`${r}.0`:"1.0",o;if(e==="real")o="return real * expR - imag * expI;";else if(e==="imag")o="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);this.userCode=`
      const float exponentMultiplier = ${s};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${o}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${r});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${r}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${a};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}};function qA(e,t,n){let r=n.texData.get(e.dataId),s=w.sizeFromShape(e.shape),a=e.shape[e.shape.length-1],o=s/a,i=pe({inputs:{x:e},backend:n,attrs:{shape:[o,a]}}),u=i.shape,c=new O1("real",u,t),l=new O1("imag",u,t),p=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:u},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:u}],d=n.runWebGLProgram(c,p,"float32"),h=n.runWebGLProgram(l,p,"float32"),f=Oa({inputs:{real:d,imag:h},backend:n});n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h);let g=pe({inputs:{x:f},backend:n,attrs:{shape:e.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(f),g}function dre(e){let{inputs:t,backend:n}=e,{input:r}=t;return qA(r,!1,n)}var pre={kernelName:jf,backendName:"webgl",kernelFunc:dre},hre=class{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}};function Bp(e){let{backend:t,attrs:n}=e,{shape:r,value:s}=n,{dtype:a}=n;if(a=a||w.inferDtype(s),a==="string"){let o=w.getArrayFromDType(a,w.sizeFromShape(r));return o.fill(s),t.makeTensorInfo(r,a,o)}else{let o=new hre(r,s),i=[[s]];return t.runWebGLProgram(o,[],a,i)}}var fre={kernelName:Hd,backendName:"webgl",kernelFunc:Bp},mre=class{constructor(e){this.variableNames=["Image"],this.outputShape=[];let t=e[2];this.outputShape=e,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${t} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${t}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}},gre={kernelName:Nc,backendName:"webgl",kernelFunc:({inputs:e,backend:t})=>{let{image:n}=e,r=t,s=new mre(n.shape);return r.runWebGLProgram(s,[n],n.dtype)}},M1="return floor(x);",bre=Ze({opSnippet:M1,packedOpSnippet:M1,cpuKernelImpl:FJ}),yre={kernelName:ei,backendName:"webgl",kernelFunc:bre},vre=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,xre=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,wre=mn({opSnippet:vre,packedOpSnippet:xre,dtype:"int32"}),Ire={kernelName:ti,backendName:"webgl",kernelFunc:wre},kre=class{constructor(e){this.variableNames=["A"];let t=$n(),[n,r]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${n}.0);

        vec4 values = ${t.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}},Sre=class{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;let t=$n(),[n,r]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${r}.0, ${n}.0);
            vec4 values = ${t.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${t.output} = result;
      }
    `}},Cre={kernelName:lf,backendName:"webgl",kernelFunc:Tre},Pu,Tv=G().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function Tre(e){let{inputs:t,backend:n,attrs:r}=e,{pixels:s}=t,{numChannels:a}=r,o=typeof HTMLVideoElement<"u"&&s instanceof HTMLVideoElement,i=typeof HTMLImageElement<"u"&&s instanceof HTMLImageElement,[u,c]=o?[s.videoWidth,s.videoHeight]:[s.width,s.height],l=[c,u],p=[c,u,a];if(i||o){let g=G().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(Pu==null||g!==Tv)&&(Tv=g,Pu=document.createElement("canvas").getContext("2d",{willReadFrequently:Tv})),Pu.canvas.width=u,Pu.canvas.height=c,Pu.drawImage(s,0,0,u,c),s=Pu.canvas}let d=n.makeTensorInfo(l,"int32");n.texData.get(d.dataId).usage=dr.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(d.dataId),s);let h=G().getBool("WEBGL_PACK")?new Sre(p):new kre(p),f=n.runWebGLProgram(h,[d],"int32");return n.disposeData(d.dataId),f}function Nre(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:o,preluActivationWeights:i}=t,{strides:u,pad:c,dataFormat:l,dilations:p,dimRoundingMode:d,activation:h,leakyreluAlpha:f}=r,g=T.convertConv2DDataFormat(l),m=T.computeConv2DInfo(s.shape,a.shape,u,p,c,d,!1,g),b,v=[],y=o!=null,x=i!=null,k=h==="leakyrelu",S=()=>{let E=[s,a],$=(R,D)=>{if(D==="NCHW"&&R.shape.length===1&&R.shape[0]!==1){let F=pe({inputs:{x:R},backend:n,attrs:{shape:[R.shape[0],1,1]}});return v.push(F),F}return R};if(y&&E.push($(o,l)),x&&E.push($(i,l)),k){let R=n.makeTensorInfo([],"float32",w.createScalarValue(f,"float32"));E.push(R),v.push(R)}return E};if(m.filterHeight===1&&m.filterWidth===1&&m.dilationHeight===1&&m.dilationWidth===1&&m.strideHeight===1&&m.strideWidth===1&&(m.padInfo.type==="SAME"||m.padInfo.type==="VALID"))b=WA({x:s,filter:a,convInfo:m,backend:n,bias:o,activation:h,preluActivationWeights:i,leakyreluAlpha:f});else if(m.strideWidth<=2&&g==="channelsLast"&&G().getBool("WEBGL_EXP_CONV")){let E=h?Fd(h,!0):null,$=new BA(m,y,E,x,k),R=[[m.padInfo.top,m.padInfo.left],[m.strideHeight,m.strideWidth],[m.dilationHeight,m.dilationWidth],[m.inHeight,m.inWidth]],D=S();b=n.runWebGLProgram($,D,"float32",R)}else if(G().getBool("WEBGL_CONV_IM2COL"))b=VA({x:s,filter:a,convInfo:m,backend:n,bias:o,activation:h,preluActivationWeights:i,leakyreluAlpha:f});else{let E=h?Fd(h,!1):null,$=new zA(m,y,E,x,k),R=S();b=n.runWebGLProgram($,R,"float32")}let N=pe({inputs:{x:b},backend:n,attrs:{shape:m.outShape}});return v.push(b),v.forEach(E=>n.disposeIntermediateTensorInfo(E)),N}var _re={kernelName:lo,backendName:"webgl",kernelFunc:Nre};function Ere(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:o,preluActivationWeights:i}=t,{strides:u,pad:c,dilations:l,dimRoundingMode:p,activation:d,leakyreluAlpha:h}=r,f=[],g=l;g==null&&(g=[1,1]),w.assert(T.eitherStridesOrDilationsAreOne(u,g),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${u} and dilations '${g}'`);let m=T.computeConv2DInfo(s.shape,a.shape,u,g,c,p,!0),b=G().getBool("WEBGL_PACK_DEPTHWISECONV")&&m.strideWidth<=2&&m.outChannels/m.inChannels===1,v=d?Fd(d,b):null,y=[s,a],x=o!=null,k=i!=null,S=d==="leakyrelu";if(x&&y.push(o),k&&y.push(i),S){let R=n.makeTensorInfo([],"float32",w.createScalarValue(h,"float32"));y.push(R),f.push(R)}let N;b?N=new HA(m,x,v,k,S):N=new GA(m,x,v,k,S);let E=[[m.padInfo.top,m.padInfo.left],[m.strideHeight,m.strideWidth],[m.dilationHeight,m.dilationWidth],[m.inHeight,m.inWidth]],$=n.runWebGLProgram(N,y,"float32",E);return f.forEach(R=>n.disposeIntermediateTensorInfo(R)),$}var Are={kernelName:po,backendName:"webgl",kernelFunc:Ere},Dre=class{constructor(e,t,n,r){this.sliceDim=e,this.strides=t,this.paramsShape=r,this.variableNames=["x","indices"],this.outputShape=n;let s=pt(n.length),a=`
    int index;`;for(let o=0;o<this.sliceDim;o++)a+=`
          index = round(getIndices(coords[0], ${o}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[o]};
          flattenIndex += index * ${this.strides[o]};`;this.userCode=`
         void main() {
          ${s} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${a}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}};function $re(e){let{inputs:t,backend:n}=e,{params:r,indices:s}=t,a=s.shape,o=a[a.length-1],i=w.sizeFromShape(r.shape),[u,c,l,p]=T.prepareAndValidate(r,s),d=pe({inputs:{x:s},backend:n,attrs:{shape:[c,o]}}),h=pe({inputs:{x:r},backend:n,attrs:{shape:[w.sizeFromShape(r.shape)/l,l]}});if(n.shouldExecuteOnCPU([r,s])||r.dtype==="string"){let b=n.readSync(s.dataId),v=n.bufferSync(r),y=RJ(b,v,r.dtype,c,o,l,p,r.shape,i);return n.makeTensorInfo(u,r.dtype,y.values)}let f=new Dre(o,p,[c,l],r.shape),g=n.runWebGLProgram(f,[h,d],h.dtype),m=pe({inputs:{x:g},backend:n,attrs:{shape:u}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(g),m}var Fre={kernelName:Ec,backendName:"webgl",kernelFunc:$re},Rre=class{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;let n=pt(this.rank),r=Pre(e,2);this.userCode=`
      void main() {
        ${n} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${r}));
      }
    `}};function Pre(e,t){let n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let s=0;s<e.length;s++)s===2?r.push("index"):r.push(`${n[s]}`);return r.join()}function KA(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,indices:a}=t,{axis:o,batchDims:i}=r,u=w.parseAxisParam(o,s.shape)[0];if(G().get("DEBUG")){let v=n.readSync(a.dataId),y=s.shape[u];for(let x=0;x<v.length;++x){let k=v[x];w.assert(k<=y-1&&k>=0,()=>`GatherV2: the index value ${k} is not in [0, ${y-1}]`)}}let c=T.segment_util.collectGatherOpShapeInfo(s,a,u,i),l=w.sizeFromShape(a.shape),p=[],d=pe({inputs:{x:s},backend:n,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),h=pe({inputs:{x:a},backend:n,attrs:{shape:[c.batchSize,l/c.batchSize]}});p.push(d),p.push(h);let f=[c.batchSize,c.outerSize,l/c.batchSize,c.sliceSize];if(n.shouldExecuteOnCPU([s,a])||s.dtype==="string"){let v=n.bufferSync(h),y=n.bufferSync(d),x=PJ(y,v,f);return p.forEach(k=>n.disposeIntermediateTensorInfo(k)),n.makeTensorInfo(c.outputShape,x.dtype,x.values)}let g=new Rre(d.shape,f),m=n.runWebGLProgram(g,[d,h],d.dtype);p.push(m);let b=pe({inputs:{x:m},backend:n,attrs:{shape:c.outputShape}});return p.forEach(v=>n.disposeIntermediateTensorInfo(v)),b}var Ore={kernelName:_c,backendName:"webgl",kernelFunc:KA},Mre="return float(a > b);",Lre=`
  return vec4(greaterThan(a, b));
`,zre=mn({opSnippet:Mre,packedOpSnippet:Lre,cpuKernelImpl:OJ,dtype:"bool"}),Bre={kernelName:Ac,backendName:"webgl",kernelFunc:zre},Wre="return float(a >= b);",Vre=`
  return vec4(greaterThanEqual(a, b));
`,Ure=mn({opSnippet:Wre,packedOpSnippet:Vre,dtype:"bool",cpuKernelImpl:MJ}),Gre={kernelName:ri,backendName:"webgl",kernelFunc:Ure};function Hre(e){let{inputs:t,backend:n}=e,{input:r}=t;return qA(r,!0,n)}var jre={kernelName:qf,backendName:"webgl",kernelFunc:Hre},qre="return float(!isnan(x) && !isinf(x));",Kre=Ze({opSnippet:qre,dtype:"bool"}),Xre={kernelName:ai,backendName:"webgl",kernelFunc:Kre},Yre="return float(isinf(x));",Zre=Ze({opSnippet:Yre,dtype:"bool"}),Jre={kernelName:oi,backendName:"webgl",kernelFunc:Zre},Qre="return float(isnan(x));",ese=Ze({opSnippet:Qre,dtype:"bool"}),tse={kernelName:ii,backendName:"webgl",kernelFunc:ese},nse="return float(a < b);",rse=`
  return vec4(lessThan(a, b));
`,sse=mn({opSnippet:nse,packedOpSnippet:rse,cpuKernelImpl:LJ,dtype:"bool"}),ase={kernelName:Dc,backendName:"webgl",kernelFunc:sse},ose="return float(a <= b);",ise=`
  return vec4(lessThanEqual(a, b));
`,use=mn({opSnippet:ose,packedOpSnippet:ise,cpuKernelImpl:zJ,dtype:"bool"}),cse={kernelName:$c,backendName:"webgl",kernelFunc:use};function lse(e){let{backend:t,attrs:n}=e,{start:r,stop:s,num:a}=n,o=BJ(r,s,a);return t.makeTensorInfo([o.length],"float32",o)}var dse={kernelName:Fc,backendName:"webgl",kernelFunc:lse},pse=Nl+`
  return x < 0.0 ? 0./0. : log(x);
`,hse=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,fse=Ze({opSnippet:pse,packedOpSnippet:hse,cpuKernelImpl:WJ}),mse={kernelName:ci,backendName:"webgl",kernelFunc:fse},gse=Nl+`
  return log(1.0 + x);
`,bse=Ze({opSnippet:gse}),yse={kernelName:li,backendName:"webgl",kernelFunc:bse},vse="return float(a >= 1.0 && b >= 1.0);",xse=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,wse=mn({opSnippet:vse,packedOpSnippet:xse,dtype:"bool"}),Ise={kernelName:Rc,backendName:"webgl",kernelFunc:wse},kse="return float(!(x >= 1.0));",Sse=Ze({opSnippet:kse}),Cse={kernelName:Pc,backendName:"webgl",kernelFunc:Sse},Tse="return float(a >= 1.0 || b >= 1.0);",Nse=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,_se=mn({opSnippet:Tse,packedOpSnippet:Nse,dtype:"bool"}),Ese={kernelName:Oc,backendName:"webgl",kernelFunc:_se},Ase=class{constructor(e,t,n,r,s){this.variableNames=["x"],this.outputShape=[];let a=t,o=e[3]-1;this.outputShape=e;let i,u=`float(${n}) + float(${r}) * sum`;s===.5?i=`inversesqrt(${u})`:s===1?i=`1.0/(${u})`:i=`exp(log(${u}) * float(-${s}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${a}; j <= ${a}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${o}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${i};
        setOutput(val);
      }
    `}},Dse=class{constructor(e,t,n,r,s){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;let a=t,o=e[3]-1;this.outputShape=e;let i,u=`float(${n}) + float(${r}) * sum`;s===.5?i=`inversesqrt(${u})`:s===1?i=`1.0/(${u})`:i=`exp(log(${u}) * float(-${s}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${a};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${a}; j <= ${a}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${o}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${i};
        setOutput(result);
      }
    `}},$se=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{depthRadius:a,bias:o,alpha:i,beta:u}=r,c=G().getBool("WEBGL_PACK_NORMALIZATION")?new Dse(s.shape,a,o,i,u):new Ase(s.shape,a,o,i,u);return n.runWebGLProgram(c,[s],s.dtype)},Fse={kernelName:di,backendName:"webgl",kernelFunc:$se},Rse=class{constructor(e,t,n,r,s){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=r,this.beta=s,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${t})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${t} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${r}) * norm + float(${n});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${r})
                * float(${s})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${s});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}},Pse=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:s,y:a,dy:o}=t,{depthRadius:i,bias:u,alpha:c,beta:l}=r,p=new Rse(s.shape,i,u,c,l);return n.runWebGLProgram(p,[s,a,o],s.dtype)},Ose={kernelName:Mc,backendName:"webgl",kernelFunc:Pse};function Mse(e,t,n,r){let s=w.sizeFromShape(t),o=w.sizeFromShape(e.shape)/s,i=pe({inputs:{x:e},attrs:{shape:[o,s]},backend:r}),u=ru(i,e.dtype,"max",r),c=pe({inputs:{x:u},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(i),r.disposeIntermediateTensorInfo(u),c}function XA(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reductionIndices:a,keepDims:o}=r,i=s.shape.length,u=w.parseAxisParam(a,s.shape),c=u,l=T.getAxesPermutation(c,i),p=l!=null,d=n.shouldExecuteOnCPU([s]),h=s;if(p){if(d){let y=n.texData.get(h.dataId).values,x=new Array(i);for(let N=0;N<x.length;N++)x[N]=s.shape[l[N]];let k=c0(y,s.shape,s.dtype,l,x);h=n.makeTensorInfo(x,s.dtype);let S=n.texData.get(h.dataId);S.values=k}else h=rg(s,l,n);c=T.getInnerMostAxes(c.length,i)}T.assertAxesAreInnerMostDims("max",c,i);let[f,g]=T.computeOutAndReduceShapes(h.shape,c),m=f;o&&(m=T.expandShapeToKeepDim(f,u));let b;if(d){let y=n.texData.get(h.dataId).values,x=VJ(y,w.sizeFromShape(g),m,s.dtype);b=n.makeTensorInfo(m,s.dtype);let k=n.texData.get(b.dataId);k.values=x}else b=Mse(h,g,m,n);return p&&n.disposeIntermediateTensorInfo(h),b}var Lse={kernelName:pi,backendName:"webgl",kernelFunc:XA},zse=l0+`
  return max(a, b);
`,Bse=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+nu+`
  return result;
`,Wse=mn({opSnippet:zse,packedOpSnippet:Bse,cpuKernelImpl:UJ}),Vse={kernelName:hi,backendName:"webgl",kernelFunc:Wse};function Use(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t;wl(s,"maxPool");let{filterSize:a,strides:o,pad:i,dimRoundingMode:u}=r,c=1;w.assert(T.eitherStridesOrDilationsAreOne(o,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);let l=T.computePool2DInfo(s.shape,a,o,c,i,u);if(l.filterWidth===1&&l.filterHeight===1&&w.arraysEqual(l.inShape,l.outShape))return ar({inputs:{x:s},backend:n});let p=new Rd(l,"max",!1);return n.runWebGLProgram(p,[s],s.dtype)}var Gse={kernelName:fi,backendName:"webgl",kernelFunc:Use};function Hse(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:o,pad:i,dataFormat:u,dimRoundingMode:c}=r,l=[1,1,1],p=T.computePool3DInfo(s.shape,a,o,l,i,c,u),d=new p0(p,"max",!1);return n.runWebGLProgram(d,[s],s.dtype)}var jse={kernelName:Lc,backendName:"webgl",kernelFunc:Hse},qse=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;let t=e.strideHeight,n=e.strideWidth,r=e.dilationHeight,s=e.effectiveFilterHeight,a=e.effectiveFilterWidth,o=s-1-e.padInfo.top,i=a-1-e.padInfo.left,u=s*a-1;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${s};
          wR += ${r}) {
          float dyR = float(dyRCorner + wR) / ${t}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${a}; wC++) {
            float dyC = float(dyCCorner + wC) / ${n}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${u} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${a} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}},Kse=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;let t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,s=e.dilationDepth,a=e.dilationHeight,o=e.dilationWidth,i=e.effectiveFilterDepth,u=e.effectiveFilterHeight,c=e.effectiveFilterWidth,l=i-1-e.padInfo.front,p=u-1-e.padInfo.top,d=c-1-e.padInfo.left,h=i*u*c-1;this.userCode=`
      const ivec3 pads = ivec3(${l}, ${p}, ${d});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${i};
           wD += ${s}) {
          float dyD = float(dyDCorner + wD) / ${t}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${u};
              wR += ${a}) {
            float dyR = float(dyRCorner + wR) / ${n}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${c};
                wC += ${o}) {
              float dyC = float(dyCCorner + wC) / ${r}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${h} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${u} * ${c} +
                  wR * ${c} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function Xse(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,o=a,{filterSize:i,strides:u,pad:c,dimRoundingMode:l}=r,p=[1,1,1],d=T.computePool3DInfo(o.shape,i,u,p,c,l),h=new p0(d,"max",!0),f=n.runWebGLProgram(h,[o],o.dtype),g=new Kse(d),m=n.runWebGLProgram(g,[s,f],o.dtype);return n.disposeIntermediateTensorInfo(f),m}var Yse={kernelName:qd,backendName:"webgl",kernelFunc:Xse};function Zse(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a,output:o}=t,i=a;wl([a,o],"maxPoolGrad");let{filterSize:u,strides:c,pad:l,dimRoundingMode:p}=r,d=T.computePool2DInfo(i.shape,u,c,1,l,p),h=!0,f=new Rd(d,"max",h),g=n.runWebGLProgram(f,[i],i.dtype),m=new qse(d),b=n.runWebGLProgram(m,[s,g],i.dtype);return n.disposeIntermediateTensorInfo(g),b}var Jse={kernelName:jd,backendName:"webgl",kernelFunc:Zse};function Qse(e,t,n,r){let s=new Rd(n,"max",!1),a=r.runWebGLProgram(s,[e],"float32");s=new Rd(n,"max",!0,!0,t);let o=r.runWebGLProgram(s,[e],"float32");return[a,o]}var eae={kernelName:Kd,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{x:r}=e,{filterSize:s,strides:a,pad:o,includeBatchInIndex:i}=t,u=n;w.assert(r.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);let c=[1,1];w.assert(T.eitherStridesOrDilationsAreOne(a,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${c}'`);let l=T.computePool2DInfo(r.shape,s,a,c,o),[p,d]=Qse(r,i,l,u);return[p,d]}};function tae(e,t,n,r){let s=w.sizeFromShape(t),o=w.sizeFromShape(e.shape)/s,i=pe({inputs:{x:e},attrs:{shape:[o,s]},backend:r}),u=ru(i,"float32","mean",r),c=pe({inputs:{x:u},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(i),r.disposeIntermediateTensorInfo(u),c}var nae={kernelName:mi,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{x:r}=e,{keepDims:s,axis:a}=t,o=n,i=r.shape.length,u=w.parseAxisParam(a,r.shape),c=u,l=T.getAxesPermutation(c,i),p=l!=null,d=o.shouldExecuteOnCPU([r]),h=[],f=r;if(p){if(d){let x=o.texData.get(f.dataId).values,k=new Array(i);for(let E=0;E<k.length;E++)k[E]=r.shape[l[E]];let S=c0(x,r.shape,r.dtype,l,k);f=o.makeTensorInfo(k,r.dtype);let N=o.texData.get(f.dataId);N.values=S}else f=rg(r,l,o);h.push(f),c=T.getInnerMostAxes(c.length,i)}T.assertAxesAreInnerMostDims("sum",c,i);let[g,m]=T.computeOutAndReduceShapes(f.shape,c),b=g;s&&(b=T.expandShapeToKeepDim(g,u));let v=tae(f,m,b,o);for(let y of h)o.disposeIntermediateTensorInfo(y);return v}};function rae(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:o}=r,i=s.shape.length,u=w.parseAxisParam(a,s.shape),c=u,l=T.getAxesPermutation(c,i),p=s;l!=null&&(p=_n({inputs:{x:s},backend:n,attrs:{perm:l}}),c=T.getInnerMostAxes(c.length,s.shape.length)),T.assertAxesAreInnerMostDims("min",c,i);let[d,h]=T.computeOutAndReduceShapes(p.shape,c),f=w.sizeFromShape(h),g=pe({inputs:{x:p},backend:n,attrs:{shape:[-1,f]}}),m=ru(g,g.dtype,"min",n),b;if(o){let v=T.expandShapeToKeepDim(d,u);b=pe({inputs:{x:m},backend:n,attrs:{shape:v}})}else b=pe({inputs:{x:m},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(m),l!=null&&n.disposeIntermediateTensorInfo(p),b}var sae={kernelName:gi,backendName:"webgl",kernelFunc:rae},aae=l0+`
  return min(a, b);
`,oae=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+nu+`
  return result;
`,iae=mn({opSnippet:aae,packedOpSnippet:oae,cpuKernelImpl:GJ}),uae={kernelName:bi,backendName:"webgl",kernelFunc:iae},cae=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map((c,l)=>c[0]+e[l]+c[1]);let r=e.length,s=pt(r),a=t.map(c=>c[0]).join(","),o=t.map((c,l)=>c[0]+e[l]).join(","),i=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),u=n==="reflect"?0:1;if(r===1){this.userCode=`
        int start = ${a};
        int end = ${o};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${u};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${u};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${s} start = ${s}(${a});
      ${s} end = ${s}(${o});

      void main() {
        ${s} outC = getOutputCoords();
        for (int i = 0; i < ${r}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${u};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${u};
          }
        }
        ${s} coords = outC - start;
        setOutput(getX(${i}));
      }
    `}},lae=class{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((h,f)=>h[0]+e[f]+h[1]);let r=e.length,s=pt(r),a=t.map(h=>h[0]).join(","),o=t.map((h,f)=>h[0]+e[f]).join(","),i=Nn("rc",r),u=Nn("source",r),c=`${i[r-1]} < ${this.outputShape[r-1]}`,l=r===1?"source":`vec2(${u.slice(-2).join()})`,p=n==="reflect"?0:1,d="";if(r===1){let h=`
        ${s} source = rc;
        if (source < start) {
          source = start * 2 - source - ${p};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${p};
        }
        source -= start;
      `;d=`
        ${s} rc = outputLoc;
        ${h}
        result[0] = getChannel(getX(${u.join()}), ${l});
        ${i[r-1]} += 1;
        if(${c}) {
          ${h}
          result[1] = getChannel(getX(${u.join()}), ${l});
        }
      `}else{let h=`
        ${s} source = rc;
        ${s} lt = ${s}(lessThan(source, start));
        ${s} gte = ${s}(greaterThanEqual(source, end));
        ${s} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${p}) +
                gte * ((end - 1) * 2 - source + ${p});
        source -= start;
      `;d=`
        ${s} rc = outputLoc;
        ${h}
        result[0] = getChannel(getX(${u.join()}), ${l});
        ${i[r-1]} += 1;
        if(${c}) {
          ${h}
          result[1] = getChannel(getX(${u.join()}), ${l});
        }
        rc = outputLoc;
        ${i[r-2]} += 1;
        if(${i[r-2]} < ${this.outputShape[r-2]}) {
          ${h}
          result[2] = getChannel(getX(${u.join()}), ${l});
          ${i[r-1]} += 1;
          if(${c}) {
            ${h}
            result[3] = getChannel(getX(${u.join()}), ${l});
          }
        }
      `}this.userCode=`
      const ${s} start = ${s}(${a});
      const ${s} end = ${s}(${o});

      void main() {
        ${s} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${d}
        setOutput(result);
      }
    `}},dae=({inputs:e,backend:t,attrs:n})=>{let{x:r}=e,{paddings:s,mode:a}=n,o=G().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new lae(r.shape,s,a):new cae(r.shape,s,a);return t.runWebGLProgram(o,[r],r.dtype)},pae={kernelName:yi,backendName:"webgl",kernelFunc:dae},hae=`if (b == 0.0) return NAN;
  return mod(a, b);`,fae=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+nu+`
  return result;
`,mae=mn({opSnippet:hae,packedOpSnippet:fae}),gae={kernelName:vi,backendName:"webgl",kernelFunc:mae},bae=class{constructor(e,t,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,n],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${t-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${t-1}));
      }
    `}},yae=`
if (a == b) {
  return 1.0;
};
return a / b;`,vae=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,YA=mn({opSnippet:yae,packedOpSnippet:vae,checkOutOfBounds:!0}),xae={kernelName:Xo,backendName:"webgl",kernelFunc:YA},L1="return a - b;",ZA=mn({opSnippet:L1,packedOpSnippet:L1,supportsComplex:!0,cpuKernelImpl:dQ}),wae={kernelName:Gi,backendName:"webgl",kernelFunc:ZA};function JA(e){let{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{dim:a}=r,o=w.parseAxisParam([a],s.shape),i=XA({inputs:{x:s},backend:n,attrs:{reductionIndices:o,keepDims:!1}}),u=T.expandShapeToKeepDim(i.shape,o),c=pe({inputs:{x:i},backend:n,attrs:{shape:u}}),l=ZA({inputs:{a:s,b:c},backend:n}),p=jA({inputs:{x:l},backend:n}),d=sg({inputs:{x:p},backend:n,attrs:{axis:o,keepDims:!1}}),h=pe({inputs:{x:d},backend:n,attrs:{shape:u}}),f=YA({inputs:{a:p,b:h},backend:n});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),f}var Iae={kernelName:Vi,backendName:"webgl",kernelFunc:JA};function kae(e){let{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{numSamples:a,seed:o,normalized:i}=r,u=i?s:JA({inputs:{logits:s},backend:n,attrs:{dim:s.shape.length-1}}),c=u.shape[0],l=u.shape[1],p=new bae(c,l,a),d=[[o]],h=n.runWebGLProgram(p,[u],"int32",d);return i||n.disposeIntermediateTensorInfo(u),h}var Sae={kernelName:zc,backendName:"webgl",kernelFunc:kae},Cae=Lr+`
  return -x;
`,Tae=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function Nae(e){let{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])){let a=n.texData.get(r.dataId),[o,i]=jJ(a.values,r.shape,r.dtype);return n.makeTensorInfo(i,r.dtype,o)}let s;return G().getBool("WEBGL_PACK_UNARY_OPERATIONS")?s=new ua(r.shape,Tae):s=new is(r.shape,Cae),n.runWebGLProgram(s,[r],r.dtype)}var _ae={kernelName:Bc,backendName:"webgl",kernelFunc:Nae},Eae=bs.nonMaxSuppressionV3Impl;function Aae(e){T.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:o,iouThreshold:i,scoreThreshold:u}=r,c=n.readSync(s.dataId),l=n.readSync(a.dataId),{selectedIndices:p}=Eae(c,l,o,i,u);return n.makeTensorInfo([p.length],"int32",new Int32Array(p))}var Dae={kernelName:Vc,backendName:"webgl",kernelFunc:Aae},$ae=bs.nonMaxSuppressionV4Impl;function Fae(e){T.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:o,iouThreshold:i,scoreThreshold:u,padToMaxOutputSize:c}=r,l=n.readSync(s.dataId),p=n.readSync(a.dataId),{selectedIndices:d,validOutputs:h}=$ae(l,p,o,i,u,c);return[n.makeTensorInfo([d.length],"int32",new Int32Array(d)),n.makeTensorInfo([],"int32",new Int32Array([h]))]}var Rae={kernelName:Uc,backendName:"webgl",kernelFunc:Fae},Pae=bs.nonMaxSuppressionV5Impl;function Oae(e){T.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:o,iouThreshold:i,scoreThreshold:u,softNmsSigma:c}=r,l=n.readSync(s.dataId),p=n.readSync(a.dataId),d=o,h=i,f=u,g=c,{selectedIndices:m,selectedScores:b}=Pae(l,p,d,h,f,g);return[n.makeTensorInfo([m.length],"int32",new Int32Array(m)),n.makeTensorInfo([b.length],"float32",new Float32Array(b))]}var Mae={kernelName:Gc,backendName:"webgl",kernelFunc:Oae},Lae=class{constructor(e,t,n,r){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${r}), float(${n}),
                      float(index == coords.y)));
      }
    `}},zae=e=>{let{inputs:t,backend:n,attrs:r}=e,{indices:s}=t,{dtype:a,depth:o,onValue:i,offValue:u}=r,c=w.sizeFromShape(s.shape),l=new Lae(c,o,i,u),p=pe({inputs:{x:s},backend:n,attrs:{shape:[c]}}),d=n.runWebGLProgram(l,[p],a);n.disposeIntermediateTensorInfo(p);let h=[...s.shape,o],f=pe({inputs:{x:d},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(d),f},Bae={kernelName:wi,backendName:"webgl",kernelFunc:zae};function Rf(e){let{inputs:t,backend:n}=e,{x:r}=t;if(r.dtype==="complex64"){let s=zp({inputs:{input:r},backend:n}),a=Rf({inputs:{x:s},backend:n}),o=ag({inputs:{input:r},backend:n}),i=Rf({inputs:{x:o},backend:n}),u=Oa({inputs:{real:a,imag:i},backend:n});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(i),u}else return Bp({attrs:{shape:r.shape,dtype:r.dtype,value:r.dtype==="string"?"":0},backend:n})}var Wae={kernelName:cl,backendName:"webgl",kernelFunc:Rf};function QA(e){let{inputs:t,backend:n}=e,{x:r}=t;if(r.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(r.dtype==="complex64"){let s=zp({inputs:{input:r},backend:n}),a=QA({inputs:{x:s},backend:n}),o=ag({inputs:{input:r},backend:n}),i=Rf({inputs:{x:o},backend:n}),u=Oa({inputs:{real:a,imag:i},backend:n});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(i),u}else return Bp({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:n})}var Vae={kernelName:Hc,backendName:"webgl",kernelFunc:QA};function Uae(e){let{inputs:t,backend:n,attrs:r}=e,{axis:s}=r;if(t.length===1)return xx({inputs:{input:t[0]},backend:n,attrs:{dim:s}});let a=t[0].shape,o=t[0].dtype;t.forEach(l=>{w.assertShapesMatch(a,l.shape,"All tensors passed to stack must have matching shapes"),w.assert(o===l.dtype,()=>"All tensors passed to stack must have matching dtypes")});let i=[],u=t.map(l=>{let p=xx({inputs:{input:l},backend:n,attrs:{dim:s}});return i.push(p),p}),c=LA({inputs:u,backend:n,attrs:{axis:s}});return i.forEach(l=>n.disposeIntermediateTensorInfo(l)),c}var Gae={kernelName:jc,backendName:"webgl",kernelFunc:Uae},Hae=class{constructor(e,t,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((u,c)=>u[0]+e[c]+u[1]);let r=e.length,s=pt(r),a=t.map(u=>u[0]).join(","),o=t.map((u,c)=>u[0]+e[c]).join(","),i=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);if(r===1){this.userCode=`
        int start = ${a};
        int end = ${o};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${s} start = ${s}(${a});
      ${s} end = ${s}(${o});

      void main() {
        ${s} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${s} coords = outC - start;
          setOutput(getX(${i}));
        }
      }
    `}},jae=class{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((f,g)=>f[0]+e[g]+f[1]);let r=e.length,s=pt(r),a=t.map(f=>f[0]).join(","),o=t.map((f,g)=>f[0]+e[g]).join(","),i=Nn("rc",r),u=Nn("source",r),c=`${i[r-1]} < ${this.outputShape[r-1]}`,l=r===1?"source":`vec2(${u.slice(-2).join()})`,p=[`${s} rc = outputLoc;`,`${i[r-1]} += 1;
       if(${c}) {
      `,r===1?"":`}
       rc = outputLoc;
       ${i[r-2]} += 1;
       if(${i[r-2]} < ${this.outputShape[r-2]}) {`,r===1?"":`  ${i[r-1]} += 1;
         if(${c}) {`],d=r===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))",h="";for(let f=0,g=r===1?2:4;f<g;f++)h+=`
        ${p[f]}
        if (${d}) {
          result[${f}] = float(value);
        } else {
          ${s} source = rc - start;
          result[${f}] = getChannel(getX(${u.join()}), ${l});
        }
      `;h+=r===1?"} ":"}}",this.userCode=`
      const ${s} start = ${s}(${a});
      const ${s} end = ${s}(${o});

      void main() {
        ${s} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${h}
        setOutput(result);
      }
    `}},eD=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{paddings:a,constantValue:o}=r;if(w.sizeFromShape(s.shape)===0){let c=a.map((l,p)=>l[0]+s.shape[p]+l[1]);return Bp({backend:n,attrs:{shape:c,value:o,dtype:s.dtype}})}let i=G().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new jae(s.shape,a,o):new Hae(s.shape,a,o),u=[[o]];return n.runWebGLProgram(i,[s],s.dtype,u)},qae={kernelName:Ii,backendName:"webgl",kernelFunc:eD},Kae=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,Xae=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+nu+`
  return result;
`,Yae=mn({opSnippet:Kae,packedOpSnippet:Xae}),Zae={kernelName:ki,backendName:"webgl",kernelFunc:Yae};function Jae(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:o}=r,i=s.shape.length,u=[],c=w.parseAxisParam(a,s.shape),l=c,p=T.getAxesPermutation(l,i),d=s;p!=null&&(d=_n({inputs:{x:s},backend:n,attrs:{perm:p}}),l=T.getInnerMostAxes(l.length,i),u.push(d)),T.assertAxesAreInnerMostDims("prod",l,i);let h;if(n.shouldExecuteOnCPU([d])){let f=n.texData.get(d.dataId).values,{outVals:g,outShape:m,outDtype:b}=KJ(d.shape,d.dtype,f,l);h=n.makeTensorInfo(m,b,g)}else{let[f,g]=T.computeOutAndReduceShapes(d.shape,l),m=w.sizeFromShape(g),b=pe({inputs:{x:d},backend:n,attrs:{shape:[-1,m]}}),v=em(s.dtype),y=ru(b,v,"prod",n);h=pe({inputs:{x:y},backend:n,attrs:{shape:f}}),u.push(b),u.push(y)}if(o){u.push(h);let f=T.expandShapeToKeepDim(h.shape,c);h=pe({inputs:{x:h},backend:n,attrs:{shape:f}})}return u.forEach(f=>n.disposeIntermediateTensorInfo(f)),h}var Qae={kernelName:Ci,backendName:"webgl",kernelFunc:Jae};function eoe(e){let{inputs:t,backend:n,attrs:r}=e,{paramsNestedSplits:s,paramsDenseValues:a,indices:o}=t,{outputRaggedRank:i}=r,u=s.map(b=>n.readSync(b.dataId)),c=s.map(b=>b.shape),l=n.readSync(a.dataId),p=n.readSync(o.dataId),[d,h,f]=XJ(u,c,l,a.shape,a.dtype,p,o.shape,i),g=d.map(b=>n.makeTensorInfo([b.length],"int32",b)),m=n.makeTensorInfo(f,a.dtype,h);return g.concat([m])}var toe={kernelName:Xf,backendName:"webgl",kernelFunc:eoe};function noe(e){let{inputs:t,backend:n}=e,{starts:r,limits:s,deltas:a}=t,o=n.readSync(r.dataId),i=n.readSync(s.dataId),u=n.readSync(a.dataId),[c,l]=YJ(o,r.shape,r.dtype,i,s.shape,u,a.shape),p=n.makeTensorInfo([c.length],"int32",c),d=n.makeTensorInfo([l.length],r.dtype,l);return[p,d]}var roe={kernelName:Yf,backendName:"webgl",kernelFunc:noe};function soe(e){let{inputs:t,backend:n,attrs:r}=e,{shape:s,values:a,defaultValue:o,rowPartitionTensors:i}=t,{rowPartitionTypes:u}=r,c=n.readSync(s.dataId),l=n.readSync(a.dataId),p=n.readSync(o.dataId),d=i.map(m=>n.readSync(m.dataId)),h=i.map(m=>m.shape),[f,g]=ZJ(c,s.shape,l,a.shape,a.dtype,p,o.shape,d,h,u);return n.makeTensorInfo(f,a.dtype,g)}var aoe={kernelName:Zf,backendName:"webgl",kernelFunc:soe},tD=e=>{let{backend:t,attrs:n}=e,{start:r,stop:s,step:a,dtype:o}=n,i=JJ(r,s,a,o);return t.makeTensorInfo([i.length],o,i)},ooe={kernelName:Xd,backendName:"webgl",kernelFunc:tD},ioe="return 1.0 / x;",uoe=Ze({opSnippet:ioe}),coe={kernelName:Ti,backendName:"webgl",kernelFunc:uoe},loe=Lr+`
  return (x < 0.0) ? 0.0 : x;
`,doe=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,poe=Ze({opSnippet:loe,packedOpSnippet:doe}),hoe={kernelName:Ni,backendName:"webgl",kernelFunc:poe},foe=Lr+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,moe=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,goe=Ze({opSnippet:foe,packedOpSnippet:moe}),boe={kernelName:Ai,backendName:"webgl",kernelFunc:goe},yoe=class{constructor(e,t,n,r,s){this.variableNames=["A"],this.outputShape=[];let[a,o,i,u]=e;this.outputShape=[a,t,n,u];let c=[r&&t>1?o-1:o,r&&n>1?i-1:i],l=[r&&t>1?t-1:t,r&&n>1?n-1:n],p;s?p="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":p="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0]/l[0]},
          ${c[1]/l[1]});
      const vec2 inputShapeRC = vec2(${o}.0, ${i}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${p};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}},voe=class{constructor(e,t,n,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[a,o,i,u]=e;this.outputShape=[a,t,n,u];let c=[r&&t>1?o-1:o,r&&n>1?i-1:i],l=[r&&t>1?t-1:t,r&&n>1?n-1:n],p;s?p="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":p="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0]/l[0]},
          ${c[1]/l[1]},
          ${c[1]/l[1]});
      const vec3 inputShapeRC = vec3(${o}.0, ${i}.0,
                                     ${i}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${p};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${u-1};
        bool hasNextRow = coords.z < ${n-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}};function xoe(e){let{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:o,size:i}=r,[u,c]=i,l=G().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new voe(s.shape,u,c,a,o):new yoe(s.shape,u,c,a,o);return n.runWebGLProgram(l,[s],"float32")}var woe={kernelName:Ei,backendName:"webgl",kernelFunc:xoe},Ioe=class{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;let[,r,s]=t,[,a,o]=e,i=[n&&a>1?r-1:r,n&&o>1?s-1:s],u=[n&&a>1?a-1:a,n&&o>1?o-1:o],c=i[0]/u[0],l=i[1]/u[1],p=1/c,d=1/l,h=Math.ceil(p)*2+2,f=Math.ceil(d)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${l});

        const float invHeightScale = float(${p});
        const float invWidthScale = float(${d});

        const int winHeight = int(${h});
        const int winWidth = int(${f});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${a}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${o}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${s-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function koe(e){let{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:o}=r,i=new Ioe(a.shape,s.shape,o);return n.runWebGLProgram(i,[a],a.dtype)}var Soe={kernelName:Xc,backendName:"webgl",kernelFunc:koe},Coe=class{constructor(e,t,n,r,s){this.variableNames=["A"],this.outputShape=[];let[a,o,i,u]=e;this.outputShape=[a,t,n,u];let c=[r&&t>1?o-1:o,r&&n>1?i-1:i],l=[r&&t>1?t-1:t,r&&n>1?n-1:n],p=r?"0.5":"0.0",d;s?d="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":d="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0]/l[0]},
          ${c[1]/l[1]});
      const vec2 inputShapeRC = vec2(${o}.0, ${i}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${d};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${p})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}},Toe=class{constructor(e,t,n,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[a,o,i,u]=e;this.outputShape=[a,t,n,u];let c=[r&&t>1?o-1:o,r&&n>1?i-1:i],l=[r&&t>1?t-1:t,r&&n>1?n-1:n],p=r?"0.5":"0.0",d;s?d="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":d="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0]/l[0]},
          ${c[1]/l[1]},
          ${c[1]/l[1]});
      const vec3 inputShapeRC = vec3(${o}.0, ${i}.0,
                                     ${i}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${d};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${p})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${u-1};
        bool hasNextRow = coords.z < ${n-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}};function Noe(e){let{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:o,size:i}=r,[u,c]=i,l=G().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Toe(s.shape,u,c,a,o):new Coe(s.shape,u,c,a,o);return n.runWebGLProgram(l,[s],s.dtype)}var _oe={kernelName:_i,backendName:"webgl",kernelFunc:Noe},Eoe=class{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;let[,r,s]=t,[,a,o]=e,i=[n&&a>1?r-1:r,n&&o>1?s-1:s],u=[n&&a>1?a-1:a,n&&o>1?o-1:o],c=i[0]/u[0],l=i[1]/u[1],p=1/c,d=1/l,h=Math.ceil(p)*2+2,f=Math.ceil(d)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${l});

        const float invHeightScale = float(${p});
        const float invWidthScale = float(${d});

        const int winHeight = int(${h});
        const int winWidth = int(${f});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${a}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${o}) {
              continue;
            }

            float sourceFracRow =
              float(${i[0]}) *
                (float(dyR) / float(${u[0]}));

            float sourceFracCol =
                float(${i[1]}) *
                  (float(dyC) / float(${u[1]}));

            int sourceNearestRow = int(min(
                float(int(${r}) - 1),
                ${n} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${s}) - 1),
                ${n} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function Aoe(e){let{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:o}=r,i=new Eoe(a.shape,s.shape,o);return n.runWebGLProgram(i,[a],a.dtype)}var Doe={kernelName:Kc,backendName:"webgl",kernelFunc:Aoe},$oe=class{constructor(e,t){this.variableNames=["x"];let n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=e,n===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;return}let r=o=>t.indexOf(o)!==-1&&e[o]!==1?`${e[o]} - coords[${o}] - 1`:`coords[${o}]`,s=e.map((o,i)=>r(i)).join(","),a=pt(n);this.userCode=`
      void main() {
        ${a} coords = getOutputCoords();
        setOutput(getX(${s}));
      }
    `}},Foe=class{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;let n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=e;let r=Nn("rc",n),s=`${r[n-1]} + 1 < ${this.outputShape[n-1]}`,a=`${r[n-2]} + 1 < ${this.outputShape[n-2]}`,o=pt(n);n===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${s}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${o} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${i(r.slice())};
          if(${s}){
            result.g = ${u(r.slice())};
          }
          if(${a}) {
            result.b = ${c(r.slice())};
            if(${s}) {
              result.a = ${l(r.slice())};
            }
          }
          setOutput(result);
        }
    `;function i(h){return p(h)}function u(h){return h[n-1]="("+h[n-1]+" + 1)",p(h)}function c(h){return h[n-2]="("+h[n-2]+" + 1)",p(h)}function l(h){return h[n-1]="("+h[n-1]+" + 1)",h[n-2]="("+h[n-2]+" + 1)",p(h)}function p(h){let f=e.map((b,v)=>d(v,h)),g=f.join(","),m=f.slice(-2).join(",");return`getChannel(getX(${g}), vec2(${m}))`}function d(h,f){return t.indexOf(h)!==-1&&e[h]!==1?`${e[h]} - ${f[h]} - 1`:`${f[h]}`}}};function Roe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dims:a}=r,o=s.shape.length,i=w.parseAxisParam(a,s.shape);if(o===0)return ar({inputs:{x:s},backend:n});let u=G().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Foe(s.shape,i):new $oe(s.shape,i);return n.runWebGLProgram(u,[s],s.dtype)}var Poe={kernelName:Di,backendName:"webgl",kernelFunc:Roe},Ooe=class{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];let n=e[1],r=e[2];this.outputShape=e;let s="";typeof t=="number"?s=`float outputValue = ${t.toFixed(2)};`:s=`
        vec3 fill = vec3(${t.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${s}
          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${n}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}},Moe={kernelName:ll,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{image:r}=e,{radians:s,fillValue:a,center:o}=t,i=n,u=new Ooe(r.shape,a),[c,l]=T.getImageCenter(o,r.shape[1],r.shape[2]),p=[[c,l,Math.sin(s),Math.cos(s)]];return i.runWebGLProgram(u,[r],r.dtype,p)}},Loe=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,zoe=Ze({opSnippet:Loe}),Boe={kernelName:$i,backendName:"webgl",kernelFunc:zoe},Woe="return inversesqrt(x);",Voe=Ze({opSnippet:Woe,cpuKernelImpl:QJ}),Uoe={kernelName:Fi,backendName:"webgl",kernelFunc:Voe},h0=class{constructor(e,t,n,r,s,a,o=!0,i=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=a;let u=pt(s.length),c=pt(a.length),l="";n===1?l="i":n===2&&(l="i, j");let p=`getIndices(${l})`,d="";r===1?d="i":r===2&&(d="i, coords[1]");let h=`getUpdates(${d})`,f="";i&&(f="coords[0], coords[1]");let g=`getDefaultValue(${f})`,m=t>1?"strides[j]":"strides";this.userCode=`
        ${u} strides = ${u}(${s});

        void main() {
          ${c} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${t}; j++) {
              int index = round(${p});
              flattenedIndex += index * ${m};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${h};
              found = true;
            }
          }
          setOutput(mix(${g}, sum, float(found)));
        }
      `}},Goe=class{constructor(e,t,n,r,s,a,o=!0,i=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=a;let u=pt(s.length),c=pt(a.length),l="";n===1?l="i":n===2&&(l="i, j");let p=`getIndices(${l})`,d="";r===1?d="i":r===2&&(d="i, coords[1]");let h=`getUpdates(${d})`,f="";i&&(f="coords[0], coords[1]");let g=`getDefaultValue(${f})`,m=t>1?"strides[j]":"strides",b=t>1?"strides[j + 1]":"strides";this.userCode=`
        ${u} strides = ${u}(${s});

        void main() {
          ${c} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${e}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${t}; j+=2) {
              ivec4 index = round(${p});
              flattenedIndex += index.xz * ${m};
              if (j + 1 < ${t}) {
                flattenedIndex += index.yw * ${b};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${h};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${g}, sum, found));
        }
      `}};function Hoe(e){let{inputs:t,backend:n,attrs:r}=e,{indices:s,updates:a}=t,{shape:o}=r,{sliceRank:i,numUpdates:u,sliceSize:c,strides:l,outputSize:p}=T.calculateShapes(a,s,o),d=[p/c,c];if(p===0)return n.makeTensorInfo(o,s.dtype);let h=pe({inputs:{x:s},backend:n,attrs:{shape:[u,i]}}),f=pe({inputs:{x:a},backend:n,attrs:{shape:[u,c]}}),g=n.makeTensorInfo([],"float32",new Float32Array([0])),m;G().getBool("WEBGL_PACK")?m=new Goe(u,i,h.shape.length,f.shape.length,l,d):m=new h0(u,i,h.shape.length,f.shape.length,l,d);let b=n.runWebGLProgram(m,[f,h,g],f.dtype),v=pe({inputs:{x:b},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(g),v}var joe={kernelName:Yc,backendName:"webgl",kernelFunc:Hoe},qoe=class{constructor(e,t,n,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,n];let s="while (left < right) {",a=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,o=G().getNumber("WEBGL_VERSION")===2?s:a,i=r==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${o}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${i} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}};function Koe(e){let{inputs:t,backend:n,attrs:r}=e,{sortedSequence:s,values:a}=t,{side:o}=r,i=new qoe(s.shape[0],s.shape[1],a.shape[1],o),u=[[s.shape[1]]];return n.runWebGLProgram(i,[s,a],"int32",u)}var Xoe={kernelName:Jc,backendName:"webgl",kernelFunc:Koe},Yoe=class{constructor(e,t,n){this.variableNames=["c","a","b"],this.outputShape=t;let r,s;if(n>4)throw Error(`Where for rank ${n} is not yet supported`);if(n===1)s="resRC",r="resRC";else{let o=["resRC.x","resRC.y","resRC.z","resRC.w"],i=[],u=[];for(let c=0;c<t.length;c++)u.push(`${o[c]}`),c<e&&i.push(`${o[c]}`);r=i.join(),s=u.join()}let a=pt(n);this.userCode=`
      void main() {
        ${a} resRC = getOutputCoords();
        float cVal = getC(${r});
        if (cVal >= 1.0) {
          setOutput(getA(${s}));
        } else {
          setOutput(getB(${s}));
        }
      }
    `}};function Zoe(e){let{inputs:t,backend:n}=e,{condition:r,t:s,e:a}=t,o=new Yoe(r.shape.length,s.shape,s.shape.length);return n.runWebGLProgram(o,[r,s,a],mr(s.dtype,a.dtype))}var Joe={kernelName:Qc,backendName:"webgl",kernelFunc:Zoe},Qoe=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${T.SELU_SCALEALPHA};
  float scale = ${T.SELU_SCALE};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,eie=Ze({opSnippet:Qoe}),tie={kernelName:Ri,backendName:"webgl",kernelFunc:eie},nie=Nl+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,rie=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,sie=Ze({opSnippet:nie,packedOpSnippet:rie,cpuKernelImpl:tQ}),aie={kernelName:Li,backendName:"webgl",kernelFunc:sie},oie=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,iie=Ze({opSnippet:oie}),uie={kernelName:Mi,backendName:"webgl",kernelFunc:iie},cie=Nl+`
  return sin(x);
`,lie=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${nu}
  return result;
`,die=Ze({opSnippet:cie,packedOpSnippet:lie}),pie={kernelName:Pi,backendName:"webgl",kernelFunc:die},hie=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,fie=Ze({opSnippet:hie}),mie={kernelName:Oi,backendName:"webgl",kernelFunc:fie},gie=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,bie=Ze({opSnippet:gie}),yie={kernelName:zi,backendName:"webgl",kernelFunc:bie},vie=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,paddings:o}=r;w.assert(s.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");let i=a.reduce((b,v)=>b*v),u=[[0,0]];u.push(...o);for(let b=1+a.length;b<s.shape.length;++b)u.push([0,0]);let c=[],l=eD({inputs:{x:s},backend:n,attrs:{paddings:u,constantValue:0}}),p=T.getReshaped(l.shape,a,i,!1),d=T.getPermuted(p.length,a.length,!1),h=T.getReshapedPermuted(l.shape,a,i,!1),f=pe({inputs:{x:l},backend:n,attrs:{shape:p}}),g=_n({inputs:{x:f},backend:n,attrs:{perm:d}}),m=pe({inputs:{x:g},backend:n,attrs:{shape:h}});return c.push(l),c.push(f),c.push(g),c.forEach(b=>n.disposeIntermediateTensorInfo(b)),m},xie={kernelName:tl,backendName:"webgl",kernelFunc:vie};function wie(e){let{inputs:t,backend:n}=e,{indices:r,values:s,denseShape:a,defaultValue:o}=t;if(a.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${a.shape}`);if(r.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${r.shape}`);if(s.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${s.shape}`);if(o.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${o.shape}`);let i=n.readSync(r.dataId),u=n.readSync(s.dataId),c=n.readSync(a.dataId),l=n.readSync(o.dataId)[0],[p,d,h,f,g]=rQ(i,r.shape,r.dtype,u,s.dtype,c,l);return[n.makeTensorInfo(d,r.dtype,p),n.makeTensorInfo([d[0]],s.dtype,h),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(m=>Number(m)))),n.makeTensorInfo([g.length],r.dtype,new Int32Array(g))]}var Iie={kernelName:Yd,backendName:"webgl",kernelFunc:wie};function kie(e){let{inputs:t,backend:n}=e,{inputIndices:r,inputShape:s,newShape:a}=t;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(s.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${s.shape}`);if(a.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${a.shape}`);let o=Array.from(n.readSync(s.dataId)),i=n.readSync(r.dataId),u=Array.from(n.readSync(a.dataId)),[c,l,p]=sQ(i,r.shape,r.dtype,o,u);return[n.makeTensorInfo(l,r.dtype,c),n.makeTensorInfo([p.length],a.dtype,new Int32Array(p))]}var Sie={kernelName:rl,backendName:"webgl",kernelFunc:kie};function Cie(e){let{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${s.shape}`);if(a.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${a.shape}`);let o=n.readSync(r.dataId),i=n.readSync(s.dataId),u=n.readSync(a.dataId),[c,l]=SA(o,r.shape,r.dtype,i,u,!0);return n.makeTensorInfo(l,r.dtype,c)}var Tie={kernelName:Zd,backendName:"webgl",kernelFunc:Cie};function Nie(e){let{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${s.shape}`);if(a.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${a.shape}`);let o=n.readSync(r.dataId),i=n.readSync(s.dataId),u=n.readSync(a.dataId),[c,l]=SA(o,r.shape,r.dtype,i,u);return n.makeTensorInfo(l,r.dtype,c)}var _ie={kernelName:Jd,backendName:"webgl",kernelFunc:Nie};function Eie(e){let{inputs:t,backend:n,attrs:r}=e,{sparseIndices:s,sparseValues:a,defaultValue:o}=t,{outputShape:i}=r,{sliceRank:u,numUpdates:c,sliceSize:l,strides:p,outputSize:d}=T.calculateShapes(a,s,i),h=!1;if(a.dtype==="string"){let b=n.bufferSync(s),v=n.bufferSync(a),y=w.decodeString(n.readSync(o.dataId)[0]),x=eQ(b,v,i,d,l,c,u,p,y,h);return n.makeTensorInfo(i,x.dtype,x.values)}let f=new h0(c,u,s.shape.length,a.shape.length,p,[d,1],h),g=n.runWebGLProgram(f,[a,s,o],a.dtype),m=pe({inputs:{x:g},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(g),m}var Aie={kernelName:sl,backendName:"webgl",kernelFunc:Eie};function Die(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{numOrSizeSplits:a,axis:o}=r,i=w.parseAxisParam(o,s.shape)[0],u=T.prepareSplitSize(s,a,i),c=s.shape.length,l=new Array(c).fill(0),p=s.shape.slice();return u.map(d=>{let h=[...p];h[i]=d;let f=_l({inputs:{x:s},backend:n,attrs:{begin:l,size:h}});return l[i]+=d,f})}var $ie={kernelName:nl,backendName:"webgl",kernelFunc:Die},z1="return sqrt(x);",Fie=Ze({opSnippet:z1,packedOpSnippet:z1,cpuKernelImpl:aQ}),Rie={kernelName:Bi,backendName:"webgl",kernelFunc:Fie},Pie="return x * x;",Oie=Ze({opSnippet:Pie}),Mie={kernelName:Qd,backendName:"webgl",kernelFunc:Oie},B1="return (a - b) * (a - b);",Lie=mn({opSnippet:B1,packedOpSnippet:B1}),zie={kernelName:Ui,backendName:"webgl",kernelFunc:Lie};function Bie(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");let a=n.readSync(s.dataId),o=T.fromUint8ToStringArray(a),i=oQ(o,"string",r);return n.makeTensorInfo(s.shape,"string",i)}var Wie={kernelName:ep,backendName:"webgl",kernelFunc:Bie};function Vie({inputs:e,attrs:t,backend:n}){let{x:r}=e,s=Lr+`
    return x > 0.0 ? 1.0 : float(${t.alpha});
  `,a=new is(r.shape,s);return n.runWebGLProgram(a,[r],r.dtype)}var Uie={kernelName:Na,backendName:"webgl",kernelFunc:Vie},Gie=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=n;let r=n.length,s=pt(n.length),a=pt(n.length),o="";if(r===1)o="coords * strides + begin";else{let i=0;o=n.map((u,c)=>(i++,n.length===1?`coords * strides[${c}] + begin[${c}]`:`coords[${i-1}] * strides[${c}] + begin[${c}]`)).join(",")}this.userCode=`
      ${s} begin = ${s}(${e});
      ${s} strides = ${s}(${t});

      void main() {
        ${a} coords = getOutputCoords();
        setOutput(getX(${o}));
      }
    `}};function Hie(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,end:o,strides:i,beginMask:u,endMask:c,ellipsisMask:l,newAxisMask:p,shrinkAxisMask:d}=r,{finalShapeSparse:h,finalShape:f,isIdentity:g,sliceDim0:m,isSimpleSlice:b,begin:v,end:y,strides:x}=Yt.sliceInfo(s.shape,a,o,i,u,c,l,p,d),k;if(g)k=pe({inputs:{x:s},backend:n,attrs:{shape:f}});else if(m||b){w.assert(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);let N=Yt.computeOutShape(v,y,x),E=_l({inputs:{x:s},backend:n,attrs:{begin:v,size:N}});k=pe({inputs:{x:E},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(E)}else if(n.shouldExecuteOnCPU([s])){let E=n.readSync(s.dataId),$=ze(s.shape,s.dtype,E),R=iQ(h,$,x,v);k=n.makeTensorInfo(f,s.dtype,R.values)}else{let E=new Gie(v,x,h);k=n.runWebGLProgram(E,[s],s.dtype)}let S=pe({inputs:{x:k},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(k),S}var jie={kernelName:al,backendName:"webgl",kernelFunc:Hie};function qie(e){let{inputs:t,backend:n,attrs:r}=e,{separator:s,nGramWidths:a,leftPad:o,rightPad:i,padWidth:u,preserveShortSequences:c}=r,{data:l,dataSplits:p}=t,d=n.readSync(l.dataId),h=n.readSync(p.dataId),[f,g]=uQ(d,h,s,a,o,i,u,c);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(p.shape,"int32",g)]}var Kie={kernelName:tp,backendName:"webgl",kernelFunc:qie};function Xie(e){let{inputs:t,backend:n,attrs:r}=e,{skipEmpty:s}=r,{input:a,delimiter:o}=t;if(a.dtype!=="string")throw new Error("Input must be of datatype string");if(a.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${a.shape}`);if(o.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);let i=n.readSync(a.dataId),u=n.readSync(o.dataId)[0],[c,l,p]=cQ(i,u,s),d=l.length;return[n.makeTensorInfo([d,2],"int32",c),n.makeTensorInfo([d],"string",l),n.makeTensorInfo([2],"int32",new Int32Array(p))]}var Yie={kernelName:np,backendName:"webgl",kernelFunc:Xie};function Zie(e){let{inputs:t,backend:n,attrs:r}=e,{numBuckets:s}=r,{input:a}=t;if(a.dtype!=="string")throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");let o=n.readSync(a.dataId),i=lQ(o,s);return n.makeTensorInfo(a.shape,"int32",i)}var Jie={kernelName:rp,backendName:"webgl",kernelFunc:Zie},Qie="return tan(x);",eue=Ze({opSnippet:Qie}),tue={kernelName:Hi,backendName:"webgl",kernelFunc:eue},nue=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,rue=Ze({opSnippet:nue}),sue={kernelName:ji,backendName:"webgl",kernelFunc:rue};function aue(e){let{inputs:t,backend:n,attrs:r}=e,{tensor:s,indices:a,updates:o}=t,{}=r,{sliceRank:i,numUpdates:u,sliceSize:c,strides:l,outputSize:p}=T.calculateShapes(o,a,s.shape),d=[p/c,c];if(p===0)return n.makeTensorInfo(s.shape,a.dtype);let h=pe({inputs:{x:a},backend:n,attrs:{shape:[u,i]}}),f=pe({inputs:{x:o},backend:n,attrs:{shape:[u,c]}}),g=pe({inputs:{x:s},backend:n,attrs:{shape:d}}),m=new h0(u,i,h.shape.length,f.shape.length,l,d,!1,!0),b=n.runWebGLProgram(m,[f,h,g],g.dtype),v=pe({inputs:{x:b},backend:n,attrs:{shape:s.shape}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(b),v}var oue={kernelName:Zc,backendName:"webgl",kernelFunc:aue},iue=class{constructor(e,t){this.variableNames=["A"];let n=new Array(e.length);for(let a=0;a<n.length;a++)n[a]=e[a]*t[a];this.outputShape=n,this.rank=n.length;let r=pt(this.rank),s=uue(e);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        setOutput(getA(${s}));
      }
    `}};function uue(e){let t=e.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(t===1)return`imod(resRC, ${e[0]})`;let n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let s=0;s<e.length;s++)r.push(`imod(${n[s]}, ${e[s]})`);return r.join()}function nD(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reps:a}=r;if(s.dtype==="string"||s.shape.length>5){let u=n.readSync(s.dataId),c=s.dtype==="string"?u.map(d=>w.decodeString(d)):u,l=ze(s.shape,s.dtype,c),p=pQ(l,a);return n.makeTensorInfo(p.shape,p.dtype,p.values)}let o=new iue(s.shape,a);return n.runWebGLProgram(o,[s],s.dtype)}var cue={kernelName:Ta,backendName:"webgl",kernelFunc:nD},lue=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}},due=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}};function Ka(e,t){t!==null&&e.disposeIntermediateTensorInfo(t)}function W1(e){let t=1;for(;t<e;)t*=2;return t}function pue(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{k:a,sorted:o}=r,i=G().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),u=G().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),c=s.shape,l=c[c.length-1];if(n.shouldExecuteOnCPU([s])||l<i||a>u){let R=n.readSync(s.dataId),[D,F]=hQ(R,c,s.dtype,a,o);return[n.makeTensorInfo(D.shape,D.dtype,D.values),n.makeTensorInfo(F.shape,F.dtype,F.values)]}if(a===0)return c[c.length-1]=0,[n.makeTensorInfo(c,s.dtype,[]),n.makeTensorInfo(c,"int32",[])];if(l===1)return[s,Bp({attrs:{shape:c,dtype:"int32",value:0},backend:n})];let p=n.texData.get(s.dataId),d=p!==null&&p.isPacked,h=d?n.unpackTensor(s):s,g=w.sizeFromShape(c)/l,m=pe({inputs:{x:h},attrs:{shape:[g,l]},backend:n});d&&Ka(n,h);let b=W1(a),v=W1(l),y=null,x=()=>y===null?[m,m]:[m,y],k=(R,D,F)=>{let C=x(),L=new lue(F),H=[[l],[y===null?1:0],[Number.NEGATIVE_INFINITY],[R],[D]],K=y;y=n.runWebGLProgram(L,C,"int32",H),Ka(n,K)};for(let R=1;R<b;R*=2){let D=R*2;for(let F=R;F>=1;F/=2)k(D,F,[g,v])}for(let R=v;R>b;R/=2){let D=x(),F=new due([g,R/2]),L=[[l],[y===null?1:0],[b]],U=y;y=n.runWebGLProgram(F,D,"int32",L),Ka(n,U);let H=b/2,K=H*2;for(let q=H;q>=1;q/=2)k(K,q,y.shape)}let S=y;y=_l({inputs:{x:y},backend:n,attrs:{begin:0,size:[g,a]}}),Ka(n,S);let N=KA({inputs:{x:m,indices:y},backend:n,attrs:{axis:1,batchDims:1}});Ka(n,m);let E=c.slice(0,-1);E.push(a),S=y,y=pe({inputs:{x:y},attrs:{shape:E},backend:n}),Ka(n,S);let $=N;return N=pe({inputs:{x:N},attrs:{shape:E},backend:n}),Ka(n,$),[N,y]}var hue={kernelName:ol,backendName:"webgl",kernelFunc:pue},fue=class{constructor(e,t,n,r,s,a){this.variableNames=["Image","Transforms"],this.outputShape=a;let o=n==="nearest"?1:2,i;switch(r){case"constant":i=1;break;case"reflect":i=2;break;case"wrap":i=3;break;case"nearest":i=4;break;default:i=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${i} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${i} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${i} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${s});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${s});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${t}));
                float mapY = mapCoord(inY, float(${e}));

                if (${o} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}};function mue(e){let{inputs:t,backend:n,attrs:r}=e,{image:s,transforms:a}=t,{interpolation:o,fillMode:i,fillValue:u,outputShape:c}=r,[l,p,d,h]=s.shape,[f,g]=c??[p,d],m=[l,f,g,h],b=new fue(p,d,o,i,u,m);return n.runWebGLProgram(b,[s,a],"float32")}var gue={kernelName:il,backendName:"webgl",kernelFunc:mue};function bue(e){let{inputs:t,attrs:n,backend:r}=e,{axis:s}=n,{x:a}=t;wl(a,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");let o=r.readSync(a.dataId),{outputValues:i,outputShape:u,indices:c}=fQ(o,s,a.shape,a.dtype);return[r.makeTensorInfo(u,a.dtype,i),r.makeTensorInfo([c.length],"int32",c)]}var yue={kernelName:sp,backendName:"webgl",kernelFunc:bue};function vue(e){let{inputs:t,backend:n,attrs:r}=e,{value:s}=t,{axis:a}=r;a<0&&(a+=s.shape.length);let o=s,i=o.shape.length,u=s.shape[a],c=new Array(i-1),l=0;for(let g=0;g<i;g++)g!==a&&(c[l++]=o.shape[g]);let p=[],d=new Array(i).fill(0),h=o.shape.slice();h[a]=1;let f=new Array(u);for(let g=0;g<f.length;g++){d[a]=g;let m=_l({inputs:{x:o},backend:n,attrs:{begin:d,size:h}}),b=pe({inputs:{x:m},backend:n,attrs:{shape:c}});f[g]=b,p.push(m)}return p.forEach(g=>n.disposeIntermediateTensorInfo(g)),f}var xue={kernelName:ul,backendName:"webgl",kernelFunc:vue},wue=class{constructor(e,t){this.variableNames=["x","segmentIds"];let n=e.windowSize,r=e.batchSize,s=e.inSize,a=e.numSegments,o=a*Math.ceil(s/n);this.outputShape=[r,o];let i="0.0",u="sumValue",c=Math.floor(n/4)*4,l=n%4,p=`
        sumValue += dot(values, segFilter);
    `,d="";s%n>0&&(d=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return initializationValue;
        }
      `);let h="";s%n>0&&(h=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${i};

      float getValue(int batch, int inIdx) {
        ${d}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${h}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${a})) * float(${n}));
        int currentSeg = int(mod(float(outIdx), float(${a})));

        float sumValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${p}
        }

        int inIdx = inOffset + ${c};
        if (${l===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${p}
        } else if (${l===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${p}
        } else if (${l===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${p}
        }
        setOutput(${u});
      }
    `}};function Iue(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,segmentIds:a}=t,{numSegments:o}=r,i=s.shape.length,u=[],c=0,l=T.getAxesPermutation([c],i),p=s;l!=null&&(p=_n({inputs:{x:s},backend:n,attrs:{perm:l}}),u.push(p),c=T.getInnerMostAxes(1,i)[0]);let d=T.segment_util.computeOutShape(p.shape,c,o),h=w.sizeFromShape([p.shape[c]]),f=pe({inputs:{x:p},backend:n,attrs:{shape:[-1,h]}});u.push(f);let g=em(s.dtype),m=(x,k,S,N,E)=>{let $=x.shape[0],R=x.shape[1],D=T.segment_util.segOpComputeOptimalWindowSize(R,E),F={windowSize:D,inSize:R,batchSize:$,numSegments:E},C=new wue(F,k),L=n.compileAndRun(C,[x,S],N);if(u.push(L),L.shape[1]===E)return L;let U=tD({backend:n,attrs:{start:0,stop:E,step:1,dtype:"float32"}}),H=nD({inputs:{x:U},backend:n,attrs:{reps:[R/D]}});return u.push(U),u.push(H),m(L,k,H,N,E)},b=m(f,"unsortedSegmentSum",a,g,o),v=pe({inputs:{x:b},backend:n,attrs:{shape:d}}),y=v;if(l!=null){u.push(v);let x=T.getUndoAxesPermutation(l);y=_n({inputs:{x:y},backend:n,attrs:{perm:x}})}return u.forEach(x=>n.disposeIntermediateTensorInfo(x)),y}var kue={kernelName:ap,backendName:"webgl",kernelFunc:Iue},Sue=[iee,cee,pee,mee,bee,xee,Iee,See,_ee,Aee,Fee,Oee,zee,Uee,jee,Kee,Yee,ete,nte,ste,ute,mte,bte,wte,kte,Ete,Dte,Pte,GQ,Lte,Ute,qte,Qte,nne,sne,one,une,pne,mne,yne,xne,Ine,Sne,Nne,Ene,Fne,Pne,Lne,Wne,Une,qne,Zne,tre,sre,ire,ure,lre,pre,fre,gre,yre,Ire,Cre,_re,Are,Fre,Ore,Bre,Gre,UQ,jre,Wte,Xre,Jre,tse,jQ,ase,cse,dse,mse,yse,Ise,Cse,Ese,Fse,Ose,Lse,Vse,Gse,jse,Yse,Jse,eae,nae,sae,uae,pae,gae,Sae,XQ,_ae,Dae,Rae,Mae,Cte,Bae,Vae,Gae,qae,Zae,KQ,Qae,toe,roe,aoe,ooe,Tte,xae,coe,hoe,boe,ZQ,woe,Soe,_oe,Doe,Poe,Moe,Boe,Uoe,joe,Xoe,Joe,tie,aie,uie,pie,mie,hte,Iae,yie,xie,Iie,Sie,Tie,_ie,Aie,$ie,Rie,Mie,zie,Wie,Uie,jie,Kie,Yie,Jie,wae,see,tue,sue,oue,cue,hue,gue,aee,yue,xue,kue,Wae];for(let e of Sue)op(e);var et;(function(e){e[e.float32=0]="float32",e[e.int32=1]="int32",e[e.bool=2]="bool",e[e.string=3]="string",e[e.complex64=4]="complex64"})(et||(et={}));var Od;(function(e){e[e.linear=0]="linear",e[e.relu=1]="relu",e[e.relu6=2]="relu6",e[e.prelu=3]="prelu",e[e.leakyrelu=4]="leakyrelu",e[e.sigmoid=5]="sigmoid",e[e.elu=6]="elu"})(Od||(Od={}));var rD;function Cue(e){rD=e.wasm.cwrap(co,null,["number","array","number","number","array","number","number","number","number","number","number","number","number"])}function Tue(e){let{inputs:t,backend:n,attrs:r}=e,{a:s,b:a,bias:o,preluActivationWeights:i}=t;if(s.dtype!=="float32"||a.dtype!=="float32")throw new Error("_FusedMatMul for non non-float32 tensors not yet supported.");let{transposeA:u,transposeB:c,activation:l,leakyreluAlpha:p}=r,d=n.dataIdMap.get(s.dataId).id,h=n.dataIdMap.get(a.dataId).id,f=0;if(o!=null){let E=n.dataIdMap.get(o.dataId);if(E.shape.length!==1)throw new Error(`_FusedMatMul only supports rank-1 bias but got rank ${E.shape.length}.`);f=E.id}let g=i==null?0:n.dataIdMap.get(i.dataId).id,m=Od[l];if(m==null)throw new Error(`${l} activation not yet supported for FusedConv2D in the wasm backend.`);let b=u?s.shape[2]:s.shape[1],v=c?a.shape[1]:a.shape[2],y=dl.assertAndGetBroadcastShape(s.shape.slice(0,-2),a.shape.slice(0,-2)),x=n.makeOutput([...y,b,v],s.dtype),k=n.dataIdMap.get(x.dataId).id,S=new Uint8Array(new Int32Array(s.shape).buffer),N=new Uint8Array(new Int32Array(a.shape).buffer);return rD(d,S,s.shape.length,h,N,a.shape.length,u,c,m,f,g,p||0,k),x}var Nue={kernelName:co,backendName:"wasm",setupFunc:Cue,kernelFunc:Tue};function Xe(e,t){let n;function r(a){n=a.wasm.cwrap(e,null,["number","number","number"])}function s(a){let{backend:o,inputs:{x:i}}=a,u=o.dataIdMap.get(i.dataId).id,c=o.makeOutput(i.shape,t||i.dtype),l=o.dataIdMap.get(c.dataId).id;return w.sizeFromShape(c.shape)===0||n(u,et[i.dtype],l),c}return{kernelName:e,backendName:"wasm",setupFunc:r,kernelFunc:s}}var _ue=Xe(cc),Eue=Xe(Eo),Aue=Xe(Ao);function Ht(e,t,n){let r;function s(o){r=o.wasm.cwrap(e,null,["number","array","number","number","array","number","number","number"])}function a(o){let{backend:i,inputs:u}=o,{a:c,b:l}=u,p=i.dataIdMap.get(c.dataId).id,d=i.dataIdMap.get(l.dataId).id,h=n??c.dtype,f=T.assertAndGetBroadcastShape(c.shape,l.shape),g=i.makeOutput(f,h);if(w.sizeFromShape(f)===0)return g;let m=new Uint8Array(new Int32Array(c.shape).buffer),b=new Uint8Array(new Int32Array(l.shape).buffer),v=i.dataIdMap.get(g.dataId).id;return(()=>r(p,m,c.shape.length,d,b,l.shape.length,et[c.dtype],v))(),g}return{kernelName:e,backendName:"wasm",setupFunc:s,kernelFunc:a}}var Due=!0,$ue=Ht(Sa,Due),sD;function Fue(e){sD=e.wasm.cwrap(Do,null,["array","number","number","number"])}function Rue(e){let{inputs:t,backend:n}=e,r=n.makeOutput(t[0].shape,t[0].dtype);if(w.sizeFromShape(r.shape)===0)return r;let s=t.map(i=>n.dataIdMap.get(i.dataId).id),a=new Uint8Array(new Int32Array(s).buffer),o=n.dataIdMap.get(r.dataId).id;return sD(a,s.length,et[r.dtype],o),r}var Pue={kernelName:Do,backendName:"wasm",setupFunc:Fue,kernelFunc:Rue};function og(e){let{inputs:{x:t},backend:n}=e;if(t.dtype==="string")return yn(n.readSync(t.dataId),t.shape,t.dtype);let r=n.makeOutput(t.shape,t.dtype),s=n.typedArrayFromHeap(t);return n.typedArrayFromHeap(r).set(s),r}var Oue={kernelName:si,backendName:"wasm",kernelFunc:og},aD;function Mue(e){aD=e.wasm.cwrap($s,null,["number","array","number","number","number","array","number"])}function Ia(e){let{inputs:t,backend:n,attrs:r}=e,[s,a]=zue(t.x.shape,r.perm),o=!0;for(let f=0;f<a.length;f++)a[f]!==f&&(o=!1);let i=Lue(t.x.shape,r.perm),u={dataId:t.x.dataId,shape:s,dtype:t.x.dtype};if(o){let f=og({inputs:t,backend:n});return f.shape=i,f}let c=n.makeOutput(i,u.dtype),l=n.dataIdMap.get(u.dataId).id,p=n.dataIdMap.get(c.dataId).id,d=new Uint8Array(new Int32Array(a).buffer),h=new Uint8Array(new Int32Array(u.shape).buffer);return aD(l,h,u.shape.length,et[u.dtype],p,d,a.length),c}function Lue(e,t){let n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];return n}function zue(e,t){let n=[],r=[];for(let s=0;s<e.length;++s)e[s]!==1&&n.push(e[s]),e[t[s]]!==1&&r.push(t[s]);for(let s=0;s<r.length;++s){let a=-1;for(let o=0;o<r.length;++o)r[o]>=s&&(a===-1||r[a]>r[o])&&(a=o);r[a]=s}return[n,r]}var Bue={kernelName:$s,backendName:"wasm",kernelFunc:Ia,setupFunc:Mue};function Ma(e,t,n){let r=e.shape,s=e.shape.length,a=w.parseAxisParam(t,r),o=a,i=T.getAxesPermutation(o,s),u=null,c=!1;if(i!=null){let l=new Array(s);for(let h=0;h<l.length;h++)l[h]=r[i[h]];o=T.getInnerMostAxes(o.length,s),u=Ia({inputs:{x:e},attrs:{perm:i},backend:n});let p=n.dataIdMap.get(e.dataId).id;n.dataIdMap.get(u.dataId).id!==p&&(c=!0)}return{transposed:u,originalAxes:a,axes:o,inputWasTransposed:c}}var oD;function Wue(e){oD=e.wasm.cwrap(lc,null,["number, number, number"])}function Vue(e){let{backend:t,inputs:n,attrs:r}=e,{axis:s,keepDims:a}=r,{x:o}=n,u=t.dataIdMap.get(o.dataId).id,c=o,{transposed:l,axes:p,originalAxes:d,inputWasTransposed:h}=Ma(o,s,t);if(h){let y=t.dataIdMap.get(l.dataId).id;c=l,u=y}let f=c.shape.length;T.assertAxesAreInnerMostDims("all",p,f);let[g,m]=T.computeOutAndReduceShapes(c.shape,p),b=w.sizeFromShape(m),v=t.makeOutput(g,o.dtype);if(w.sizeFromShape(c.shape)!==0){let y=t.dataIdMap.get(v.dataId).id;oD(u,b,y)}if(h&&t.disposeData(l.dataId),a){let y=T.expandShapeToKeepDim(v.shape,d);v.shape=y}return v}var Uue={kernelName:lc,backendName:"wasm",setupFunc:Wue,kernelFunc:Vue},iD;function Gue(e){iD=e.wasm.cwrap(dc,null,["number, number, number"])}function Hue(e){let{backend:t,inputs:n,attrs:r}=e,{axis:s,keepDims:a}=r,{x:o}=n,u=t.dataIdMap.get(o.dataId).id,c=o,{transposed:l,axes:p,originalAxes:d,inputWasTransposed:h}=Ma(o,s,t);if(h){let y=t.dataIdMap.get(l.dataId).id;c=l,u=y}let f=c.shape.length;T.assertAxesAreInnerMostDims("any",p,f);let[g,m]=T.computeOutAndReduceShapes(c.shape,p),b=w.sizeFromShape(m),v=t.makeOutput(g,o.dtype);if(w.sizeFromShape(c.shape)!==0){let y=t.dataIdMap.get(v.dataId).id;iD(u,b,y)}if(h&&t.disposeData(l.dataId),a){let y=T.expandShapeToKeepDim(v.shape,d);v.shape=y}return v}var jue={kernelName:dc,backendName:"wasm",setupFunc:Gue,kernelFunc:Hue};function uD(e){let t;function n(s){t=s.wasm.cwrap(e,null,["number","number","number","number","number"])}function r(s){let{backend:a,inputs:o,attrs:i}=s,{axis:u}=i,{x:c}=o,l=a.dataIdMap.get(c.dataId).id,p=l,d=c,{transposed:h,axes:f,inputWasTransposed:g}=Ma(c,u,a);if(g){let k=a.dataIdMap.get(h.dataId).id;k!==l&&(d=h,p=k)}let m=d.shape.slice(0,-1),b=a.makeOutput(m,"int32"),v=a.dataIdMap.get(b.dataId).id,y=w.sizeFromShape(b.shape),x=d.shape[f[0]];return t(p,et[d.dtype],y,x,v),g&&a.disposeData(h.dataId),b}return{kernelName:e,backendName:"wasm",setupFunc:n,kernelFunc:r}}var que=uD(pc),Kue=uD(hc),Xue=Xe($o),Yue=Xe(Fo),Zue=Xe(Ro),Jue=Ht(Oo,!1),Que=Xe(Po),cD;function ece(e){cD=e.wasm.cwrap(Mo,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function tce(e){let{inputs:t,attrs:n,backend:r}=e,s=t.x,a=r.dataIdMap.get(s.dataId).id,{filterSize:o,strides:i,pad:u,dimRoundingMode:c}=n,l=T.computePool2DInfo(s.shape,o,i,1,u,c),p=l.filterHeight,d=l.filterWidth,h=l.padInfo.top,f=l.padInfo.right,g=l.padInfo.bottom,m=l.padInfo.left,b=l.strideHeight,v=l.strideWidth,y=l.inChannels;if(l.dataFormat!=="channelsLast")throw new Error(`wasm backend does not support dataFormat:'${l.dataFormat}'. Please use 'channelsLast'.`);if(l.dilationWidth!==1||l.dilationHeight!==1)throw new Error(`was backend only supports average pooling with dilation = [1, 1], got [${l.dilationHeight}, ${l.dilationWidth}].`);let x=r.makeOutput(l.outShape,"float32"),k=r.dataIdMap.get(x.dataId).id;return cD(a,s.shape[0],s.shape[1],s.shape[2],p,d,h,f,g,m,b,v,y,k),x}var nce={kernelName:Mo,backendName:"wasm",setupFunc:ece,kernelFunc:tce},lD;function rce(e){lD=e.wasm.cwrap("AvgPool3D",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function sce(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:o,pad:i,dimRoundingMode:u,dataFormat:c}=r,l=T.computePool3DInfo(s.shape,a,o,1,i,u,c),p=n.makeOutput(l.outShape,s.dtype);return lD(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(p.dataId).id,l.batchSize,l.inChannels,l.inDepth,l.inHeight,l.inWidth,l.outDepth,l.outHeight,l.outWidth,l.strideDepth,l.strideHeight,l.strideWidth,l.dilationDepth,l.dilationHeight,l.dilationWidth,l.effectiveFilterDepth,l.effectiveFilterHeight,l.effectiveFilterWidth,l.padInfo.front,l.padInfo.top,l.padInfo.left),p}var ace={kernelName:fc,backendName:"wasm",setupFunc:rce,kernelFunc:sce},dD;function oce(e){dD=e.wasm.cwrap("AvgPool3DGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function ice(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,{filterSize:o,strides:i,pad:u,dimRoundingMode:c}=r,l=T.computePool3DInfo(a.shape,o,i,1,u,c),p=n.makeOutput(a.shape,a.dtype);return dD(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(p.dataId).id,l.batchSize,l.inChannels,l.inDepth,l.inHeight,l.inWidth,l.outDepth,l.outHeight,l.outWidth,l.strideDepth,l.strideHeight,l.strideWidth,l.dilationDepth,l.dilationHeight,l.dilationWidth,l.effectiveFilterDepth,l.effectiveFilterHeight,l.effectiveFilterWidth,l.padInfo.front,l.padInfo.top,l.padInfo.left,l.filterDepth,l.filterHeight,l.filterWidth),p}var uce={kernelName:Bd,backendName:"wasm",setupFunc:oce,kernelFunc:ice},pD;function cce(e){pD=e.wasm.cwrap("AvgPoolGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function lce(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,{filterSize:o,strides:i,pad:u}=r,c=T.computePool2DInfo(a.shape,o,i,1,u),l=n.makeOutput(a.shape,a.dtype);return pD(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(l.dataId).id,c.batchSize,c.inChannels,c.inHeight,c.inWidth,c.outHeight,c.outWidth,c.strideHeight,c.strideWidth,c.dilationHeight,c.dilationWidth,c.effectiveFilterHeight,c.effectiveFilterWidth,c.padInfo.top,c.padInfo.left,c.filterHeight,c.filterWidth),l}var dce={kernelName:zd,backendName:"wasm",setupFunc:cce,kernelFunc:lce};function Bn(e){let{inputs:t,attrs:n}=e,{x:r}=t,{shape:s}=n,a=w.sizeFromShape(r.shape),o=w.inferFromImplicitShape(s,a);return w.assert(a===w.sizeFromShape(o),()=>`new shape: ${o}, old shape: ${r.shape}. New shape and old shape must have the same number of elements.`),e.backend.incRef(r.dataId),{dataId:r.dataId,shape:o,dtype:r.dtype}}var pce={kernelName:qc,backendName:"wasm",kernelFunc:Bn},hD;function hce(e){hD=e.wasm.cwrap(Lo,null,["number","array","number","number","array","number","number","number","number"])}function fce(e){let{inputs:t,backend:n,attrs:r}=e,{a:s,b:a}=t,{transposeA:o,transposeB:i}=r;if(s.dtype!=="float32"||a.dtype!=="float32")throw new Error("BatchMatMul for non non-float32 tensors not yet supported.");let u=s.shape.length,c=a.shape.length,l=o?s.shape[u-2]:s.shape[u-1],p=i?a.shape[c-1]:a.shape[c-2],d=o?s.shape[u-1]:s.shape[u-2],h=i?a.shape[c-2]:a.shape[c-1],f=s.shape.slice(0,-2),g=a.shape.slice(0,-2),m=w.sizeFromShape(f),b=w.sizeFromShape(g),y=dl.assertAndGetBroadcastShape(s.shape.slice(0,-2),a.shape.slice(0,-2)).concat([d,h]);w.assert(l===p,()=>`Error in matMul: inner shapes (${l}) and (${p}) of Tensors with shapes ${s.shape} and ${a.shape} and transposeA=${o} and transposeB=${i} must match.`);let x=o?[m,l,d]:[m,d,l],k=i?[b,h,p]:[b,p,h],S=Bn({inputs:{x:s},backend:n,attrs:{shape:x}}),N=Bn({inputs:{x:a},backend:n,attrs:{shape:k}}),E=n.dataIdMap.get(S.dataId).id,$=n.dataIdMap.get(N.dataId).id,R=o?S.shape[2]:S.shape[1],D=i?N.shape[1]:N.shape[2],F=Math.max(m,b),C=n.makeOutput([F,R,D],S.dtype),L=n.dataIdMap.get(C.dataId).id,U=new Uint8Array(new Int32Array(S.shape).buffer),H=new Uint8Array(new Int32Array(N.shape).buffer);return hD(E,U,S.shape.length,$,H,N.shape.length,o,i,L),n.disposeData(S.dataId),n.disposeData(N.dataId),C.shape=y,C}var mce={kernelName:Lo,backendName:"wasm",setupFunc:hce,kernelFunc:fce};function No(e){let{inputs:{x:t},attrs:{begin:n,size:r},backend:s}=e,[a,o]=Yt.parseSliceParams(t,n,r),i=Yt.isSliceContinous(t.shape,a,o),u=s.readSync(t.dataId),c=s.makeOutput(o,t.dtype),l=w.computeStrides(t.shape),p=s.dataIdMap.get(c.dataId);if(i){let f=Yt.computeFlatOffset(a,l);return t.dtype==="string"?p.stringBytes=u.slice(f,f+w.sizeFromShape(o)):s.typedArrayFromHeap(c).set(u.subarray(f,f+w.sizeFromShape(o))),c}if(t.dtype==="string"){let f=_f(u,a,o,t.shape,t.dtype);return p.stringBytes=f,c}let d=s.typedArrayFromHeap(c),h=t.shape.length;if(h===2)gce(u,l[0],d,a,o);else if(h===3)bce(u,l[0],l[1],d,a,o);else if(h===4)yce(u,l[0],l[1],l[2],d,a,o);else{let f=_f(u,a,o,t.shape,t.dtype);d.set(f)}return c}function gce(e,t,n,r,s){let a=0,o=r[0],i=r[1],u=o+s[0];for(let c=o;c<u;c++){let l=c*t+i;n.set(e.subarray(l,l+s[1]),a),a+=s[1]}}function bce(e,t,n,r,s,a){let o=0,i=s[0],u=s[1],c=s[2],l=i+a[0],p=u+a[1];for(let d=i;d<l;d++)for(let h=u;h<p;h++){let f=d*t+h*n+c;r.set(e.subarray(f,f+a[2]),o),o+=a[2]}}function yce(e,t,n,r,s,a,o){let i=0,u=a[0],c=a[1],l=a[2],p=u+o[0],d=c+o[1],h=l+o[2],f=a[3];for(let g=u;g<p;g++)for(let m=c;m<d;m++)for(let b=l;b<h;b++){let v=g*t+m*n+b*r+f;s.set(e.subarray(v,v+o[3]),i),i+=o[3]}}var vce={kernelName:el,backendName:"wasm",kernelFunc:No};function xce(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,crops:o}=r,i=a.reduce((b,v)=>b*v),u=T.getReshaped(s.shape,a,i),c=T.getPermuted(u.length,a.length),l=T.getReshapedPermuted(s.shape,a,i),p=T.getSliceBeginCoords(o,a.length),d=T.getSliceSize(l,o,a.length),h=Bn({inputs:{x:s},backend:n,attrs:{shape:u}}),f=Ia({inputs:{x:h},backend:n,attrs:{perm:c}}),g=Bn({inputs:{x:f},backend:n,attrs:{shape:l}}),m=No({inputs:{x:g},backend:n,attrs:{begin:p,size:d}});return n.disposeData(h.dataId),n.disposeData(f.dataId),n.disposeData(h.dataId),m}var wce={kernelName:mc,backendName:"wasm",kernelFunc:xce},fD;function Ice(e){fD=e.wasm.cwrap(gc,null,["number","number","boolean","number","number","number"])}function kce(e){let{backend:t,inputs:n,attrs:r}=e,{x:s,weights:a}=n,{size:o}=r,i=a.shape.reduce((p,d)=>p*d,1)!==0,u=s.shape.length===1?[o]:[s.shape[0],o],c=t.makeOutput(u,a.dtype);function l(p){return t.dataIdMap.get(p.dataId).id}return fD(l(s),o,i,l(a),et[a.dtype],l(c)),c}var Sce={kernelName:gc,backendName:"wasm",setupFunc:Ice,kernelFunc:kce},Cce=!0,Tce=Ht(bc,Cce);function Nce(e){let{inputs:t,backend:n}=e,{s0:r,s1:s}=t,a=n.typedArrayFromHeap(r),o=n.typedArrayFromHeap(s),i=T.assertAndGetBroadcastShape(Array.from(a),Array.from(o));return n.makeOutput([i.length],"int32",void 0,new Int32Array(i))}var _ce={kernelName:Wd,backendName:"wasm",kernelFunc:Nce};function La(e){let{inputs:{x:t},attrs:{dtype:n},backend:r}=e,s=r.makeOutput(t.shape,n),a=r.typedArrayFromHeap(t);return r.typedArrayFromHeap(s).set(a),s}var Ece={kernelName:zo,backendName:"wasm",kernelFunc:La},Ace=Xe(Bo),mD;function Dce(e){mD=e.wasm.cwrap(Ca,null,["number","number","number","number"])}function $ce(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{clipValueMin:a,clipValueMax:o}=r,i=n.dataIdMap.get(s.dataId).id,u=n.makeOutput(s.shape,s.dtype),c=n.dataIdMap.get(u.dataId).id;return mD(i,a,o,c),u}var Fce={kernelName:Ca,backendName:"wasm",setupFunc:Dce,kernelFunc:$ce};function gD(e){let{inputs:t,backend:n}=e,r=w.parseAxisParam(e.attrs.axis,t[0].shape)[0],s=t.map(h=>h.shape);T.assertParamsConsistent(s,r);let a=T.computeOutShape(t.map(h=>h.shape),r),o=t.filter(h=>w.sizeFromShape(h.shape)>0);if(o.length===1)return og({inputs:{x:o[0]},backend:n});let i=n.makeOutput(a,t[0].dtype);if(w.sizeFromShape(a)===0)return i;if(o[0].dtype==="string"){let h=o.map(y=>{let k=[-1,w.sizeFromShape(y.shape.slice(r))];return Bn({inputs:{x:y},backend:n,attrs:{shape:k}})}),f=h.map(y=>({vals:n.readSync(y.dataId),shape:y.shape}));a=T.computeOutShape(h.map(y=>y.shape),1);let g=h[0].shape[0]===1,m=Bk(f,a,t[0].dtype,g),b=T.computeOutShape(o.map(y=>y.shape),r);i.shape=b;let v=n.dataIdMap.get(i.dataId);return v.stringBytes=T.fromStringArrayToUint8(m),h.forEach(y=>n.disposeData(y.dataId)),i}let u=w.sizeFromShape(o[0].shape.slice(0,r)),c=0,l=o.map(h=>{let f=w.sizeFromShape(h.shape.slice(r));return c+=f,f}),p=o.map(h=>n.typedArrayFromHeap(h)),d=n.typedArrayFromHeap(i);for(let h=0;h<u;h++){let f=h*c;for(let g=0;g<p.length;g++){let m=l[g],b=h*m,v=p[g].subarray(b,b+m);d.set(v,f),f+=m}}return i}var Rce={kernelName:yc,backendName:"wasm",kernelFunc:gD},bD;function Pce(e){bD=e.wasm.cwrap(Wo,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Oce(e){let{inputs:t,attrs:n,backend:r}=e,{x:s,filter:a}=t,o=r.dataIdMap.get(s.dataId).id,i=r.dataIdMap.get(a.dataId).id,{strides:u,dilations:c,pad:l,dimRoundingMode:p,dataFormat:d}=n,h=T.convertConv2DDataFormat(d),f=T.computeConv2DInfo(s.shape,a.shape,u,c,l,p,!1,h),g=f.filterHeight,m=f.filterWidth,b=f.padInfo.top,v=f.padInfo.right,y=f.padInfo.bottom,x=f.padInfo.left,k=f.dilationHeight,S=f.dilationWidth,N=f.strideHeight,E=f.strideWidth,$=f.inChannels,R=f.outChannels,D=f.padInfo.type==="SAME"?1:0;if(f.dataFormat!=="channelsLast")throw new Error(`wasm backend Conv2D does not support dataFormat:'${f.dataFormat}'. Please use 'channelsLast'.`);let F=r.makeOutput(f.outShape,"float32"),C=r.dataIdMap.get(F.dataId).id;return bD(o,s.shape[0],s.shape[1],s.shape[2],i,g,m,b,v,y,x,D,k,S,N,E,$,R,C),F}var Mce={kernelName:Wo,backendName:"wasm",setupFunc:Pce,kernelFunc:Oce},yD;function Lce(e){yD=e.wasm.cwrap(Vo,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function zce(e){let{backend:t,inputs:n,attrs:r}=e,{dy:s,filter:a}=n,{strides:o,pad:i,dataFormat:u,dimRoundingMode:c,inputShape:l}=r,p=1,d=T.convertConv2DDataFormat(u),h=T.computeConv2DInfo(l,a.shape,o,p,i,c,!1,d),{batchSize:f,filterHeight:g,filterWidth:m,inChannels:b,inHeight:v,inWidth:y,outChannels:x,outHeight:k,outWidth:S,strideHeight:N,strideWidth:E}=h,$=g-1-h.padInfo.top,R=m-1-h.padInfo.left,D=h.dataFormat==="channelsLast",F=w.computeStrides(h.inShape),C=w.computeStrides(s.shape),[L,U,H]=w.computeStrides(a.shape),K=F[0],q=D?F[1]:F[2],Z=D?F[2]:1,J=D?1:F[1],ee=C[0],se=D?C[1]:C[2],te=D?C[2]:1,oe=D?1:C[1],ne=t.makeOutput(h.inShape,"float32"),le=t.dataIdMap.get(ne.dataId).id,ce=t.dataIdMap.get(s.dataId).id,we=t.dataIdMap.get(a.dataId).id;return yD(ce,we,f,g,m,v,y,b,k,S,x,N,E,$,R,L,U,H,K,q,Z,J,ee,se,te,oe,le),ne}var Bce={kernelName:Vo,backendName:"wasm",setupFunc:Lce,kernelFunc:zce},vD;function Wce(e){vD=e.wasm.cwrap(Uo,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Vce(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:o,pad:i,dilations:u}=r;if(s.dtype!=="float32")throw new Error(`Tensor x must have dtype float32, got ${s.dtype}`);if(a.dtype!=="float32")throw new Error(`Tensor filter must have dtype float32, got ${a.dtype}`);let c=T.computeConv3DInfo(s.shape,a.shape,o,u,i),l=n.makeOutput(c.outShape,s.dtype);return vD(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(l.dataId).id,c.batchSize,c.inDepth,c.inHeight,c.inWidth,c.inChannels,c.outDepth,c.outHeight,c.outWidth,c.outChannels,c.strideDepth,c.strideHeight,c.strideWidth,c.dilationDepth,c.dilationHeight,c.dilationWidth,c.filterDepth,c.filterHeight,c.filterWidth,c.padInfo.front,c.padInfo.top,c.padInfo.left),l}var Uce={kernelName:Uo,backendName:"wasm",setupFunc:Wce,kernelFunc:Vce},xD;function Gce(e){xD=e.wasm.cwrap(vc,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Hce(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:o,pad:i,filterShape:u}=r;if(s.dtype!=="float32")throw new Error(`Tensor dy must have dtype float32, got ${s.dtype}`);if(a.dtype!=="float32")throw new Error(`Tensor filter must have dtype float32, got ${a.dtype}`);let c=T.computeConv3DInfo(s.shape,u,o,1,i),l=n.makeOutput(c.filterShape,a.dtype);return xD(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(l.dataId).id,c.batchSize,c.inDepth,c.inHeight,c.inWidth,c.inChannels,c.outDepth,c.outHeight,c.outWidth,c.outChannels,c.strideDepth,c.strideHeight,c.strideWidth,c.dilationDepth,c.dilationHeight,c.dilationWidth,c.filterDepth,c.filterHeight,c.filterWidth,c.padInfo.front,c.padInfo.top,c.padInfo.left),l}var jce={kernelName:vc,backendName:"wasm",setupFunc:Gce,kernelFunc:Hce},wD;function qce(e){wD=e.wasm.cwrap(xc,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Kce(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{pad:o,strides:i,inputShape:u}=r;if(s.dtype!=="float32")throw new Error(`Tensor dy must have dtype float32, got ${s.dtype}`);if(a.dtype!=="float32")throw new Error(`Tensor filter must have dtype float32, got ${a.dtype}`);let c=T.computeConv3DInfo(u,a.shape,i,1,o),l=n.makeOutput(c.inShape,s.dtype);return wD(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(l.dataId).id,c.batchSize,c.inDepth,c.inHeight,c.inWidth,c.inChannels,c.outDepth,c.outHeight,c.outWidth,c.outChannels,c.strideDepth,c.strideHeight,c.strideWidth,c.dilationDepth,c.dilationHeight,c.dilationWidth,c.filterDepth,c.filterHeight,c.filterWidth,c.padInfo.front,c.padInfo.top,c.padInfo.left),l}var Xce={kernelName:xc,backendName:"wasm",setupFunc:qce,kernelFunc:Kce},Yce=Xe(Go),Zce=Xe(Ho),wx;(function(e){e[e.bilinear=0]="bilinear",e[e.nearest=1]="nearest"})(wx||(wx={}));var ID;function Jce(e){ID=e.wasm.cwrap(Ic,null,["number","number","number","number","array","number","number","number","number","number"])}function Qce(e){let{backend:t,inputs:n,attrs:r}=e,{method:s,extrapolationValue:a,cropSize:o}=r,{image:i,boxes:u,boxInd:c}=n,l=u.shape[0],[p,d]=o,h=[l,p,d,i.shape[3]],f=t.dataIdMap.get(i.dataId),g;i.dtype!=="float32"&&(g=La({backend:t,inputs:{x:i},attrs:{dtype:"float32"}}),f=t.dataIdMap.get(g.dataId));let m=f.id,b=t.dataIdMap.get(u.dataId).id,v=t.dataIdMap.get(c.dataId).id,y=t.makeOutput(h,"float32"),x=t.dataIdMap.get(y.dataId).id,k=new Uint8Array(new Int32Array(i.shape).buffer);return ID(m,b,v,l,k,p,d,wx[s],a,x),g!=null&&t.disposeData(g.dataId),y}var ele={kernelName:Ic,backendName:"wasm",setupFunc:Jce,kernelFunc:Qce},kD;function tle(e){kD=e.wasm.cwrap(wc,null,["number","number","number","number","number","number"])}function nle(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:o,reverse:i}=r,u=s.shape.length;w.assert(s.dtype==="float32"||s.dtype==="int32",()=>`cumprod does not support ${s.dtype} tensors in the WASM backend`);let c=T.getAxesPermutation([a],u),l=s;c!==null&&(l=Ia({inputs:{x:s},attrs:{perm:c},backend:n}));let p=T.getInnerMostAxes(1,u)[0];T.assertAxesAreInnerMostDims("cumprod",[p],u);let d=n.makeOutput(l.shape,l.dtype),h=l.shape[p],f=n.dataIdMap.get(l.dataId).id,g=n.dataIdMap.get(d.dataId).id;kD(f,o?1:0,i?1:0,h,g,et[s.dtype]);let m=d;if(c!==null){let b=T.getUndoAxesPermutation(c);m=Ia({inputs:{x:d},attrs:{perm:b},backend:n}),n.disposeData(l.dataId),n.disposeData(d.dataId)}return m}var rle={kernelName:wc,backendName:"wasm",setupFunc:tle,kernelFunc:nle},SD;function sle(e){SD=e.wasm.cwrap(jo,null,["number","number","number","number","number","number"])}function ale(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:o,reverse:i}=r,u=s.shape.length;w.assert(s.dtype==="float32"||s.dtype==="int32",()=>`cumsum does not support ${s.dtype} tensors in the WASM backend`);let c=T.getAxesPermutation([a],u),l=s;c!==null&&(l=Ia({inputs:{x:s},attrs:{perm:c},backend:n}));let p=T.getInnerMostAxes(1,u)[0];T.assertAxesAreInnerMostDims("cumsum",[p],u);let d=n.makeOutput(l.shape,l.dtype),h=l.shape[p],f=n.dataIdMap.get(l.dataId).id,g=n.dataIdMap.get(d.dataId).id;SD(f,o?1:0,i?1:0,h,g,et[s.dtype]);let m=d;if(c!==null){let b=T.getUndoAxesPermutation(c);m=Ia({inputs:{x:d},attrs:{perm:b},backend:n}),n.disposeData(l.dataId),n.disposeData(d.dataId)}return m}var ole={kernelName:jo,backendName:"wasm",setupFunc:sle,kernelFunc:ale},CD;function ile(e){CD=e.wasm.cwrap("DenseBincount",null,["number","array","number","number","boolean","number","number","boolean","number"])}function ule(e){let{backend:t,inputs:n,attrs:r}=e,{x:s,weights:a}=n,{size:o,binaryOutput:i}=r,u=a.shape.reduce((d,h)=>d*h,1)!==0,c=s.shape.length===1?[o]:[s.shape[0],o],l=t.makeOutput(c,a.dtype);function p(d){return t.dataIdMap.get(d.dataId).id}return CD(p(s),new Uint8Array(new Int32Array(s.shape).buffer),s.shape.length,o,u,p(a),et[a.dtype],i,p(l)),l}var cle={kernelName:Ud,backendName:"wasm",setupFunc:ile,kernelFunc:ule},TD;function lle(e){TD=e.wasm.cwrap(kc,null,["number","number","number","array","number","array","array","number","number"])}function dle(e){let{backend:t,inputs:n,attrs:r}=e,{x:s}=n,{blockSize:a,dataFormat:o}=r,i=s.shape[0],u=o==="NHWC"?s.shape[1]:s.shape[2],c=o==="NHWC"?s.shape[2]:s.shape[3],l=o==="NHWC"?s.shape[3]:s.shape[1],p=u*a,d=c*a,h=l/(a*a),f=o==="NHWC"?[i,p,d,h]:[i,h,p,d],g=t.makeOutput(f,"float32"),b=t.dataIdMap.get(s.dataId).id,v=new Uint8Array(new Int32Array(w.computeStrides(s.shape)).buffer),y=new Uint8Array(new Int32Array(f).buffer),x=new Uint8Array(new Int32Array(w.computeStrides(f)).buffer),k=t.dataIdMap.get(g.dataId).id;return TD(b,a,o==="NHWC"?1:0,v,s.shape.length-1,y,x,f.length,k),g}var ple={kernelName:kc,backendName:"wasm",setupFunc:lle,kernelFunc:dle},ND;function hle(e){ND=e.wasm.cwrap(qo,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function fle(e){let{inputs:t,attrs:n,backend:r}=e,{x:s,filter:a}=t,o=r.dataIdMap.get(s.dataId).id,i=r.dataIdMap.get(a.dataId).id,{strides:u,dilations:c,pad:l,dimRoundingMode:p}=n,d=c??[1,1],h=T.computeConv2DInfo(s.shape,a.shape,u,d,l,p,!0),f=h.filterHeight,g=h.filterWidth,m=h.padInfo.top,b=h.padInfo.right,v=h.padInfo.bottom,y=h.padInfo.left,x=h.dilationHeight,k=h.dilationWidth,S=h.strideHeight,N=h.strideWidth,E=h.inChannels,$=h.outChannels,R=h.padInfo.type==="SAME"?1:0;if(h.dataFormat!=="channelsLast")throw new Error(`wasm backend DepthwiseConv2dNative does not support dataFormat:'${h.dataFormat}'. Please use 'channelsLast'.`);let D=r.makeOutput(h.outShape,"float32"),F=r.dataIdMap.get(D.dataId).id;return ND(o,s.shape[0],s.shape[1],s.shape[2],i,f,g,m,b,v,y,R,x,k,S,N,E,$,F),D}var mle={kernelName:qo,backendName:"wasm",setupFunc:hle,kernelFunc:fle},_D;function gle(e){_D=e.wasm.cwrap("Diag",null,["number","number","number","number"])}function ble(e){let{inputs:t,backend:n}=e,{x:r}=t,s=w.sizeFromShape(r.shape),a=n.makeOutput([...r.shape,...r.shape],r.dtype);return _D(n.dataIdMap.get(r.dataId).id,et[r.dtype],s,n.dataIdMap.get(a.dataId).id),a}var yle={kernelName:Gd,backendName:"wasm",setupFunc:gle,kernelFunc:ble},ED;function vle(e){ED=e.wasm.cwrap(Ko,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function xle(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:o,pad:i,dilations:u}=r;if(s.dtype!==a.dtype)throw new Error(`Dilation2D error: x must have the same dtype as filter. Got ${s.dtype} and ${a.dtype}`);let c=T.computeDilation2DInfo(s.shape,a.shape,o,i,"NHWC",u),l=n.makeOutput(c.outShape,s.dtype);return ED(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(l.dataId).id,et[s.dtype],c.batchSize,c.inChannels,c.inHeight,c.inWidth,c.outHeight,c.outWidth,c.strideHeight,c.strideWidth,c.dilationHeight,c.dilationWidth,c.filterHeight,c.filterWidth,c.padInfo.top,c.padInfo.left),l}var wle={kernelName:Ko,backendName:"wasm",setupFunc:vle,kernelFunc:xle},AD;function Ile(e){AD=e.wasm.cwrap(Gu,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function kle(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,dy:o}=t,{strides:i,pad:u,dilations:c}=r;if(s.dtype!==a.dtype||s.dtype!==o.dtype)throw new Error(`Dilation2DBackpropFilter error: x must have the same dtype as filter and dy. Got ${s.dtype}, ${a.dtype}, and ${o.dtype}`);let l=T.computeDilation2DInfo(s.shape,a.shape,i,u,"NHWC",c),p=n.makeOutput(a.shape,a.dtype);return AD(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(o.dataId).id,n.dataIdMap.get(p.dataId).id,et[s.dtype],l.batchSize,l.inChannels,l.inHeight,l.inWidth,l.outHeight,l.outWidth,l.strideHeight,l.strideWidth,l.dilationHeight,l.dilationWidth,l.filterHeight,l.filterWidth,l.padInfo.top,l.padInfo.left),p}var Sle={kernelName:Gu,backendName:"wasm",setupFunc:Ile,kernelFunc:kle},DD;function Cle(e){DD=e.wasm.cwrap(Uu,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Tle(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,dy:o}=t,{strides:i,pad:u,dilations:c}=r;if(s.dtype!==a.dtype||s.dtype!==o.dtype)throw new Error(`Dilation2DBackpropInput error: x must have the same dtype as filter and dy. Got ${s.dtype}, ${a.dtype}, and ${o.dtype}`);let l=T.computeDilation2DInfo(s.shape,a.shape,i,u,"NHWC",c),p=n.makeOutput(s.shape,s.dtype);return DD(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(o.dataId).id,n.dataIdMap.get(p.dataId).id,et[s.dtype],l.batchSize,l.inChannels,l.inHeight,l.inWidth,l.outHeight,l.outWidth,l.strideHeight,l.strideWidth,l.dilationHeight,l.dilationWidth,l.filterHeight,l.filterWidth,l.padInfo.top,l.padInfo.left),p}var Nle={kernelName:Uu,backendName:"wasm",setupFunc:Cle,kernelFunc:Tle},_le=Xe(Yo),$D;function Ele(e){$D=e.wasm.cwrap(Sc,null,["number","number","number"])}function Ale(e){let{inputs:t,backend:n}=e,{dy:r,y:s}=t,a=n.makeOutput(s.shape,"float32"),o=i=>n.dataIdMap.get(i.dataId).id;return $D(o(s),o(r),o(a)),a}var Dle={kernelName:Sc,backendName:"wasm",setupFunc:Ele,kernelFunc:Ale},$le=!1,Fle=Ht(Cc,$le,"bool"),Rle=Xe(Zo),Ple=Xe(Jo,"float32");function Ix(e){let{inputs:t,attrs:n,backend:r}=e,{input:s}=t,{dim:a}=n,o=s.shape.length,i=s.shape.slice(),u=a;return a<0&&(w.assert(-(o+1)<=a,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),u=o+a+1),i.splice(u,0,1),Bn({inputs:{x:s},backend:r,attrs:{shape:i}})}var Ole={kernelName:Tc,backendName:"wasm",kernelFunc:Ix},Mle=Xe(Qo,"float32");function FD(e){let{attrs:{shape:t,value:n,dtype:r},backend:s}=e,a=s.makeOutput(t,r);return s.typedArrayFromHeap(a).fill(n),a}var Lle={kernelName:Hd,backendName:"wasm",kernelFunc:FD},RD;function zle(e){RD=e.wasm.cwrap(Nc,null,["number","number","number","number","number","number"])}function Ble(e){let{inputs:t,backend:n}=e,{image:r}=t,s=n.makeOutput(r.shape,r.dtype),a=n.dataIdMap.get(r.dataId).id,o=n.dataIdMap.get(s.dataId).id,[i,u,c,l]=r.shape;return RD(a,i,u,c,l,o),s}var Wle={kernelName:Nc,backendName:"wasm",kernelFunc:Ble,setupFunc:zle},Vle=Xe(ei),Ule=!1,Gle=Ht(ti,Ule),PD;function Hle(e){PD=e.wasm.cwrap(ni,null,["number","number","number","number","number","number","number"])}function jle(e){let{backend:t,inputs:n,attrs:r}=e,{varianceEpsilon:s}=r,{x:a,mean:o,variance:i,offset:u,scale:c}=n,l=t.dataIdMap.get(a.dataId).id,p=t.dataIdMap.get(o.dataId).id,d=t.dataIdMap.get(i.dataId).id,h=u!=null?t.dataIdMap.get(u.dataId).id:0,f=c!=null?t.dataIdMap.get(c.dataId).id:0,g=t.makeOutput(a.shape,a.dtype);if(w.sizeFromShape(a.shape)===0)return g;let m=t.dataIdMap.get(g.dataId).id;return PD(l,p,d,h,f,s,m),g}var qle={kernelName:ni,backendName:"wasm",setupFunc:Hle,kernelFunc:jle},OD;function Kle(e){OD=e.wasm.cwrap(lo,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Xle(e){let{inputs:t,attrs:n,backend:r}=e,{x:s,filter:a,bias:o,preluActivationWeights:i}=t,{strides:u,pad:c,dilations:l,dataFormat:p,dimRoundingMode:d,activation:h,leakyreluAlpha:f}=n,g=T.computeConv2DInfo(s.shape,a.shape,u,l,c,d),m=Od[h];if(m==null)throw new Error(`${h} activation not yet supported for FusedConv2D in the wasm backend.`);let b=r.dataIdMap.get(s.dataId).id,v=r.dataIdMap.get(a.dataId).id,y=g.outChannels,x=0;if(o!=null){let te=r.dataIdMap.get(o.dataId);if(te.shape.length!==1)throw new Error(`FusedConv2D only supports rank-1 bias but got rank ${te.shape.length}.`);if(te.shape[0]!==y)throw new Error(`FusedConv2D bias shape (${te.shape}) does not match the number of output channels (${y})`);x=te.id}let k=g.filterHeight,S=g.filterWidth,N=g.padInfo.top,E=g.padInfo.right,$=g.padInfo.bottom,R=g.padInfo.left,D=g.dilationHeight,F=g.dilationWidth,C=g.strideHeight,L=g.strideWidth,U=g.inChannels,H=g.padInfo.type==="SAME"?1:0,K=g.batchSize,q=g.inHeight,Z=g.inWidth;if(p!=="NHWC")throw new Error(`wasm backend FusedConv2D does not support dataFormat:'${p}'. Please use 'NHWC'.`);let J=r.makeOutput(g.outShape,"float32"),ee=r.dataIdMap.get(J.dataId).id,se=i==null?0:r.dataIdMap.get(i.dataId).id;return OD(b,K,q,Z,v,k,S,x,N,E,$,R,H,D,F,C,L,U,y,m,se,f||0,ee),J}var Yle={kernelName:lo,backendName:"wasm",setupFunc:Kle,kernelFunc:Xle},MD;function Zle(e){MD=e.wasm.cwrap(po,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Jle(e){let{inputs:t,attrs:n,backend:r}=e,{x:s,filter:a,bias:o,preluActivationWeights:i}=t,{strides:u,pad:c,dilations:l,dataFormat:p,dimRoundingMode:d,activation:h,leakyreluAlpha:f}=n,g=T.computeConv2DInfo(s.shape,a.shape,u,l,c,d,!0),m=Od[h];if(m==null)throw new Error(`${h} activation not yet supported for FusedDepthwiseConv2D in the wasm backend.`);let b=r.dataIdMap.get(s.dataId).id,v=r.dataIdMap.get(a.dataId).id,y=g.outChannels,x=0;if(o!=null){let te=r.dataIdMap.get(o.dataId);if(te.shape.length!==1)throw new Error(`FusedDepthwiseConv2D only supports rank-1 bias but got rank ${te.shape.length}.`);if(te.shape[0]!==y)throw new Error(`FusedDepthwiseConv2D bias shape (${te.shape}) does not match the number of output channels (${y})`);x=te.id}let k=g.filterHeight,S=g.filterWidth,N=g.padInfo.top,E=g.padInfo.right,$=g.padInfo.bottom,R=g.padInfo.left,D=g.dilationHeight,F=g.dilationWidth,C=g.strideHeight,L=g.strideWidth,U=g.inChannels,H=g.padInfo.type==="SAME"?1:0,K=g.batchSize,q=g.inHeight,Z=g.inWidth;if(p!=="NHWC")throw new Error(`wasm backend FusedDepthwiseConv2D does not support dataFormat:'${p}'. Please use 'NHWC'.`);let J=r.makeOutput(g.outShape,"float32"),ee=r.dataIdMap.get(J.dataId).id,se=i==null?0:r.dataIdMap.get(i.dataId).id;return MD(b,K,q,Z,v,k,S,x,N,E,$,R,H,D,F,C,L,U,y,m,se,f||0,ee),J}var Qle={kernelName:po,backendName:"wasm",setupFunc:Zle,kernelFunc:Jle},LD;function ede(e){LD=e.wasm.cwrap(Ec,null,["number","number","number","number","number","number","array","number"])}function tde(e){let{backend:t,inputs:n}=e,{params:r,indices:s}=n,[a,o,i,u]=Qw.prepareAndValidate(r,s),c=t.makeOutput(a,r.dtype);if(o===0)return c;let l=s.shape,p=l[l.length-1],h=t.dataIdMap.get(r.dataId).id,g=t.dataIdMap.get(s.dataId).id,m=new Uint8Array(new Int32Array(u).buffer),b=t.dataIdMap.get(c.dataId).id;return LD(h,et[r.dtype],g,o,p,i,m,b),c}var nde={kernelName:Ec,backendName:"wasm",setupFunc:ede,kernelFunc:tde},zD;function rde(e){zD=e.wasm.cwrap("Gather",null,["number","number","array","number","number","number","array","number"])}function sde(e){let{backend:t,inputs:n,attrs:r}=e,{x:s,indices:a}=n,{axis:o,batchDims:i}=r,u=w.parseAxisParam(o,s.shape)[0],c=t.readSync(a.dataId),l=s.shape[u];for(let $=0;$<c.length;++$){let R=c[$];w.assert(R<=l-1&&R>=0,()=>`GatherV2: the index value ${R} is not in [0, ${l-1}]`)}let p=T.segment_util.collectGatherOpShapeInfo(s,a,u,i),d=Bn({inputs:{x:s},attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]},backend:t}),h=w.sizeFromShape(a.shape),f=Bn({inputs:{x:a},attrs:{shape:[p.batchSize,h/p.batchSize]},backend:t}),g=[p.batchSize,p.outerSize,h/p.batchSize,p.sliceSize],m=t.makeOutput(g,s.dtype);if(w.sizeFromShape(s.shape)===0)return m;let b=d.shape.length-1,y=t.dataIdMap.get(d.dataId).id,k=t.dataIdMap.get(f.dataId).id,S=t.dataIdMap.get(m.dataId).id,N=new Uint8Array(new Int32Array(w.computeStrides(d.shape)).buffer),E=new Uint8Array(new Int32Array(w.computeStrides(g)).buffer);return zD(y,et[s.dtype],N,b,k,p.batchSize,E,S),t.disposeData(d.dataId),t.disposeData(f.dataId),m.shape=p.outputShape,m}var ade={kernelName:_c,backendName:"wasm",setupFunc:rde,kernelFunc:sde},ode=!1,ide=Ht(Ac,ode,"bool"),ude=!1,cde=Ht(ri,ude,"bool"),lde=Xe(ai,"bool"),dde=Xe(oi,"bool"),pde=Xe(ii,"bool"),BD;function hde(e){BD=e.wasm.cwrap(ui,null,["number","number","number","number"])}function fde(e){let{inputs:{x:t},attrs:{alpha:n},backend:r}=e,s=r.dataIdMap.get(t.dataId).id,a=r.makeOutput(t.shape,"float32");if(w.sizeFromShape(t.shape)!==0){let o=r.dataIdMap.get(a.dataId).id;BD(s,et[t.dtype],n,o)}return a}var mde={kernelName:ui,backendName:"wasm",setupFunc:hde,kernelFunc:fde},gde=!1,bde=Ht(Dc,gde,"bool"),yde=!1,vde=Ht($c,yde,"bool"),WD;function xde(e){WD=e.wasm.cwrap(Fc,null,["number","number","number","number"])}function wde(e){let{attrs:t,backend:n}=e,{start:r,stop:s,num:a}=t,o=Math.floor(a),i=n.makeOutput([o],"float32");return WD(n.dataIdMap.get(i.dataId).id,r,s,o),i}var Ide={kernelName:Fc,backendName:"wasm",setupFunc:xde,kernelFunc:wde},kde=Xe(ci),Sde=Xe(li),Cde=!1,Tde=Ht(Rc,Cde,"bool"),Nde=Xe(Pc),_de=!1,Ede=Ht(Oc,_de,"bool"),Ade=!1,Dde=Ht(cC,Ade,"bool"),VD;function $de(e){VD=e.wasm.cwrap(di,null,["number","number","number","number","number","number","number"])}function Fde(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{depthRadius:a,bias:o,alpha:i,beta:u}=r;if(s.dtype!=="float32")throw new Error("LRN error: x must have dtype float32");let c=n.makeOutput(s.shape,s.dtype);return VD(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(c.dataId).id,s.shape[3],a,o,i,u),c}var Rde={kernelName:di,backendName:"wasm",setupFunc:$de,kernelFunc:Fde},UD;function Pde(e){UD=e.wasm.cwrap(Mc,null,["number","number","number","number","number","number","number","number","number"])}function Ode(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,y:a,dy:o}=t,{depthRadius:i,bias:u,alpha:c,beta:l}=r;if(s.dtype!=="float32"||a.dtype!=="float32"||o.dtype!=="float32")throw new Error("LRNGrad error: x, y, and dy must have dtype float32");let p=n.makeOutput(s.shape,s.dtype);return UD(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(o.dataId).id,n.dataIdMap.get(p.dataId).id,o.shape[3],i,u,c,l),p}var Mde={kernelName:Mc,backendName:"wasm",setupFunc:Pde,kernelFunc:Ode},GD;function Lde(e){GD=e.wasm.cwrap(pi,null,["number","number","number","number"])}function zde(e){let{backend:t,inputs:n,attrs:r}=e,{reductionIndices:s,keepDims:a}=r,{x:o}=n,u=t.dataIdMap.get(o.dataId).id,c=o,{transposed:l,axes:p,originalAxes:d,inputWasTransposed:h}=Ma(o,s,t);if(h){let y=t.dataIdMap.get(l.dataId).id;c=l,u=y}let f=c.shape.length;T.assertAxesAreInnerMostDims("max",p,f);let[g,m]=T.computeOutAndReduceShapes(c.shape,p),b=w.sizeFromShape(m),v=t.makeOutput(g,o.dtype);if(w.sizeFromShape(c.shape)!==0){let y=t.dataIdMap.get(v.dataId).id;GD(u,et[o.dtype],b,y)}if(h&&t.disposeData(l.dataId),a){let y=T.expandShapeToKeepDim(v.shape,d);v.shape=y}return v}var Bde={kernelName:pi,backendName:"wasm",setupFunc:Lde,kernelFunc:zde},Wde=!1,Vde=Ht(hi,Wde),HD;function Ude(e){HD=e.wasm.cwrap(fi,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Gde(e){let{inputs:t,attrs:n,backend:r}=e,s=t.x,a=r.dataIdMap.get(s.dataId).id;w.assert(s.dtype==="float32",()=>`Error in MaxPool: only float32 input is supported. Got ${s.dtype}.`);let{filterSize:o,strides:i,pad:u,dimRoundingMode:c}=n,l=T.computePool2DInfo(s.shape,o,i,1,u,c),p=l.filterHeight,d=l.filterWidth,h=l.padInfo.top,f=l.padInfo.right,g=l.padInfo.bottom,m=l.padInfo.left,b=l.dilationHeight,v=l.dilationWidth,y=l.strideHeight,x=l.strideWidth,k=l.inChannels,S=l.outChannels;if(l.dataFormat!=="channelsLast")throw new Error(`wasm backend does not support dataFormat:'${l.dataFormat}'. Please use 'channelsLast'.`);let N=r.makeOutput(l.outShape,"float32"),E=r.dataIdMap.get(N.dataId).id;return HD(a,s.shape[0],s.shape[1],s.shape[2],p,d,h,f,g,m,b,v,y,x,k,S,E),N}var Hde={kernelName:fi,backendName:"wasm",setupFunc:Ude,kernelFunc:Gde},jD;function jde(e){jD=e.wasm.cwrap("MaxPool3D",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function qde(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:o,pad:i,dimRoundingMode:u,dataFormat:c}=r,l=T.computePool3DInfo(s.shape,a,o,1,i,u,c),p=n.makeOutput(l.outShape,s.dtype);return jD(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(p.dataId).id,l.batchSize,l.inChannels,l.inDepth,l.inHeight,l.inWidth,l.outDepth,l.outHeight,l.outWidth,l.strideDepth,l.strideHeight,l.strideWidth,l.dilationDepth,l.dilationHeight,l.dilationWidth,l.effectiveFilterDepth,l.effectiveFilterHeight,l.effectiveFilterWidth,l.padInfo.front,l.padInfo.top,l.padInfo.left),p}var Kde={kernelName:Lc,backendName:"wasm",setupFunc:jde,kernelFunc:qde},qD;function Xde(e){qD=e.wasm.cwrap("MaxPool3DGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Yde(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,{filterSize:o,strides:i,pad:u,dimRoundingMode:c}=r,l=T.computePool3DInfo(a.shape,o,i,1,u,c),p=n.makeOutput(a.shape,a.dtype);return qD(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(p.dataId).id,l.batchSize,l.inChannels,l.inDepth,l.inHeight,l.inWidth,l.outDepth,l.outHeight,l.outWidth,l.strideDepth,l.strideHeight,l.strideWidth,l.dilationDepth,l.dilationHeight,l.dilationWidth,l.effectiveFilterDepth,l.effectiveFilterHeight,l.effectiveFilterWidth,l.padInfo.front,l.padInfo.top,l.padInfo.left),p}var Zde={kernelName:qd,backendName:"wasm",setupFunc:Xde,kernelFunc:Yde},KD;function Jde(e){KD=e.wasm.cwrap("MaxPoolGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Qde(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,{filterSize:o,strides:i,pad:u,dimRoundingMode:c}=r,l=T.computePool2DInfo(a.shape,o,i,1,u,c),p=n.makeOutput(a.shape,a.dtype);return KD(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(p.dataId).id,l.batchSize,l.inChannels,l.inHeight,l.inWidth,l.outHeight,l.outWidth,l.strideHeight,l.strideWidth,l.dilationHeight,l.dilationWidth,l.effectiveFilterHeight,l.effectiveFilterWidth,l.padInfo.top,l.padInfo.left),p}var epe={kernelName:jd,backendName:"wasm",setupFunc:Jde,kernelFunc:Qde},XD;function tpe(e){XD=e.wasm.cwrap("MaxPoolWithArgmax",null,["number","number","number","number","boolean","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function npe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:o,pad:i,includeBatchInIndex:u}=r;w.assert(s.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${s.shape.length}.`);let c=[1,1];w.assert(T.eitherStridesOrDilationsAreOne(o,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);let l=T.computePool2DInfo(s.shape,a,o,[1,1],i),p=n.makeOutput(l.outShape,s.dtype),d=n.makeOutput(l.outShape,"int32");return XD(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(p.dataId).id,n.dataIdMap.get(d.dataId).id,et[s.dtype],u,l.batchSize,l.inChannels,l.inHeight,l.inWidth,l.outHeight,l.outWidth,l.strideHeight,l.strideWidth,l.dilationHeight,l.dilationWidth,l.effectiveFilterHeight,l.effectiveFilterWidth,l.padInfo.top,l.padInfo.left),[p,d]}var rpe={kernelName:Kd,backendName:"wasm",setupFunc:tpe,kernelFunc:npe},YD;function spe(e){YD=e.wasm.cwrap(mi,null,["number, number, number"])}function ape(e){let{backend:t,inputs:n,attrs:r}=e,{axis:s,keepDims:a}=r,{x:o}=n,i=t.dataIdMap.get(o.dataId).id,u=i,c=o,{transposed:l,axes:p,originalAxes:d,inputWasTransposed:h}=Ma(o,s,t),f=p;if(h){let x=t.dataIdMap.get(l.dataId).id;x!==i&&(c=l,u=x,f=T.getInnerMostAxes(f.length,c.shape.length))}T.assertAxesAreInnerMostDims("mean",f,c.shape.length);let[g,m]=T.computeOutAndReduceShapes(c.shape,f),b=w.sizeFromShape(m),v=c;c.dtype!=="float32"&&(v=La({backend:t,inputs:{x:c},attrs:{dtype:"float32"}}),u=t.dataIdMap.get(v.dataId).id);let y=t.makeOutput(g,"float32");if(w.sizeFromShape(c.shape)!==0){let x=t.dataIdMap.get(y.dataId).id;YD(u,b,x)}if(h&&t.disposeData(l.dataId),a){let x=T.expandShapeToKeepDim(y.shape,d);y.shape=x}return c.dtype!=="float32"&&t.disposeData(v.dataId),y}var ope={kernelName:mi,backendName:"wasm",setupFunc:spe,kernelFunc:ape},ZD;function ipe(e){ZD=e.wasm.cwrap(gi,null,["number","number","number","number"])}function upe(e){let{backend:t,inputs:n,attrs:r}=e,{axis:s,keepDims:a}=r,{x:o}=n,i=t.dataIdMap.get(o.dataId).id,u=i,c=o,{transposed:l,axes:p,originalAxes:d,inputWasTransposed:h}=Ma(o,s,t);if(h){let y=t.dataIdMap.get(l.dataId).id;y!==i&&(c=l,u=y)}let f=c.shape.length;T.assertAxesAreInnerMostDims("min",p,f);let[g,m]=T.computeOutAndReduceShapes(c.shape,p),b=w.sizeFromShape(m),v=t.makeOutput(g,c.dtype);if(w.sizeFromShape(c.shape)!==0){let y=t.dataIdMap.get(v.dataId).id;ZD(u,et[o.dtype],b,y)}if(h&&t.disposeData(l.dataId),a){let y=T.expandShapeToKeepDim(v.shape,d);v.shape=y}return v}var cpe={kernelName:gi,backendName:"wasm",setupFunc:ipe,kernelFunc:upe},lpe=!1,dpe=Ht(bi,lpe),kx;(function(e){e[e.reflect=0]="reflect",e[e.symmetric=1]="symmetric"})(kx||(kx={}));var JD;function ppe(e){JD=e.wasm.cwrap(yi,null,["number","array","number","number","array","array","number","number"])}function hpe(e){let{inputs:{x:t},backend:n,attrs:{paddings:r,mode:s}}=e,a=r.map((f,g)=>f[0]+t.shape[g]+f[1]),o=n.dataIdMap.get(t.dataId).id,i=n.makeOutput(a,t.dtype),u=n.dataIdMap.get(i.dataId).id,c=new Uint8Array(new Int32Array(t.shape).buffer),l=r.map(f=>f[0]),p=r.map(f=>f[1]),d=new Uint8Array(new Int32Array(l).buffer),h=new Uint8Array(new Int32Array(p).buffer);return JD(o,c,t.shape.length,et[t.dtype],d,h,kx[s],u),i}var fpe={kernelName:yi,backendName:"wasm",kernelFunc:hpe,setupFunc:ppe},QD;function mpe(e){QD=e.wasm.cwrap(Vi,null,["number","number","number","number"])}function e$(e){let{backend:t,inputs:{logits:n},attrs:{dim:r}}=e,s=t.dataIdMap.get(n.dataId).id,a=t.makeOutput(n.shape,n.dtype),o=t.dataIdMap.get(a.dataId).id,i=n.shape[r],u=w.sizeFromShape(n.shape)/i;return w.sizeFromShape(a.shape)===0||QD(s,o,i,u),a}var gpe={kernelName:Vi,backendName:"wasm",setupFunc:mpe,kernelFunc:e$},t$;function bpe(e){t$=e.wasm.cwrap(zc,null,["number","number","number","number","number","number"])}function ype(e){let{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{numSamples:a,seed:o,normalized:i}=r;if(s.dtype!=="float32")throw new Error(`Tensor logits must have dtype float32, got ${s.dtype}`);let u=i?s:e$({inputs:{logits:s},backend:n,attrs:{dim:s.shape.length-1}}),[c,l]=u.shape,p=n.makeOutput([c,a],"int32");return t$(n.dataIdMap.get(u.dataId).id,c,l,a,o,n.dataIdMap.get(p.dataId).id),i||n.disposeData(u.dataId),p}var vpe={kernelName:zc,backendName:"wasm",setupFunc:bpe,kernelFunc:ype},xpe=Ht(vi,!0),wpe=!0,Ipe=Ht(xi,wpe),kpe=Xe(Bc);function f0(e,t){let n=new Int32Array(e.wasm.HEAPU8.buffer,t,4),r=n[0],s=n[1],a=n[2],o=n[3];return e.wasm._free(t),{pSelectedIndices:r,selectedSize:s,pSelectedScores:a,pValidOutputs:o}}var n$;function Spe(e){n$=e.wasm.cwrap(Vc,"number",["number","number","number","number","number"])}function Cpe(e){let{backend:t,inputs:n,attrs:r}=e,{iouThreshold:s,maxOutputSize:a,scoreThreshold:o}=r,{boxes:i,scores:u}=n,c=t.dataIdMap.get(i.dataId).id,l=t.dataIdMap.get(u.dataId).id,p=n$(c,l,a,s,o),{pSelectedIndices:d,selectedSize:h,pSelectedScores:f,pValidOutputs:g}=f0(t,p);return t.wasm._free(f),t.wasm._free(g),t.makeOutput([h],"int32",d)}var Tpe={kernelName:Vc,backendName:"wasm",setupFunc:Spe,kernelFunc:Cpe},r$;function Npe(e){r$=e.wasm.cwrap(Uc,"number",["number","number","number","number","number","bool"])}function _pe(e){let{backend:t,inputs:n,attrs:r}=e,{iouThreshold:s,maxOutputSize:a,scoreThreshold:o,padToMaxOutputSize:i}=r,{boxes:u,scores:c}=n,l=t.dataIdMap.get(u.dataId).id,p=t.dataIdMap.get(c.dataId).id,d=r$(l,p,a,s,o,i),{pSelectedIndices:h,selectedSize:f,pSelectedScores:g,pValidOutputs:m}=f0(t,d);t.wasm._free(g);let b=t.makeOutput([f],"int32",h),v=t.makeOutput([],"int32",m);return[b,v]}var Epe={kernelName:Uc,backendName:"wasm",setupFunc:Npe,kernelFunc:_pe},s$;function Ape(e){s$=e.wasm.cwrap(Gc,"number",["number","number","number","number","number","number"])}function Dpe(e){let{backend:t,inputs:n,attrs:r}=e,{iouThreshold:s,maxOutputSize:a,scoreThreshold:o,softNmsSigma:i}=r,{boxes:u,scores:c}=n,l=t.dataIdMap.get(u.dataId).id,p=t.dataIdMap.get(c.dataId).id,d=s$(l,p,a,s,o,i),{pSelectedIndices:h,selectedSize:f,pSelectedScores:g,pValidOutputs:m}=f0(t,d);t.wasm._free(m);let b=t.makeOutput([f],"int32",h),v=t.makeOutput([f],"float32",g);return[b,v]}var $pe={kernelName:Gc,backendName:"wasm",setupFunc:Ape,kernelFunc:Dpe},Fpe=!1,Rpe=Ht(Wc,Fpe,"bool"),a$;function Ppe(e){a$=e.wasm.cwrap(wi,null,["number","number","number","number","number"])}function Ope(e){let{inputs:t,backend:n,attrs:r}=e,{indices:s}=t,{dtype:a,depth:o,onValue:i,offValue:u}=r,c=n.makeOutput([...s.shape,o],a),l=n.dataIdMap.get(c.dataId).id,d=n.dataIdMap.get(s.dataId).id;return a$(d,o,i,u,l),c}var Mpe={kernelName:wi,backendName:"wasm",setupFunc:Ppe,kernelFunc:Ope};function Lpe(e){let{inputs:{x:t},backend:n}=e,r=n.makeOutput(t.shape,t.dtype);return n.typedArrayFromHeap(r).fill(1),r}var zpe={kernelName:Hc,backendName:"wasm",kernelFunc:Lpe};function Bpe(e){let{inputs:t,backend:n,attrs:r}=e,{axis:s}=r;if(t.length===1)return Ix({inputs:{input:t[0]},backend:n,attrs:{dim:s}});let a=t[0].shape,o=t[0].dtype;t.forEach(l=>{w.assertShapesMatch(a,l.shape,"All tensors passed to stack must have matching shapes"),w.assert(o===l.dtype,()=>"All tensors passed to stack must have matching dtypes")});let i=[],u=t.map(l=>{let p=Ix({inputs:{input:l},backend:n,attrs:{dim:s}});return i.push(p),p}),c=gD({inputs:u,backend:n,attrs:{axis:s}});return i.forEach(l=>n.disposeData(l.dataId)),c}var Wpe={kernelName:jc,backendName:"wasm",kernelFunc:Bpe},o$;function Vpe(e){o$=e.wasm.cwrap(Ii,null,["number","array","number","number","array","array","number","number"])}function Upe(e){let{inputs:{x:t},backend:n,attrs:{paddings:r,constantValue:s}}=e,a=r.map((g,m)=>g[0]+t.shape[m]+g[1]);if(w.sizeFromShape(t.shape)===0)return FD({backend:n,attrs:{shape:a,value:s,dtype:t.dtype}});let o=n.dataIdMap.get(t.dataId).id,i=n.makeOutput(a,t.dtype),c=n.dataIdMap.get(i.dataId).id,l=new Uint8Array(new Int32Array(t.shape).buffer),p=r.map(g=>g[0]),d=r.map(g=>g[1]),h=new Uint8Array(new Int32Array(p).buffer),f=new Uint8Array(new Int32Array(d).buffer);return o$(o,l,t.shape.length,et[t.dtype],h,f,s,c),i}var i$={kernelName:Ii,backendName:"wasm",kernelFunc:Upe,setupFunc:Vpe},Gpe=!1,Hpe=Ht(ki,Gpe),u$;function jpe(e){u$=e.wasm.cwrap(Si,null,["number","number","number"])}function qpe(e){let{inputs:t,backend:n}=e,{x:r,alpha:s}=t,a=n.dataIdMap.get(r.dataId).id,o=n.dataIdMap.get(s.dataId).id,i=a,u=r,c=u;u.dtype!=="float32"&&(c=La({backend:n,inputs:{x:r},attrs:{dtype:"float32"}}),i=n.dataIdMap.get(c.dataId).id);let l=n.makeOutput(r.shape,"float32"),p=n.dataIdMap.get(l.dataId).id;return u$(i,o,p),u.dtype!=="float32"&&n.disposeData(c.dataId),l}var Kpe={kernelName:Si,backendName:"wasm",setupFunc:jpe,kernelFunc:qpe},c$;function Xpe(e){c$=e.wasm.cwrap(Ci,null,["number","number","number","number"])}function Ype(e){let{backend:t,inputs:n,attrs:r}=e,{axis:s,keepDims:a}=r,{x:o}=n,i=t.dataIdMap.get(o.dataId).id,u=i,c=o,{transposed:l,axes:p,originalAxes:d,inputWasTransposed:h}=Ma(o,s,t),f=p;if(h){let y=t.dataIdMap.get(l.dataId).id;y!==i&&(c=l,u=y,f=T.getInnerMostAxes(f.length,c.shape.length))}T.assertAxesAreInnerMostDims("prod",f,c.shape.length);let[g,m]=T.computeOutAndReduceShapes(c.shape,f),b=w.sizeFromShape(m),v=t.makeOutput(g,c.dtype);if(w.sizeFromShape(c.shape)!==0){let y=t.dataIdMap.get(v.dataId).id;c$(u,b,et[v.dtype],y)}if(h&&t.disposeData(l.dataId),a){let y=T.expandShapeToKeepDim(v.shape,d);v.shape=y}return v}var Zpe={kernelName:Ci,backendName:"wasm",setupFunc:Xpe,kernelFunc:Ype},Jpe=e=>{let{backend:t,attrs:n}=e,{start:r,stop:s,step:a,dtype:o}=n,i=Uk(r,s,a,o),u=t.makeOutput([i.length],o);return t.typedArrayFromHeap(u).set(i),u},Qpe={kernelName:Xd,backendName:"wasm",kernelFunc:Jpe},ehe=!0,the=Ht(Xo,ehe),nhe=Xe(Ti),rhe=Xe(Ni),she=Xe(Ai),l$;function ahe(e){l$=e.wasm.cwrap(Ei,null,["number","number","number","number","number","number","number","number","number","number"])}function ohe(e){let{backend:t,inputs:n,attrs:r}=e,{images:s}=n,{alignCorners:a,halfPixelCenters:o,size:i}=r,[u,c]=i,[l,p,d,h]=s.shape,f=[l,u,c,h],g=t.dataIdMap.get(s.dataId),m;g.dtype!=="float32"&&(m=La({backend:t,inputs:{x:s},attrs:{dtype:"float32"}}),g=t.dataIdMap.get(m.dataId));let b=g.id,v=t.makeOutput(f,"float32");if(w.sizeFromShape(s.shape)===0)return v;let y=t.dataIdMap.get(v.dataId).id;return l$(b,l,p,d,h,u,c,a?1:0,o?1:0,y),m!=null&&t.disposeData(m.dataId),v}var ihe={kernelName:Ei,backendName:"wasm",setupFunc:ahe,kernelFunc:ohe},d$;function uhe(e){d$=e.wasm.cwrap(Xc,null,["number","number","number","array","array","boolean"])}function che(e){let{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:o}=r,i=n.makeOutput(s.shape,"float32"),u=n.dataIdMap.get(s.dataId),c;return u.dtype!=="float32"&&(c=La({backend:n,inputs:{x:s},attrs:{dtype:"float32"}}),u=n.dataIdMap.get(c.dataId)),d$(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(i.dataId).id,new Uint8Array(new Int32Array(s.shape).buffer),new Uint8Array(new Int32Array(a.shape).buffer),o),c!=null&&n.disposeData(c.dataId),i}var lhe={kernelName:Xc,backendName:"wasm",setupFunc:uhe,kernelFunc:che},p$;function dhe(e){p$=e.wasm.cwrap(_i,null,["number","number","number","number","number","number","number","number","number","number"])}function phe(e){let{backend:t,inputs:n,attrs:r}=e,{images:s}=n,{alignCorners:a,halfPixelCenters:o,size:i}=r,[u,c]=i,[l,p,d,h]=s.shape,f=[l,u,c,h],g=t.makeOutput(f,"float32");if(w.sizeFromShape(s.shape)===0)return g;let m=t.dataIdMap.get(s.dataId),b;m.dtype!=="float32"&&(b=La({backend:t,inputs:{x:s},attrs:{dtype:"float32"}}),m=t.dataIdMap.get(b.dataId));let v=m.id,y=t.dataIdMap.get(g.dataId).id;return p$(v,l,p,d,h,u,c,a?1:0,o?1:0,y),b!=null&&t.disposeData(b.dataId),g}var hhe={kernelName:_i,backendName:"wasm",setupFunc:dhe,kernelFunc:phe},h$;function fhe(e){h$=e.wasm.cwrap(Kc,null,["number","number","number","array","array","boolean"])}function mhe(e){let{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:o}=r,i=n.makeOutput(s.shape,"float32"),u=n.dataIdMap.get(s.dataId),c;return u.dtype!=="float32"&&(c=La({backend:n,inputs:{x:s},attrs:{dtype:"float32"}}),u=n.dataIdMap.get(c.dataId)),h$(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(i.dataId).id,new Uint8Array(new Int32Array(s.shape).buffer),new Uint8Array(new Int32Array(a.shape).buffer),o),c!=null&&n.disposeData(c.dataId),i}var ghe={kernelName:Kc,backendName:"wasm",setupFunc:fhe,kernelFunc:mhe},f$;function bhe(e){f$=e.wasm.cwrap(Di,null,["number","array","number","array","number","number"])}function yhe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dims:a}=r,o=w.parseAxisParam(a,s.shape);if(s.shape.length===0)return og({inputs:{x:s},backend:n});let i=n.makeOutput(s.shape,s.dtype),u=n.dataIdMap.get(s.dataId).id,c=n.dataIdMap.get(i.dataId).id,l=new Uint8Array(new Int32Array(o).buffer),p=new Uint8Array(new Int32Array(s.shape).buffer);f$(u,l,o.length,p,s.shape.length,c);let d=Bn({inputs:{x:i},attrs:{shape:s.shape},backend:n});return n.disposeData(i.dataId),d}var vhe={kernelName:Di,backendName:"wasm",kernelFunc:yhe,setupFunc:bhe},m$;function xhe(e){m$=e.wasm.cwrap(ll,null,["number","number","number","number","number","number","number","number","array","number","number"])}function whe(e){let{inputs:t,backend:n,attrs:r}=e,{image:s}=t,{radians:a,fillValue:o,center:i}=r,u=n.makeOutput(s.shape,s.dtype),c=n.dataIdMap.get(s.dataId).id,l=n.dataIdMap.get(u.dataId).id,[p,d,h,f]=s.shape,[g,m]=T.getImageCenter(i,d,h),b=o===0,v=255,y=typeof o=="number"?[o,o,o,b?0:v]:[...o,v],x=new Uint8Array(new Int32Array(y).buffer);return m$(c,p,d,h,f,a,g,m,x,y.length,l),u}var Ihe={kernelName:ll,backendName:"wasm",kernelFunc:whe,setupFunc:xhe},khe=Xe($i),She=Xe(Fi),g$;function Che(e){g$=e.wasm.cwrap(Yc,null,["number","number","number","number","number","number","array","number","number"])}function The(e){let{backend:t,inputs:n,attrs:r}=e,{indices:s,updates:a}=n,{shape:o}=r,i=t.makeOutput(o,a.dtype);if(w.sizeFromShape(o)===0)return i;let{sliceRank:u,numUpdates:c,sliceSize:l,strides:p,outputSize:d}=Sm.calculateShapes(a,s,o),f=t.dataIdMap.get(s.dataId).id,m=t.dataIdMap.get(a.dataId).id,b=new Uint8Array(new Int32Array(p).buffer),v=t.dataIdMap.get(i.dataId).id;return g$(f,m,et[a.dtype],u,c,l,b,d,v),i}var Nhe={kernelName:Yc,backendName:"wasm",setupFunc:Che,kernelFunc:The},b$;function _he(e){b$=e.wasm.cwrap(Jc,null,["number","number","number","number","number","number","bool","number"])}function Ehe(e){let{inputs:t,backend:n,attrs:r}=e,{sortedSequence:s,values:a}=t,{side:o}=r;if(s.dtype!==a.dtype)throw new Error(`SearchSorted error: sorted_sequence must have the same dtype as values. Got ${s.dtype} and ${a.dtype}`);let i=n.makeOutput(a.shape,"int32");function u(c){return n.dataIdMap.get(c.dataId).id}return b$(u(s),u(a),s.shape[0],s.shape[1],a.shape[1],et[s.dtype],o==="left",u(i)),i}var Ahe={kernelName:Jc,backendName:"wasm",setupFunc:_he,kernelFunc:Ehe},y$;function Dhe(e){y$=e.wasm.cwrap("SelectV2",null,["number","number","number","number","number"])}function $he(e){let{inputs:t,backend:n}=e,{condition:r,t:s,e:a}=t,o=n.dataIdMap.get(r.dataId).id,i=n.dataIdMap.get(s.dataId).id,u=n.dataIdMap.get(a.dataId).id,c=n.makeOutput(s.shape,s.dtype),l=n.dataIdMap.get(c.dataId).id,p=r.shape.length,d=s.shape.length,h=p===0||p>1||d===1?1:w.sizeFromShape(s.shape.slice(1));return y$(o,i,u,h,l),c}var Fhe={kernelName:Qc,backendName:"wasm",kernelFunc:$he,setupFunc:Dhe},Rhe=Xe(Ri),v$;function Phe(e){v$=e.wasm.cwrap(Li,null,["number","number"])}function Ohe(e){let{backend:t,inputs:{x:n}}=e,r=t.dataIdMap.get(n.dataId).id,s=t.makeOutput(n.shape,n.dtype),a=t.dataIdMap.get(s.dataId).id;return w.sizeFromShape(s.shape)===0||v$(r,a),s}var Mhe={kernelName:"Sigmoid",backendName:"wasm",setupFunc:Phe,kernelFunc:Ohe},Lhe=Xe(Mi),zhe=Xe(Pi),Bhe=Xe(Oi),Whe=Xe(zi);function Vhe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,paddings:o}=r,i=w.sizeFromShape(a),u=[[0,0]];u.push(...o);for(let S=1+a.length;S<s.shape.length;++S)u.push([0,0]);let c=i$.kernelFunc({inputs:{x:s},backend:n,attrs:{paddings:u,constantValue:0}}),l=T.getReshaped(c.shape,a,i,!1),p=T.getPermuted(l.length,a.length,!1),d=T.getReshapedPermuted(c.shape,a,i,!1),g=Bn({inputs:{x:c},backend:n,attrs:{shape:l}}),v=Ia({inputs:{x:g},backend:n,attrs:{perm:p}}),k=Bn({inputs:{x:v},backend:n,attrs:{shape:d}});return n.disposeData(c.dataId),n.disposeData(g.dataId),n.disposeData(v.dataId),k}var Uhe={kernelName:tl,backendName:"wasm",kernelFunc:Vhe},x$;function Ghe(e){x$=e.wasm.cwrap("SparseFillEmptyRows","number",["number","number","number","number","number","number","number","number","number","number","number","number"])}function Hhe(e){let{backend:t,inputs:n}=e,{indices:r,values:s,denseShape:a,defaultValue:o}=n,i=r.shape[0],u=r.shape[1],c=t.readSync(a.dataId)[0],l=[i+c,u],p=t.dataIdMap.get(r.dataId).id,d=t.dataIdMap.get(s.dataId).id,h=t.dataIdMap.get(o.dataId).id,f=t.makeOutput(l,r.dtype),g=t.dataIdMap.get(f.dataId).id,m=t.makeOutput(l.slice(0,1),s.dtype),b=t.dataIdMap.get(m.dataId).id,v=t.makeOutput([c],"bool"),y=t.dataIdMap.get(v.dataId).id,x=t.makeOutput([i],r.dtype),k=t.dataIdMap.get(x.dataId).id,S=t.makeOutput([4],"int32"),N=t.dataIdMap.get(S.dataId).id,E=x$(p,d,et[s.dtype],i,c,u,h,g,b,y,k,N),$=t.readSync(S.dataId),R;switch($[0]){case 1:{R=T.getSparseFillEmptyRowsIndicesDenseShapeMismatch($[1]);break}case 2:{R=T.getSparseFillEmptyRowsNegativeIndexErrorMessage($[1],$[2]);break}case 3:R=T.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage($[1],$[2],$[3]);break;default:R=""}if(t.disposeData(S.dataId),R)throw t.disposeData(f.dataId),t.disposeData(m.dataId),t.disposeData(v.dataId),t.disposeData(x.dataId),new Error(R);let D=f,F=m;return E!==l[0]&&(D=No({inputs:{x:f},attrs:{begin:0,size:[E,u]},backend:t}),F=No({inputs:{x:m},attrs:{begin:0,size:E},backend:t}),t.disposeData(f.dataId),t.disposeData(m.dataId)),[D,F,v,x]}var jhe={kernelName:Yd,backendName:"wasm",setupFunc:Ghe,kernelFunc:Hhe},w$;function qhe(e){w$=e.wasm.cwrap(rl,null,["number","number","number","number","number","number","number"])}function Khe(e){let{backend:t,inputs:n}=e,{inputIndices:r,inputShape:s,newShape:a}=n;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${r.shape}`);if(s.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${s.shape}`);if(a.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${a.shape}`);let o=t.dataIdMap.get(r.dataId).id,i=t.dataIdMap.get(s.dataId).id,u=t.dataIdMap.get(a.dataId).id,c=r.shape[0],l=w.sizeFromShape(a.shape),p=t.makeOutput([c,l],r.dtype),d=t.dataIdMap.get(p.dataId).id,h=t.makeOutput([l],a.dtype),f=t.dataIdMap.get(h.dataId).id,g=t.makeOutput([3],"int32"),m=t.dataIdMap.get(g.dataId).id;w$(o,i,u,c,d,f,m);let b=t.readSync(g.dataId),v;switch(b[0]){case 0:{v=T.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(b[1],b[2]);break}case 1:{v=T.getSparseReshapeNegativeOutputDimErrorMessage(b[1],b[2]);break}case 2:v=T.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage();break;case 3:{let y=Array.from(t.readSync(s.dataId)),x=Array.from(t.readSync(h.dataId));v=T.getSparseReshapeInputOutputMultipleErrorMessage(y,x);break}case 4:{let y=Array.from(t.readSync(s.dataId)),x=Array.from(t.readSync(h.dataId));v=T.getSparseReshapeInputOutputMismatchErrorMessage(y,x);break}default:v=""}if(t.disposeData(g.dataId),v)throw t.disposeData(p.dataId),t.disposeData(h.dataId),new Error(v);return[p,h]}var Xhe={kernelName:rl,backendName:"wasm",setupFunc:qhe,kernelFunc:Khe},I$;function k$(e){I$=e.wasm.cwrap("SparseSegmentReduction",null,["number","number","number","number","number","number","number","number","number"])}function S$(e,t){let{backend:n,inputs:r}=e,{data:s,indices:a,segmentIds:o}=r,i=a.shape[0],u=n.readSync(o.dataId,i-1,i)[0],l=i>0?u+1:0;if(l<0)throw new Error(T.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let p=s.shape.slice();p[0]=l;let d=n.dataIdMap.get(s.dataId).id,h=n.dataIdMap.get(a.dataId).id,f=n.dataIdMap.get(o.dataId).id,g=n.makeOutput(p,s.dtype),m=n.dataIdMap.get(g.dataId).id,b=n.makeOutput([4],"int32"),v=n.dataIdMap.get(b.dataId).id;I$(d,et[s.dtype],s.shape[0],h,f,m,v,t,0);let y=n.readSync(b.dataId),x;switch(y[0]){case 0:{x=T.getSparseSegmentReductionNegativeSegmentIdsErrorMessage();break}case 1:{x=T.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage();break}case 2:x=T.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(y[1],y[2]);break;case 3:x=T.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(y[1],y[2],y[3]);break;default:x=""}if(n.disposeData(b.dataId),x)throw n.disposeData(g.dataId),new Error(x);return g}function Yhe(e){return S$(e,!0)}var Zhe={kernelName:Zd,backendName:"wasm",setupFunc:k$,kernelFunc:Yhe};function Jhe(e){return S$(e,!1)}var Qhe={kernelName:Jd,backendName:"wasm",setupFunc:k$,kernelFunc:Jhe},C$;function efe(e){C$=e.wasm.cwrap(sl,null,["number","number","number","number","number","number","number","number","array","number","number"])}function tfe(e){let{backend:t,inputs:n,attrs:r}=e,{sparseIndices:s,sparseValues:a,defaultValue:o}=n,{outputShape:i}=r,u=t.makeOutput(i,o.dtype);if(w.sizeFromShape(i)===0)return u;let{sliceRank:c,numUpdates:l,sliceSize:p,strides:d,outputSize:h}=T.calculateShapes(a,s,i),f=t.dataIdMap.get(s.dataId).id,g=t.dataIdMap.get(a.dataId).id,m=t.dataIdMap.get(o.dataId).id,b=new Uint8Array(new Int32Array(d).buffer),v=t.dataIdMap.get(u.dataId).id;return C$(f,g,a.shape.length,m,et[o.dtype],c,l,p,b,h,v),u}var nfe={kernelName:sl,backendName:"wasm",setupFunc:efe,kernelFunc:tfe};function rfe(e){let{inputs:t,attrs:n,backend:r}=e,{x:s}=t,{numOrSizeSplits:a,axis:o}=n,i=w.parseAxisParam(o,s.shape)[0],u=T.prepareSplitSize(s,a,i),c=new Array(s.shape.length).fill(0),l=s.shape.slice();return u.map(p=>{let d=[...l];d[i]=p;let h=No({inputs:{x:s},attrs:{begin:c,size:d},backend:r});return c[i]+=p,h})}var sfe={kernelName:nl,backendName:"wasm",kernelFunc:rfe},afe=Xe(Bi),ofe=Xe(Qd),ife=!0,ufe=Ht(Ui,ife),T$;function cfe(e){T$=e.wasm.cwrap(Na,null,["number","number","number","number"])}function lfe(e){let{backend:t,inputs:n,attrs:r}=e,{alpha:s}=r,{x:a}=n,o=t.dataIdMap.get(a.dataId).id,i=t.makeOutput(a.shape,a.dtype),u=t.dataIdMap.get(i.dataId).id;return T$(o,s,et[a.dtype],u),i}var dfe={kernelName:Na,backendName:"wasm",setupFunc:cfe,kernelFunc:lfe},N$;function pfe(e){N$=e.wasm.cwrap(al,null,["number","array","number","array","array","array","array","array","number","number"])}function hfe(e){let{backend:t,inputs:n,attrs:r}=e,{x:s}=n,{begin:a,end:o,strides:i,beginMask:u,endMask:c,ellipsisMask:l,newAxisMask:p,shrinkAxisMask:d}=r,{finalShapeSparse:h,finalShape:f,isIdentity:g,sliceDim0:m,isSimpleSlice:b,begin:v,end:y,strides:x}=Yt.sliceInfo(s.shape,a,o,i,u,c,l,p,d),k;if(g)k=Bn({inputs:{x:s},backend:t,attrs:{shape:f}});else if(m||b){w.assert(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);let S=Yt.computeOutShape(v,y,x),N=No({inputs:{x:s},backend:t,attrs:{begin:v,size:S}});k=Bn({inputs:{x:N},backend:t,attrs:{shape:f}}),t.disposeData(N.dataId)}else{let S=t.makeOutput(h,"float32"),N=t.dataIdMap.get(s.dataId).id,E=new Uint8Array(new Int32Array(w.computeStrides(s.shape)).buffer),$=new Uint8Array(new Int32Array(v).buffer),R=new Uint8Array(new Int32Array(y).buffer),D=new Uint8Array(new Int32Array(x).buffer),F=new Uint8Array(new Int32Array(h).buffer),C=new Uint8Array(new Int32Array(w.computeStrides(h)).buffer),L=t.dataIdMap.get(S.dataId).id;N$(N,E,s.shape.length,$,R,D,F,C,h.length,L),k=Bn({inputs:{x:S},backend:t,attrs:{shape:f}}),t.disposeData(S.dataId)}return k}var ffe={kernelName:al,backendName:"wasm",setupFunc:pfe,kernelFunc:hfe};function mfe(e){let{backend:t,inputs:n,attrs:r}=e,{data:s,dataSplits:a}=n,{separator:o,nGramWidths:i,leftPad:u,rightPad:c,padWidth:l,preserveShortSequences:p}=r,d=t.readSync(s.dataId),h=t.readSync(a.dataId),[f,g]=Hk(d,h,o,i,u,c,l,p),m=t.makeOutput([f.length],"string"),b=t.dataIdMap.get(m.dataId);b.stringBytes=f;let v=t.makeOutput(a.shape,"int32");return t.typedArrayFromHeap(v).set(g),[m,v]}var gfe={kernelName:tp,backendName:"wasm",kernelFunc:mfe};function bfe(e){let{backend:t,inputs:n,attrs:r}=e,{input:s,delimiter:a}=n,{skipEmpty:o}=r,i=t.readSync(s.dataId),u=t.readSync(a.dataId),[c,l,p]=jk(i,u[0],o),d=l.length,h=t.makeOutput([d,2],"int32");t.typedArrayFromHeap(h).set(c);let g=t.makeOutput([d],"string"),m=t.dataIdMap.get(g.dataId);m.stringBytes=l;let b=t.makeOutput([2],"int32");return t.typedArrayFromHeap(b).set(p),[h,g,b]}var yfe={kernelName:np,backendName:"wasm",kernelFunc:bfe};function vfe(e){let{backend:t,inputs:n,attrs:r}=e,{input:s}=n,{numBuckets:a}=r,o=t.readSync(s.dataId),i=qk(o,a),u=t.makeOutput(s.shape,"int32");return t.typedArrayFromHeap(u).set(i),u}var xfe={kernelName:rp,backendName:"wasm",kernelFunc:vfe},wfe=!0,Ife=Ht(Gi,wfe),_$;function kfe(e){_$=e.wasm.cwrap(Wi,null,["number","number","number","number"])}function Sfe(e){let{backend:t,inputs:n,attrs:r}=e,{axis:s,keepDims:a}=r,{x:o}=n,i=t.dataIdMap.get(o.dataId).id,u=i,c=o,{transposed:l,axes:p,originalAxes:d,inputWasTransposed:h}=Ma(o,s,t),f=p;if(h){let y=t.dataIdMap.get(l.dataId).id;y!==i&&(c=l,u=y,f=T.getInnerMostAxes(f.length,c.shape.length))}T.assertAxesAreInnerMostDims("sum",f,c.shape.length);let[g,m]=T.computeOutAndReduceShapes(c.shape,f),b=w.sizeFromShape(m),v=t.makeOutput(g,c.dtype);if(w.sizeFromShape(c.shape)!==0){let y=t.dataIdMap.get(v.dataId).id;_$(u,b,et[v.dtype],y)}if(h&&t.disposeData(l.dataId),a){let y=T.expandShapeToKeepDim(v.shape,d);v.shape=y}return v}var Cfe={kernelName:Wi,backendName:"wasm",setupFunc:kfe,kernelFunc:Sfe},Tfe=Xe(Hi),Nfe=Xe(ji),E$;function _fe(e){E$=e.wasm.cwrap(Zc,null,["number","number","number","number","number","number","array","number","number","number"])}function Efe(e){let{backend:t,inputs:n,attrs:r}=e,{tensor:s,indices:a,updates:o}=n,{}=r,i=t.makeOutput(s.shape,s.dtype);if(w.sizeFromShape(s.shape)===0)return i;let{sliceRank:u,numUpdates:c,sliceSize:l,strides:p,outputSize:d}=Sm.calculateShapes(o,a,s.shape),f=t.dataIdMap.get(a.dataId).id,m=t.dataIdMap.get(o.dataId).id,v=t.dataIdMap.get(s.dataId).id,y=new Uint8Array(new Int32Array(p).buffer),x=t.dataIdMap.get(i.dataId).id;return E$(f,m,et[o.dtype],u,c,l,y,d,x,v),i}var Afe={kernelName:Zc,backendName:"wasm",setupFunc:_fe,kernelFunc:Efe},A$;function Dfe(e){A$=e.wasm.cwrap(Ta,null,["number","array","number","array","number","number"])}function $fe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,a=n.dataIdMap.get(s.dataId).id,{reps:o}=r,i=new Array(s.shape.length);for(let d=0;d<i.length;d++)i[d]=s.shape[d]*o[d];let u=new Uint8Array(new Int32Array(s.shape).buffer),c=new Uint8Array(new Int32Array(i).buffer),l=n.makeOutput(i,s.dtype),p=n.dataIdMap.get(l.dataId).id;return A$(a,u,s.shape.length,c,i.length,et[l.dtype],p),l}var Ffe={kernelName:Ta,backendName:"wasm",setupFunc:Dfe,kernelFunc:$fe},D$;function Rfe(e){D$=e.wasm.cwrap(ol,null,["number","array","number","number","number","bool","number","number"])}var Pfe=({inputs:e,backend:t,attrs:n})=>{let{x:r}=e,{k:s,sorted:a}=n,o=t.dataIdMap.get(r.dataId).id,i=new Uint8Array(new Int32Array(r.shape).buffer),u=r.shape.slice();u[u.length-1]=s;let c=t.makeOutput(u,r.dtype),l=t.dataIdMap.get(c.dataId).id,p=t.makeOutput(u,"int32"),d=t.dataIdMap.get(p.dataId).id;return D$(o,i,r.shape.length,et[r.dtype],s,a,l,d),[c,p]},Ofe={kernelName:ol,backendName:"wasm",setupFunc:Rfe,kernelFunc:Pfe},$$;function Mfe(e){$$=e.wasm.cwrap(il,null,["number","number","bool","number","number","number","number","number","number","array","number","array","number","number","number","number","number"])}function Lfe(e){let{backend:t,inputs:n,attrs:r}=e,{image:s,transforms:a}=n,{interpolation:o,fillMode:i,fillValue:u,outputShape:c}=r,[l,p,d,h]=s.shape,[f,g]=c??[p,d],m=[l,f,g,h],b=new Uint8Array(new Int32Array(w.computeStrides(s.shape)).buffer),v=new Uint8Array(new Int32Array(w.computeStrides(m)).buffer),y=t.makeOutput(m,s.dtype),x=t.dataIdMap.get(y.dataId).id,S=t.dataIdMap.get(s.dataId).id,E=t.dataIdMap.get(a.dataId).id,$=o==="nearest"?1:2,R;switch(i){case"constant":R=1;break;case"reflect":R=2;break;case"wrap":R=3;break;case"nearest":R=4;break;default:R=1;break}return $$(S,E,a.shape[0]>1,l,f,g,h,d,p,b,s.shape.length-1,v,m.length-1,$,R,u,x),y}var zfe={kernelName:il,backendName:"wasm",setupFunc:Mfe,kernelFunc:Lfe};function Bfe(e){let{inputs:t,attrs:n,backend:r}=e,{axis:s}=n,{x:a}=t,{outputValues:o,outputShape:i,indices:u}=Xk(r.readSync(a.dataId),s,a.shape,a.dtype);return[r.makeOutput(i,a.dtype,void 0,o),r.makeOutput([u.length],"int32",void 0,u)]}var Wfe={kernelName:sp,backendName:"wasm",kernelFunc:Bfe};function Vfe(e){let{inputs:t,backend:n,attrs:r}=e,{value:s}=t,{axis:a}=r;a<0&&(a+=s.shape.length);let o=s.shape[a],i=s.shape.length,u=new Array(i-1),c=0;for(let h=0;h<i;h++)h!==a&&(u[c++]=s.shape[h]);let l=new Array(o),p=new Array(i).fill(0),d=s.shape.slice();d[a]=1;for(let h=0;h<l.length;h++)p[a]=h,l[h]=No({inputs:{x:s},attrs:{begin:p,size:d},backend:n});return l.map(({dataId:h,dtype:f})=>({dataId:h,dtype:f,shape:u}))}var Ufe={kernelName:ul,backendName:"wasm",kernelFunc:Vfe};function Gfe(e){let{inputs:{x:t},backend:n}=e,r=n.makeOutput(t.shape,t.dtype);return n.typedArrayFromHeap(r).fill(0),r}var Hfe={kernelName:cl,backendName:"wasm",kernelFunc:Gfe},jfe=[Nue,_ue,Eue,Aue,$ue,Pue,Uue,jue,que,Kue,Xue,Yue,Zue,Jue,Que,nce,dce,ace,uce,mce,wce,Sce,Tce,_ce,Ece,Ace,Fce,Rce,Mce,Bce,Uce,jce,Xce,Yce,Zce,ele,rle,ole,cle,ple,mle,yle,wle,Sle,Nle,_le,Dle,Fle,Rle,Ple,Ole,Mle,Lle,Wle,Vle,Gle,qle,Yle,Qle,nde,ade,ide,cde,Oue,lde,dde,pde,mde,bde,vde,Ide,Sde,kde,Tde,Nde,Ede,Dde,Rde,Mde,Bde,Vde,Hde,Kde,Zde,epe,rpe,ope,cpe,dpe,fpe,vpe,xpe,Ipe,kpe,Tpe,Epe,$pe,Rpe,Mpe,zpe,Wpe,i$,Hpe,Kpe,Zpe,Qpe,the,nhe,rhe,she,pce,ihe,lhe,hhe,ghe,vhe,Ihe,khe,She,Nhe,Ahe,Fhe,Rhe,Mhe,Lhe,zhe,Bhe,vce,gpe,Whe,Uhe,jhe,Xhe,Zhe,Qhe,nfe,sfe,afe,ofe,ufe,dfe,ffe,gfe,yfe,xfe,Ife,Cfe,Tfe,Nfe,Afe,Ffe,Ofe,zfe,Bue,Wfe,Ufe,Hfe];for(let e of jfe)op(e);var Sx=G();Sx.registerFlag("WASM_HAS_SIMD_SUPPORT",async()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]))}catch{return!1}});Sx.registerFlag("WASM_HAS_MULTITHREAD_SUPPORT",async()=>{if(Sx.get("IS_NODE"))return!1;try{return new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}});var V1=ka(CR()),qfe=ka(TR()),U1=ka(NR()),G1=V1.default||V1,Kfe=U1.default||U1,F$=class extends Md{constructor(e){super(),this.wasm=e,this.dataIdNextNumber=1,this.wasm.tfjs.initWithThreadsCount(R$),Cx=this.wasm.tfjs.getThreadsCount(),this.dataIdMap=new Mf(this,Dr())}write(e,t,n){let r={id:this.dataIdNextNumber++};return this.move(r,e,t,n,1),r}numDataIds(){return this.dataIdMap.numDataIds()}async time(e){let t=w.now();return e(),{kernelMs:w.now()-t}}move(e,t,n,r,s){let a=this.dataIdNextNumber++;if(r==="string"){let c=t;this.dataIdMap.set(e,{id:a,stringBytes:c,shape:n,dtype:r,memoryOffset:null,refCount:s});return}let o=w.sizeFromShape(n),i=o*w.bytesPerElement(r),u=this.wasm._malloc(i)>>>0;this.dataIdMap.set(e,{id:a,memoryOffset:u,shape:n,dtype:r,refCount:s}),this.wasm.tfjs.registerTensor(a,o,u),t!=null&&this.wasm.HEAPU8.set(new Uint8Array(t.buffer,t.byteOffset,i),u)}async read(e){return this.readSync(e)}readSync(e,t,n){let{memoryOffset:r,dtype:s,shape:a,stringBytes:o}=this.dataIdMap.get(e);if(s==="string")return(t==null||t===0)&&(n==null||n>=o.length)?o:o.slice(t,n);t=t||0,n=n||w.sizeFromShape(a);let i=w.bytesPerElement(s),u=this.wasm.HEAPU8.slice(r+t*i,r+n*i);return Zfe(u.buffer,s)}disposeData(e,t=!1){if(this.dataIdMap.has(e)){let n=this.dataIdMap.get(e);if(n.refCount--,!t&&n.refCount>0)return!1;this.wasm._free(n.memoryOffset),this.wasm.tfjs.disposeData(n.id),this.dataIdMap.delete(e)}return!0}refCount(e){return this.dataIdMap.has(e)?this.dataIdMap.get(e).refCount:0}incRef(e){let t=this.dataIdMap.get(e);t!=null&&t.refCount++}floatPrecision(){return 32}getMemoryOffset(e){return this.dataIdMap.get(e).memoryOffset}dispose(){this.wasm.tfjs.dispose(),"PThread"in this.wasm&&this.wasm.PThread.terminateAllThreads(),this.wasm=null}memory(){return{unreliable:!1}}makeOutput(e,t,n,r){let s;if(n==null)s=this.write(r??null,e,t);else{let a=this.dataIdNextNumber++;s={id:a},this.dataIdMap.set(s,{id:a,memoryOffset:n,shape:e,dtype:t,refCount:1});let o=w.sizeFromShape(e);this.wasm.tfjs.registerTensor(a,o,n)}return{dataId:s,shape:e,dtype:t}}typedArrayFromHeap({shape:e,dtype:t,dataId:n}){let r=this.wasm.HEAPU8.buffer,{memoryOffset:s}=this.dataIdMap.get(n),a=w.sizeFromShape(e);switch(t){case"float32":return new Float32Array(r,s,a);case"int32":return new Int32Array(r,s,a);case"bool":return new Uint8Array(r,s,a);default:throw new Error(`Unknown dtype ${t}`)}}};function Xfe(e){return(t,n)=>(w.fetch(e,{credentials:"same-origin"}).then(r=>{r.ok||t.env.a(`failed to load wasm binary file at '${e}'`),r.arrayBuffer().then(s=>{WebAssembly.instantiate(s,t).then(a=>{n(a.instance,a.module)})})}),{})}function H1(e,t,n){if(Pf!=null)return Pf;let r="tfjs-backend-wasm.wasm";return e&&t?r="tfjs-backend-wasm-threaded-simd.wasm":e&&(r="tfjs-backend-wasm-simd.wasm"),gd!=null&&gd[r]!=null?gd[r]:n+r}async function Yfe(){let[e,t]=await Promise.all([G().getAsync("WASM_HAS_SIMD_SUPPORT"),G().getAsync("WASM_HAS_MULTITHREAD_SUPPORT")]);return new Promise((n,r)=>{let s={};s.locateFile=(i,u)=>{if(i.endsWith(".worker.js")){let c=qfe.wasmWorkerContents.replace(/\n/g,"\\n"),l=new Blob([c],{type:"application/javascript"});return URL.createObjectURL(l)}return i.endsWith(".wasm")?H1(e,t,hd??u):u+i},m0&&(s.instantiateWasm=Xfe(H1(e,t,hd??"")));let a=!1;s.onAbort=()=>{if(a||bd)return;bd=!0,r({message:"Make sure the server can serve the `.wasm` file relative to the bundled js file. For more details see https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/README.md#using-bundlers"})};let o;t&&e&&Pf==null?(s.mainScriptUrlOrBlob=new Blob(["var WasmBackendModuleThreadedSimd = "+G1.toString()],{type:"text/javascript"}),o=G1(s)):o=Kfe(s),o.then(i=>{a=!0,bd=!1;let u=null;i.tfjs={init:i.cwrap("init",null,[]),initWithThreadsCount:i.cwrap("init_with_threads_count",null,["number"]),getThreadsCount:i.cwrap("get_threads_count","number",[]),registerTensor:i.cwrap("register_tensor",null,["number","number","number"]),disposeData:i.cwrap("dispose_data",u,["number"]),dispose:i.cwrap("dispose",u,[])},n({wasm:i})}).catch(r)})}function Zfe(e,t){switch(t){case"float32":return new Float32Array(e);case"int32":return new Int32Array(e);case"bool":return new Uint8Array(e);default:throw new Error(`Unknown dtype ${t}`)}}var Jfe=["tfjs-backend-wasm.wasm","tfjs-backend-wasm-simd.wasm","tfjs-backend-wasm-threaded-simd.wasm"],Pf=null,hd=null,gd={},bd=!1,m0=!1;function Qfe(e,t=!1){if(Lx("setWasmPath has been deprecated in favor of setWasmPaths and will be removed in a future release."),bd)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPath()` before you call `tf.setBackend()` or `tf.ready()`");Pf=e,m0=t}function eme(e,t=!1){if(bd)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPaths()` before you call `tf.setBackend()` or `tf.ready()`");if(typeof e=="string")hd=e;else{gd=e;let n=Jfe.filter(r=>gd[r]==null);if(n.length>0)throw new Error(`There were no entries found for the following binaries: ${n.join(",")}. Please either call setWasmPaths with a map providing a path for each binary, or with a string indicating the directory where all the binaries can be found.`)}m0=t}var R$=-1,Cx=-1;function tme(e){R$=e}function nme(){if(Cx===-1)throw new Error("WASM backend not initialized.");return Cx}var rme="4.9.0",sme=2;tm("wasm",async()=>{let{wasm:e}=await Yfe();return new F$(e)},sme);var j1="4.9.0",ame="4.9.0",ome="4.9.0",ime="4.9.0",ume="4.9.0",cme={tfjs:j1,"tfjs-core":j1,"tfjs-converter":ame,"tfjs-backend-cpu":ome,"tfjs-backend-webgl":ime,"tfjs-backend-wasm":ume};var W0={};Ph(W0,{AnchorPosition:()=>$0,DrawBox:()=>Vp,DrawBoxOptions:()=>lg,DrawFaceLandmarks:()=>wg,DrawFaceLandmarksOptions:()=>xg,DrawTextField:()=>Gs,DrawTextFieldOptions:()=>$l,drawContour:()=>Ws,drawDetections:()=>yme,drawFaceExpressions:()=>kme,drawFaceLandmarks:()=>Cme});function Ws(e,t,n=!1){if(e.beginPath(),t.slice(1).forEach(({x:r,y:s},a)=>{let o=t[a];e.moveTo(o.x,o.y),e.lineTo(r,s)}),n){let r=t[t.length-1],s=t[0];if(!r||!s)return;e.moveTo(r.x,r.y),e.lineTo(s.x,s.y)}e.stroke()}var v0={};Ph(v0,{computeReshapedDimensions:()=>y0,getCenterPoint:()=>ou,isDimensions:()=>ug,isEven:()=>ig,isFloat:()=>b0,isTensor:()=>su,isTensor1D:()=>lme,isTensor2D:()=>g0,isTensor3D:()=>Vs,isTensor4D:()=>xr,isValidNumber:()=>Jr,isValidProbablitiy:()=>El,range:()=>xs,round:()=>au});var In=class{_width;_height;constructor(t,n){if(!Jr(t)||!Jr(n))throw new Error(`Dimensions.constructor - expected width and height to be valid numbers, instead have ${JSON.stringify({width:t,height:n})}`);this._width=t,this._height=n}get width(){return this._width}get height(){return this._height}reverse(){return new In(1/this.width,1/this.height)}};function su(e,t){return e instanceof Te&&e.shape.length===t}function lme(e){return su(e,1)}function g0(e){return su(e,2)}function Vs(e){return su(e,3)}function xr(e){return su(e,4)}function b0(e){return e%1!==0}function ig(e){return e%2===0}function au(e,t=2){let n=10**t;return Math.floor(e*n)/n}function ug(e){return e&&e.width&&e.height}function y0({width:e,height:t},n){let r=n/Math.max(t,e);return new In(Math.round(e*r),Math.round(t*r))}function ou(e){return e.reduce((t,n)=>t.add(n),new Pe(0,0)).div(new Pe(e.length,e.length))}function xs(e,t,n){return Array(e).fill(0).map((r,s)=>t+s*n)}function Jr(e){return!!e&&e!==1/0&&e!==-1/0&&!Number.isNaN(e)||e===0}function El(e){return Jr(e)&&e>=0&&e<=1}var Pe=class{_x;_y;constructor(t,n){this._x=t,this._y=n}get x(){return this._x}get y(){return this._y}add(t){return new Pe(this.x+t.x,this.y+t.y)}sub(t){return new Pe(this.x-t.x,this.y-t.y)}mul(t){return new Pe(this.x*t.x,this.y*t.y)}div(t){return new Pe(this.x/t.x,this.y/t.y)}abs(){return new Pe(Math.abs(this.x),Math.abs(this.y))}magnitude(){return Math.sqrt(this.x**2+this.y**2)}floor(){return new Pe(Math.floor(this.x),Math.floor(this.y))}};var ut=class{static isRect(t){return!!t&&[t.x,t.y,t.width,t.height].every(Jr)}static assertIsValidBox(t,n,r=!1){if(!ut.isRect(t))throw new Error(`${n} - invalid box: ${JSON.stringify(t)}, expected object with properties x, y, width, height`);if(!r&&(t.width<0||t.height<0))throw new Error(`${n} - width (${t.width}) and height (${t.height}) must be positive numbers`)}_x;_y;_width;_height;constructor(t,n=!0){let r=t||{},s=[r.left,r.top,r.right,r.bottom].every(Jr),a=[r.x,r.y,r.width,r.height].every(Jr);if(!a&&!s)throw new Error(`Box.constructor - expected box to be IBoundingBox | IRect, instead have ${JSON.stringify(r)}`);let[o,i,u,c]=a?[r.x,r.y,r.width,r.height]:[r.left,r.top,r.right-r.left,r.bottom-r.top];ut.assertIsValidBox({x:o,y:i,width:u,height:c},"Box.constructor",n),this._x=o,this._y=i,this._width=u,this._height=c}get x(){return this._x}get y(){return this._y}get width(){return this._width}get height(){return this._height}get left(){return this.x}get top(){return this.y}get right(){return this.x+this.width}get bottom(){return this.y+this.height}get area(){return this.width*this.height}get topLeft(){return new Pe(this.left,this.top)}get topRight(){return new Pe(this.right,this.top)}get bottomLeft(){return new Pe(this.left,this.bottom)}get bottomRight(){return new Pe(this.right,this.bottom)}round(){let[t,n,r,s]=[this.x,this.y,this.width,this.height].map(a=>Math.round(a));return new ut({x:t,y:n,width:r,height:s})}floor(){let[t,n,r,s]=[this.x,this.y,this.width,this.height].map(a=>Math.floor(a));return new ut({x:t,y:n,width:r,height:s})}toSquare(){let{x:t,y:n,width:r,height:s}=this,a=Math.abs(r-s);return r<s&&(t-=a/2,r+=a),s<r&&(n-=a/2,s+=a),new ut({x:t,y:n,width:r,height:s})}rescale(t){let n=ug(t)?t.width:t,r=ug(t)?t.height:t;return new ut({x:this.x*n,y:this.y*r,width:this.width*n,height:this.height*r})}pad(t,n){let[r,s,a,o]=[this.x-t/2,this.y-n/2,this.width+t,this.height+n];return new ut({x:r,y:s,width:a,height:o})}clipAtImageBorders(t,n){let{x:r,y:s,right:a,bottom:o}=this,i=Math.max(r,0),u=Math.max(s,0),c=a-i,l=o-u,p=Math.min(c,t-i),d=Math.min(l,n-u);return new ut({x:i,y:u,width:p,height:d}).floor()}shift(t,n){let{width:r,height:s}=this,a=this.x+t,o=this.y+n;return new ut({x:a,y:o,width:r,height:s})}padAtBorders(t,n){let r=this.width+1,s=this.height+1,a=1,o=1,i=r,u=s,c=this.left,l=this.top,p=this.right,d=this.bottom;return p>n&&(i=-p+n+r,p=n),d>t&&(u=-d+t+s,d=t),c<1&&(u=2-c,c=1),l<1&&(u=2-l,l=1),{dy:o,edy:u,dx:a,edx:i,y:l,ey:d,x:c,ex:p,w:r,h:s}}calibrate(t){return new ut({left:this.left+t.left*this.width,top:this.top+t.top*this.height,right:this.right+t.right*this.width,bottom:this.bottom+t.bottom*this.height}).toSquare().round()}};var iu=class extends ut{constructor(t,n,r,s,a=!1){super({left:t,top:n,right:r,bottom:s},a)}};var Us=class{_score;_classScore;_className;_box;_imageDims;constructor(t,n,r,s,a){this._imageDims=new In(a.width,a.height),this._score=t,this._classScore=n,this._className=r,this._box=new ut(s).rescale(this._imageDims)}get score(){return this._score}get classScore(){return this._classScore}get className(){return this._className}get box(){return this._box}get imageDims(){return this._imageDims}get imageWidth(){return this.imageDims.width}get imageHeight(){return this.imageDims.height}get relativeBox(){return new ut(this._box).rescale(this.imageDims.reverse())}forSize(t,n){return new Us(this.score,this.classScore,this.className,this.relativeBox,{width:t,height:n})}};var vt=class extends Us{constructor(t,n,r){super(t,t,"",n,r)}forSize(t,n){let{score:r,relativeBox:s,imageDims:a}=super.forSize(t,n);return new vt(r,s,a)}};function x0(e,t,n=!0){let r=Math.max(0,Math.min(e.right,t.right)-Math.max(e.left,t.left)),s=Math.max(0,Math.min(e.bottom,t.bottom)-Math.max(e.top,t.top)),a=r*s;return n?a/(e.area+t.area-a):a/Math.min(e.area,t.area)}function w0(e){let t=e.map(i=>i.x),n=e.map(i=>i.y),r=t.reduce((i,u)=>u<i?u:i,1/0),s=n.reduce((i,u)=>u<i?u:i,1/0),a=t.reduce((i,u)=>i<u?u:i,0),o=n.reduce((i,u)=>i<u?u:i,0);return new iu(r,s,a,o)}function I0(e,t,n,r=!0){let s=t.map((o,i)=>({score:o,boxIndex:i})).sort((o,i)=>o.score-i.score).map(o=>o.boxIndex),a=[];for(;s.length>0;){let o=s.pop();a.push(o);let i=s,u=[];for(let c=0;c<i.length;c++){let l=i[c],p=e[o],d=e[l];u.push(x0(p,d,r))}s=s.filter((c,l)=>u[l]<=n)}return a}function Qr(e,t){return O(()=>{let[n,r,s]=t,a=xn([...e.shape.slice(0,3),1],n,"float32"),o=xn([...e.shape.slice(0,3),1],r,"float32"),i=xn([...e.shape.slice(0,3),1],s,"float32"),u=tt([a,o,i],3);return de(e,u)})}function k0(e,t=!1){return O(()=>{let[n,r]=e.shape.slice(1);if(n===r)return e;let s=Math.abs(n-r),a=Math.round(s*(t?.5:1)),o=n>r?2:1,i=d=>{let h=e.shape.slice();return h[o]=d,xn(h,0,"float32")},u=i(a),c=s-u.shape[o],p=[t&&c?i(c):null,e,u].filter(d=>!!d).map(d=>ae(d,"float32"));return tt(p,o)})}function dme(e){let t=e.slice();for(let n=t.length-1;n>0;n--){let r=Math.floor(Math.random()*(n+1)),s=t[n];t[n]=t[r],t[r]=s}return t}function Wp(e){return 1/(1+Math.exp(-e))}function pme(e){return Math.log(e/(1-e))}var uu=class extends ut{constructor(t,n,r,s,a=!1){super({x:t,y:n,width:r,height:s},a)}};var hme=.5,fme=.43,mme=.45,ir=class{_shift;_positions;_imgDims;constructor(t,n,r=new Pe(0,0)){let{width:s,height:a}=n;this._imgDims=new In(s,a),this._shift=r,this._positions=t.map(o=>o.mul(new Pe(s,a)).add(r))}get shift(){return new Pe(this._shift.x,this._shift.y)}get imageWidth(){return this._imgDims.width}get imageHeight(){return this._imgDims.height}get positions(){return this._positions}get relativePositions(){return this._positions.map(t=>t.sub(this._shift).div(new Pe(this.imageWidth,this.imageHeight)))}forSize(t,n){return new this.constructor(this.relativePositions,{width:t,height:n})}shiftBy(t,n){return new this.constructor(this.relativePositions,this._imgDims,new Pe(t,n))}shiftByPoint(t){return this.shiftBy(t.x,t.y)}align(t,n={}){if(t){let a=t instanceof vt?t.box.floor():new ut(t);return this.shiftBy(a.x,a.y).align(null,n)}let{useDlibAlignment:r,minBoxPadding:s}={useDlibAlignment:!1,minBoxPadding:.2,...n};return r?this.alignDlib():this.alignMinBbox(s)}alignDlib(){let t=this.getRefPointsForAlignment(),[n,r,s]=t,a=p=>s.sub(p).magnitude(),o=(a(n)+a(r))/2,i=Math.floor(o/mme),u=ou(t),c=Math.floor(Math.max(0,u.x-hme*i)),l=Math.floor(Math.max(0,u.y-fme*i));return new uu(c,l,Math.min(i,this.imageWidth+c),Math.min(i,this.imageHeight+l))}alignMinBbox(t){let n=w0(this.positions);return n.pad(n.width*t,n.height*t)}getRefPointsForAlignment(){throw new Error("getRefPointsForAlignment not implemented by base class")}};var S0=class extends ir{getRefPointsForAlignment(){let t=this.positions;return[t[0],t[1],ou([t[3],t[4]])]}};var cu=class extends ir{getJawOutline(){return this.positions.slice(0,17)}getLeftEyeBrow(){return this.positions.slice(17,22)}getRightEyeBrow(){return this.positions.slice(22,27)}getNose(){return this.positions.slice(27,36)}getLeftEye(){return this.positions.slice(36,42)}getRightEye(){return this.positions.slice(42,48)}getMouth(){return this.positions.slice(48,68)}getRefPointsForAlignment(){return[this.getLeftEye(),this.getRightEye(),this.getMouth()].map(ou)}};var Al=class{_label;_distance;constructor(t,n){this._label=t,this._distance=n}get label(){return this._label}get distance(){return this._distance}toString(t=!0){return`${this.label}${t?` (${au(this.distance)})`:""}`}};var Dl=class extends ut{static assertIsValidLabeledBox(t,n){if(ut.assertIsValidBox(t,n),!Jr(t.label))throw new Error(`${n} - expected property label (${t.label}) to be a number`)}_label;constructor(t,n){super(t),this._label=n}get label(){return this._label}};var ws=class{_label;_descriptors;constructor(t,n){if(typeof t!="string")throw new Error("LabeledFaceDescriptors - constructor expected label to be a string");if(!Array.isArray(n)||n.some(r=>!(r instanceof Float32Array)))throw new Error("LabeledFaceDescriptors - constructor expected descriptors to be an array of Float32Array");this._label=t,this._descriptors=n}get label(){return this._label}get descriptors(){return this._descriptors}toJSON(){return{label:this.label,descriptors:this.descriptors.map(t=>Array.from(t))}}static fromJSON(t){let n=t.descriptors.map(r=>new Float32Array(r));return new ws(t.label,n)}};var C0=class extends Dl{static assertIsValidPredictedBox(t,n){if(Dl.assertIsValidLabeledBox(t,n),!El(t.score)||!El(t.classScore))throw new Error(`${n} - expected properties score (${t.score}) and (${t.classScore}) to be a number between [0, 1]`)}_score;_classScore;constructor(t,n,r,s){super(t,n),this._score=r,this._classScore=s}get score(){return this._score}get classScore(){return this._classScore}};function Is(e){return e.detection instanceof vt}function lu(e,t){return{...e,...{detection:t}}}function T0(){let e=window.fetch;if(!e)throw new Error("fetch - missing fetch implementation for browser environment");return{Canvas:HTMLCanvasElement,CanvasRenderingContext2D,Image:HTMLImageElement,ImageData,Video:HTMLVideoElement,createCanvasElement:()=>document.createElement("canvas"),createImageElement:()=>document.createElement("img"),createVideoElement:()=>document.createElement("video"),fetch:e,readFile:()=>{throw new Error("readFile - filesystem not available for browser environment")}}}function cg(e){let t="";return{readFile:e?r=>new Promise((s,a)=>{e.readFile(r,(o,i)=>o?a(o):s(i))}):()=>{throw new Error(`readFile - failed to require fs in nodejs environment with error: ${t}`)}}}function N0(){let e=global.Canvas||global.HTMLCanvasElement,t=global.Image||global.HTMLImageElement,n=global.Video||global.HTMLVideoElement,r=()=>{if(e)return new e;throw new Error("createCanvasElement - missing Canvas implementation for nodejs environment")},s=()=>{if(t)return new t;throw new Error("createImageElement - missing Image implementation for nodejs environment")},a=()=>{if(n)return new n;throw new Error("createVideoElement - missing Video implementation for nodejs environment")},o=global.fetch,i=cg();return{Canvas:e||class{},CanvasRenderingContext2D:global.CanvasRenderingContext2D||class{},Image:t||class{},ImageData:global.ImageData||class{},Video:global.HTMLVideoElement||class{},createCanvasElement:r,createImageElement:s,createVideoElement:a,fetch:o,...i}}function _0(){return typeof window=="object"&&typeof document<"u"&&typeof HTMLImageElement<"u"&&typeof HTMLCanvasElement<"u"&&typeof HTMLVideoElement<"u"&&typeof ImageData<"u"&&typeof CanvasRenderingContext2D<"u"}function E0(){return typeof global=="object"&&typeof process<"u"&&process.versions!=null&&process.versions.node!=null}var cn;function gme(){if(!cn)throw new Error("getEnv - environment is not defined, check isNodejs() and isBrowser()");return cn}function A0(e){cn=e}function D0(){return _0()?A0(T0()):E0()?A0(N0()):null}function bme(e){if(cn||D0(),!cn)throw new Error("monkeyPatch - environment is not defined, check isNodejs() and isBrowser()");let{Canvas:t=cn.Canvas,Image:n=cn.Image}=e;cn.Canvas=t,cn.Image=n,cn.createCanvasElement=e.createCanvasElement||(()=>new t),cn.createImageElement=e.createImageElement||(()=>new n),cn.ImageData=e.ImageData||cn.ImageData,cn.Video=e.Video||cn.Video,cn.fetch=e.fetch||cn.fetch,cn.readFile=e.readFile||cn.readFile}var nt={getEnv:gme,setEnv:A0,initialize:D0,createBrowserEnv:T0,createFileSystem:cg,createNodejsEnv:N0,monkeyPatch:bme,isBrowser:_0,isNodejs:E0};D0();function du(e){return!nt.isNodejs()&&typeof e=="string"?document.getElementById(e):e}function Hn(e){let{Canvas:t,CanvasRenderingContext2D:n}=nt.getEnv();if(e instanceof n)return e;let r=du(e);if(!(r instanceof t))throw new Error("resolveContext2d - expected canvas to be of instance of Canvas");let s=r.getContext("2d",{willReadFrequently:!0});if(!s)throw new Error("resolveContext2d - canvas 2d context is null");return s}var $0=(s=>(s.TOP_LEFT="TOP_LEFT",s.TOP_RIGHT="TOP_RIGHT",s.BOTTOM_LEFT="BOTTOM_LEFT",s.BOTTOM_RIGHT="BOTTOM_RIGHT",s))($0||{}),$l=class{anchorPosition;backgroundColor;fontColor;fontSize;fontStyle;padding;constructor(t={}){let{anchorPosition:n,backgroundColor:r,fontColor:s,fontSize:a,fontStyle:o,padding:i}=t;this.anchorPosition=n||"TOP_LEFT",this.backgroundColor=r||"rgba(0, 0, 0, 0.5)",this.fontColor=s||"rgba(255, 255, 255, 1)",this.fontSize=a||14,this.fontStyle=o||"Georgia",this.padding=i||4}},Gs=class{text;anchor;options;constructor(t,n,r={}){this.text=typeof t=="string"?[t]:t instanceof Gs?t.text:t,this.anchor=n,this.options=new $l(r)}measureWidth(t){let{padding:n}=this.options;return this.text.map(r=>t.measureText(r).width).reduce((r,s)=>r<s?s:r,0)+2*n}measureHeight(){let{fontSize:t,padding:n}=this.options;return this.text.length*t+2*n}getUpperLeft(t,n){let{anchorPosition:r}=this.options,s=r==="BOTTOM_RIGHT"||r==="TOP_RIGHT",a=r==="BOTTOM_LEFT"||r==="BOTTOM_RIGHT",o=this.measureWidth(t),i=this.measureHeight(),u=s?this.anchor.x-o:this.anchor.x,c=a?this.anchor.y-i:this.anchor.y;if(n){let{width:l,height:p}=n,d=Math.max(Math.min(u,l-o),0),h=Math.max(Math.min(c,p-i),0);return{x:d,y:h}}return{x:u,y:c}}draw(t){let n=du(t),r=Hn(n),{backgroundColor:s,fontColor:a,fontSize:o,fontStyle:i,padding:u}=this.options;r.font=`${o}px ${i}`;let c=this.measureWidth(r),l=this.measureHeight();r.fillStyle=s;let p=this.getUpperLeft(r,n);r.fillRect(p.x,p.y,c,l),r.fillStyle=a,this.text.forEach((d,h)=>{let f=u+p.x,g=u+p.y+(h+1)*o;r.fillText(d,f,g)})}};var lg=class{boxColor;lineWidth;drawLabelOptions;label;constructor(t={}){let{boxColor:n,lineWidth:r,label:s,drawLabelOptions:a}=t;this.boxColor=n||"rgba(0, 0, 255, 1)",this.lineWidth=r||2,this.label=s;let o={anchorPosition:"BOTTOM_LEFT",backgroundColor:this.boxColor};this.drawLabelOptions=new $l({...o,...a})}},Vp=class{box;options;constructor(t,n={}){this.box=new ut(t),this.options=new lg(n)}draw(t){let n=Hn(t),{boxColor:r,lineWidth:s}=this.options,{x:a,y:o,width:i,height:u}=this.box;n.strokeStyle=r,n.lineWidth=s,n.strokeRect(a,o,i,u);let{label:c}=this.options;c&&new Gs([c],{x:a-s/2,y:o},this.options.drawLabelOptions).draw(t)}};function yme(e,t){(Array.isArray(t)?t:[t]).forEach(r=>{let s=r instanceof vt?r.score:Is(r)?r.detection.score:void 0,a=r instanceof vt?r.box:Is(r)?r.detection.box:new ut(r),o=s?`${au(s)}`:void 0;new Vp(a,{label:o}).draw(e)})}function Up(e){let{Image:t,Video:n}=nt.getEnv();return e instanceof t&&e.complete||e instanceof n&&e.readyState>=3}function F0(e){return new Promise((t,n)=>{(e instanceof nt.getEnv().Canvas||Up(e))&&t(null);function r(a){a.currentTarget&&(a.currentTarget.removeEventListener("load",s),a.currentTarget.removeEventListener("error",r),n(a))}function s(a){a.currentTarget&&(a.currentTarget.removeEventListener("load",s),a.currentTarget.removeEventListener("error",r),t(a))}e.addEventListener("load",s),e.addEventListener("error",r)})}function R0(e){return new Promise((t,n)=>{e instanceof Blob||n(new Error("bufferToImage - expected buf to be of type: Blob"));let r=new FileReader;r.onload=()=>{typeof r.result!="string"&&n(new Error("bufferToImage - expected reader.result to be a string, in onload"));let s=nt.getEnv().createImageElement();s.onload=()=>t(s),s.onerror=n,s.src=r.result},r.onerror=n,r.readAsDataURL(e)})}function pu(e){let{Image:t,Video:n}=nt.getEnv();return e instanceof t?new In(e.naturalWidth,e.naturalHeight):e instanceof n?new In(e.videoWidth,e.videoHeight):new In(e.width,e.height)}function hu({width:e,height:t}){let{createCanvasElement:n}=nt.getEnv(),r=n();return r.width=e,r.height=t,r}function Gp(e,t){let{ImageData:n}=nt.getEnv();if(!(e instanceof n)&&!Up(e))throw new Error("createCanvasFromMedia - media has not finished loading yet");let{width:r,height:s}=t||pu(e),a=hu({width:r,height:s});return e instanceof n?Hn(a).putImageData(e,0,0):Hn(a).drawImage(e,0,0,r,s),a}async function P0(e,t){let n=t||nt.getEnv().createCanvasElement(),[r,s,a]=e.shape.slice(xr(e)?1:0),o=O(()=>e.as3D(r,s,a).toInt());return await Yi.toPixels(o,n),o.dispose(),n}function dg(e){let{Image:t,Canvas:n,Video:r}=nt.getEnv();return e instanceof t||e instanceof n||e instanceof r}function O0(e,t,n=!1){let{Image:r,Canvas:s}=nt.getEnv();if(!(e instanceof r||e instanceof s))throw new Error("imageToSquare - expected arg0 to be HTMLImageElement | HTMLCanvasElement");if(t<=0)return hu({width:1,height:1});let a=pu(e),o=t/Math.max(a.height,a.width),i=o*a.width,u=o*a.height,c=hu({width:t,height:t}),l=e instanceof s?e:Gp(e),p=Math.abs(i-u)/2,d=n&&i<u?p:0,h=n&&u<i?p:0;return l.width>0&&l.height>0&&Hn(c).drawImage(l,d,h,i,u),c}var ks=class{_imageTensors=[];_canvases=[];_batchSize;_treatAsBatchInput=!1;_inputDimensions=[];_inputSize=0;constructor(t,n=!1){if(!Array.isArray(t))throw new Error(`NetInput.constructor - expected inputs to be an Array of TResolvedNetInput or to be instanceof tf.Tensor4D, instead have ${t}`);this._treatAsBatchInput=n,this._batchSize=t.length,t.forEach((r,s)=>{if(Vs(r)){this._imageTensors[s]=r,this._inputDimensions[s]=r.shape;return}if(xr(r)){let o=r.shape[0];if(o!==1)throw new Error(`NetInput - tf.Tensor4D with batchSize ${o} passed, but not supported in input array`);this._imageTensors[s]=r,this._inputDimensions[s]=r.shape.slice(1);return}let a=r instanceof nt.getEnv().Canvas?r:Gp(r);this._canvases[s]=a,this._inputDimensions[s]=[a.height,a.width,3]})}get imageTensors(){return this._imageTensors}get canvases(){return this._canvases}get isBatchInput(){return this.batchSize>1||this._treatAsBatchInput}get batchSize(){return this._batchSize}get inputDimensions(){return this._inputDimensions}get inputSize(){return this._inputSize}get reshapedInputDimensions(){return xs(this.batchSize,0,1).map((t,n)=>this.getReshapedInputDimensions(n))}getInput(t){return this.canvases[t]||this.imageTensors[t]}getInputDimensions(t){return this._inputDimensions[t]}getInputHeight(t){return this._inputDimensions[t][0]}getInputWidth(t){return this._inputDimensions[t][1]}getReshapedInputDimensions(t){if(typeof this.inputSize!="number")throw new Error("getReshapedInputDimensions - inputSize not set, toBatchTensor has not been called yet");let n=this.getInputWidth(t),r=this.getInputHeight(t);return y0({width:n,height:r},this.inputSize)}toBatchTensor(t,n=!0){return this._inputSize=t,O(()=>{let r=xs(this.batchSize,0,1).map(a=>{let o=this.getInput(a);if(o instanceof Te){let i=xr(o)?o:jt(o);return i=k0(i,n),(i.shape[1]!==t||i.shape[2]!==t)&&(i=tr.resizeBilinear(i,[t,t],!1,!1)),i.as3D(t,t,3)}if(o instanceof nt.getEnv().Canvas)return Yi.fromPixels(O0(o,t,n));throw new Error(`toBatchTensor - at batchIdx ${a}, expected input to be instanceof tf.Tensor or instanceof HTMLCanvasElement, instead have ${o}`)});return Rt(r.map(a=>ae(a,"float32"))).as4D(this.batchSize,t,t,3)})}};async function xt(e){if(e instanceof ks)return e;let t=Array.isArray(e)?e:[e];if(!t.length)throw new Error("toNetInput - empty array passed as input");let n=s=>Array.isArray(e)?` at input index ${s}:`:"",r=t.map(du);return r.forEach((s,a)=>{if(!dg(s)&&!Vs(s)&&!xr(s))throw typeof t[a]=="string"?new Error(`toNetInput -${n(a)} string passed, but could not resolve HTMLElement for element id ${t[a]}`):new Error(`toNetInput -${n(a)} expected media to be of type HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | tf.Tensor3D, or to be an element id`);if(xr(s)){let o=s.shape[0];if(o!==1)throw new Error(`toNetInput -${n(a)} tf.Tensor4D with batchSize ${o} passed, but not supported in input array`)}}),await Promise.all(r.map(s=>dg(s)&&F0(s))),new ks(r,Array.isArray(e))}async function Fl(e,t){let{Canvas:n}=nt.getEnv(),r=e;if(!(e instanceof n)){let o=await xt(e);if(o.batchSize>1)throw new Error("extractFaces - batchSize > 1 not supported");let i=o.getInput(0);r=i instanceof n?i:await P0(i)}let s=Hn(r);return t.map(o=>o instanceof vt?o.forSize(r.width,r.height).box.floor():o).map(o=>o.clipAtImageBorders(r.width,r.height)).map(({x:o,y:i,width:u,height:c})=>{let l=hu({width:u,height:c});return u>0&&c>0&&Hn(l).putImageData(s.getImageData(o,i,u,c),0,0),l})}async function Rl(e,t){if(!Vs(e)&&!xr(e))throw new Error("extractFaceTensors - expected image tensor to be 3D or 4D");if(xr(e)&&e.shape[0]>1)throw new Error("extractFaceTensors - batchSize > 1 not supported");return O(()=>{let[n,r,s]=e.shape.slice(xr(e)?1:0);return t.map(i=>i instanceof vt?i.forSize(r,n).box:i).map(i=>i.clipAtImageBorders(r,n)).filter(i=>i.width>0&&i.height>0).map(({x:i,y:u,width:c,height:l})=>Ki(e.as3D(n,r,s),[u,i,0],[l,c,s]))})}async function Hs(e,t){let{fetch:n}=nt.getEnv(),r=await n(e,t);if(!(r.status<400))throw new Error(`failed to fetch: (${r.status}) ${r.statusText}, from url: ${r.url}`);return r}async function vme(e){let t=await Hs(e),n=await t.blob();if(!n.type.startsWith("image/"))throw new Error(`fetchImage - expected blob type to be of type image/*, instead have: ${n.type}, for url: ${t.url}`);return R0(n)}async function M0(e){return(await Hs(e)).json()}async function xme(e){return new Float32Array(await(await Hs(e)).arrayBuffer())}function P$(e){return new Promise((t,n)=>{e instanceof Blob||n(new Error("bufferToVideo - expected buf to be of type: Blob"));let r=nt.getEnv().createVideoElement();r.oncanplay=()=>t(r),r.onerror=n,r.playsInline=!0,r.muted=!0,r.src=URL.createObjectURL(e),r.play()})}async function wme(e){let t=await Hs(e),n=await t.blob();if(!n.type.startsWith("video/"))throw new Error(`fetchVideo - expected blob type to be of type video/*, instead have: ${n.type}, for url: ${t.url}`);return P$(n)}function pg(e,t){let n=`${t}-weights_manifest.json`;if(!e)return{modelBaseUri:"",manifestUri:n};if(e==="/")return{modelBaseUri:"/",manifestUri:`/${n}`};let r=e.startsWith("http://")?"http://":e.startsWith("https://")?"https://":"";e=e.replace(r,"");let s=e.split("/").filter(i=>i),a=e.endsWith(".json")?s[s.length-1]:n,o=r+(e.endsWith(".json")?s.slice(0,s.length-1):s).join("/");return o=e.startsWith("/")?`/${o}`:o,{modelBaseUri:o,manifestUri:o==="/"?`/${a}`:`${o}/${a}`}}async function L0(e,t){let{manifestUri:n,modelBaseUri:r}=pg(e,t),s=await M0(n);return Kt.loadWeights(s,r)}function Ime(e,t,n=!1){let{width:r,height:s}=n?pu(t):t;return e.width=r,e.height=s,{width:r,height:s}}var ln=class{constructor(t){this._name=t}_params=void 0;_paramMappings=[];_name;get params(){return this._params}get paramMappings(){return this._paramMappings}get isLoaded(){return!!this.params}getParamFromPath(t){let{obj:n,objProp:r}=this.traversePropertyPath(t);return n[r]}reassignParamFromPath(t,n){let{obj:r,objProp:s}=this.traversePropertyPath(t);r[s].dispose(),r[s]=n}getParamList(){return this._paramMappings.map(({paramPath:t})=>({path:t,tensor:this.getParamFromPath(t)}))}getTrainableParams(){return this.getParamList().filter(t=>t.tensor instanceof fa)}getFrozenParams(){return this.getParamList().filter(t=>!(t.tensor instanceof fa))}variable(){this.getFrozenParams().forEach(({path:t,tensor:n})=>{this.reassignParamFromPath(t,n.variable())})}freeze(){this.getTrainableParams().forEach(({path:t,tensor:n})=>{let r=yn(n.dataSync());n.dispose(),this.reassignParamFromPath(t,r)})}dispose(t=!0){this.getParamList().forEach(n=>{if(t&&n.tensor.isDisposed)throw new Error(`param tensor has already been disposed for path ${n.path}`);n.tensor.dispose()}),this._params=void 0}serializeParams(){return new Float32Array(this.getParamList().map(({tensor:t})=>Array.from(t.dataSync())).reduce((t,n)=>t.concat(n)))}async load(t){if(t instanceof Float32Array){this.extractWeights(t);return}await this.loadFromUri(t)}async loadFromUri(t){if(t&&typeof t!="string")throw new Error(`${this._name}.loadFromUri - expected model uri`);let n=await L0(t,this.getDefaultModelName());this.loadFromWeightMap(n)}async loadFromDisk(t){if(t&&typeof t!="string")throw new Error(`${this._name}.loadFromDisk - expected model file path`);let{readFile:n}=nt.getEnv(),{manifestUri:r,modelBaseUri:s}=pg(t,this.getDefaultModelName()),a=c=>Promise.all(c.map(l=>n(l).then(p=>p.buffer))),o=Kt.weightsLoaderFactory(a),i=JSON.parse((await n(r)).toString()),u=await o(i,s);this.loadFromWeightMap(u)}loadFromWeightMap(t){let{paramMappings:n,params:r}=this.extractParamsFromWeightMap(t);this._paramMappings=n,this._params=r}extractWeights(t){let{paramMappings:n,params:r}=this.extractParams(t);this._paramMappings=n,this._params=r}traversePropertyPath(t){if(!this.params)throw new Error("traversePropertyPath - model has no loaded params");let n=t.split("/").reduce((a,o)=>{if(!a.nextObj.hasOwnProperty(o))throw new Error(`traversePropertyPath - object does not have property ${o}, for path ${t}`);return{obj:a.nextObj,objProp:o,nextObj:a.nextObj[o]}},{nextObj:this.params}),{obj:r,objProp:s}=n;if(!r||!s||!(r[s]instanceof Te))throw new Error(`traversePropertyPath - parameter is not a tensor, for path ${t}`);return{obj:r,objProp:s}}};function jn(e,t,n){return O(()=>{let r=Fa(e,t.depthwise_filter,t.pointwise_filter,n,"same");return r=X(r,t.bias),r})}function hg(e,t,n=!1){return O(()=>{let r=Ke(n?X(Pt(e,t.conv0.filters,[2,2],"same"),t.conv0.bias):jn(e,t.conv0,[2,2])),s=jn(r,t.conv1,[1,1]),a=Ke(X(r,s)),o=jn(a,t.conv2,[1,1]);return Ke(X(r,X(s,o)))})}function Hp(e,t,n=!1,r=!0){return O(()=>{let s=Ke(n?X(Pt(e,t.conv0.filters,r?[2,2]:[1,1],"same"),t.conv0.bias):jn(e,t.conv0,r?[2,2]:[1,1])),a=jn(s,t.conv1,[1,1]),o=Ke(X(s,a)),i=jn(o,t.conv2,[1,1]),u=Ke(X(s,X(a,i))),c=jn(u,t.conv3,[1,1]);return Ke(X(s,X(a,X(i,c))))})}function fu(e,t,n="same",r=!1){return O(()=>{let s=X(Pt(e,t.filters,[1,1],n),t.bias);return r?Ke(s):s})}function Fn(e,t){Object.keys(e).forEach(n=>{t.some(r=>r.originalPath===n)||e[n].dispose()})}function Pl(e,t){return(n,r,s,a)=>{let o=Or(e(n*r*s*s),[s,s,n,r]),i=He(e(r));return t.push({paramPath:`${a}/filters`},{paramPath:`${a}/bias`}),{filters:o,bias:i}}}function fg(e,t){return(n,r,s)=>{let a=Fr(e(n*r),[n,r]),o=He(e(r));return t.push({paramPath:`${s}/weights`},{paramPath:`${s}/bias`}),{weights:a,bias:o}}}var jp=class{constructor(t,n,r){this.depthwise_filter=t;this.pointwise_filter=n;this.bias=r}};function Ol(e,t){return(n,r,s)=>{let a=Or(e(9*n),[3,3,n,1]),o=Or(e(n*r),[1,1,n,r]),i=He(e(r));return t.push({paramPath:`${s}/depthwise_filter`},{paramPath:`${s}/pointwise_filter`},{paramPath:`${s}/bias`}),new jp(a,o,i)}}function Ml(e){return t=>{let n=e(`${t}/depthwise_filter`,4),r=e(`${t}/pointwise_filter`,4),s=e(`${t}/bias`,1);return new jp(n,r,s)}}function ur(e,t){return(n,r,s)=>{let a=e[n];if(!su(a,r))throw new Error(`expected weightMap[${n}] to be a Tensor${r}D, instead have ${a}`);return t.push({originalPath:n,paramPath:s||n}),a}}function Rn(e){let t=e;function n(s){let a=t.slice(0,s);return t=t.slice(s),a}function r(){return t}return{extractWeights:n,getRemainingWeights:r}}function mg(e,t){let n=Pl(e,t),r=Ol(e,t);function s(o,i,u,c=!1){let l=c?n(o,i,3,`${u}/conv0`):r(o,i,`${u}/conv0`),p=r(i,i,`${u}/conv1`),d=r(i,i,`${u}/conv2`);return{conv0:l,conv1:p,conv2:d}}function a(o,i,u,c=!1){let{conv0:l,conv1:p,conv2:d}=s(o,i,u,c),h=r(i,i,`${u}/conv3`);return{conv0:l,conv1:p,conv2:d,conv3:h}}return{extractDenseBlock3Params:s,extractDenseBlock4Params:a}}function O$(e){let t=[],{extractWeights:n,getRemainingWeights:r}=Rn(e),{extractDenseBlock4Params:s}=mg(n,t),a=s(3,32,"dense0",!0),o=s(32,64,"dense1"),i=s(64,128,"dense2"),u=s(128,256,"dense3");if(r().length!==0)throw new Error(`weights remaing after extract: ${r().length}`);return{paramMappings:t,params:{dense0:a,dense1:o,dense2:i,dense3:u}}}function gg(e){return t=>{let n=e(`${t}/filters`,4),r=e(`${t}/bias`,1);return{filters:n,bias:r}}}function bg(e,t){let n=ur(e,t),r=gg(n),s=Ml(n);function a(i,u=!1){let c=u?r(`${i}/conv0`):s(`${i}/conv0`),l=s(`${i}/conv1`),p=s(`${i}/conv2`);return{conv0:c,conv1:l,conv2:p}}function o(i,u=!1){let c=u?r(`${i}/conv0`):s(`${i}/conv0`),l=s(`${i}/conv1`),p=s(`${i}/conv2`),d=s(`${i}/conv3`);return{conv0:c,conv1:l,conv2:p,conv3:d}}return{extractDenseBlock3Params:a,extractDenseBlock4Params:o}}function M$(e){let t=[],{extractDenseBlock4Params:n}=bg(e,t),r={dense0:n("dense0",!0),dense1:n("dense1"),dense2:n("dense2"),dense3:n("dense3")};return Fn(e,t),{params:r,paramMappings:t}}var Ll=class extends ln{constructor(){super("FaceFeatureExtractor")}forwardInput(t){let{params:n}=this;if(!n)throw new Error("FaceFeatureExtractor - load model before inference");return O(()=>{let r=ae(t.toBatchTensor(112,!0),"float32"),a=Qr(r,[122.782,117.001,104.298]).div(255),o=Hp(a,n.dense0,!0);return o=Hp(o,n.dense1),o=Hp(o,n.dense2),o=Hp(o,n.dense3),o=br(o,[7,7],[2,2],"valid"),o})}async forward(t){return this.forwardInput(await xt(t))}getDefaultModelName(){return"face_feature_extractor_model"}extractParamsFromWeightMap(t){return M$(t)}extractParams(t){return O$(t)}};function qp(e,t){return O(()=>X(Fe(e,t.weights),t.bias))}function L$(e,t,n){let r=[],{extractWeights:s,getRemainingWeights:a}=Rn(e),i=fg(s,r)(t,n,"fc");if(a().length!==0)throw new Error(`weights remaing after extract: ${a().length}`);return{paramMappings:r,params:{fc:i}}}function z$(e){let t=[],n=ur(e,t);function r(a){let o=n(`${a}/weights`,2),i=n(`${a}/bias`,1);return{weights:o,bias:i}}let s={fc:r("fc")};return Fn(e,t),{params:s,paramMappings:t}}function yg(e){let t={},n={};return Object.keys(e).forEach(r=>{let s=r.startsWith("fc")?n:t;s[r]=e[r]}),{featureExtractorMap:t,classifierMap:n}}var zl=class extends ln{_faceFeatureExtractor;constructor(t,n){super(t),this._faceFeatureExtractor=n}get faceFeatureExtractor(){return this._faceFeatureExtractor}runNet(t){let{params:n}=this;if(!n)throw new Error(`${this._name} - load model before inference`);return O(()=>{let r=t instanceof ks?this.faceFeatureExtractor.forwardInput(t):t;return qp(r.as2D(r.shape[0],-1),n.fc)})}dispose(t=!0){this.faceFeatureExtractor.dispose(t),super.dispose(t)}loadClassifierParams(t){let{params:n,paramMappings:r}=this.extractClassifierParams(t);this._params=n,this._paramMappings=r}extractClassifierParams(t){return L$(t,this.getClassifierChannelsIn(),this.getClassifierChannelsOut())}extractParamsFromWeightMap(t){let{featureExtractorMap:n,classifierMap:r}=yg(t);return this.faceFeatureExtractor.loadFromWeightMap(n),z$(r)}extractParams(t){let n=this.getClassifierChannelsIn(),r=this.getClassifierChannelsOut(),s=r*n+r,a=t.slice(0,t.length-s),o=t.slice(t.length-s);return this.faceFeatureExtractor.extractWeights(a),this.extractClassifierParams(o)}};var z0=["neutral","happy","sad","angry","fearful","disgusted","surprised"],js=class{neutral=0;happy=0;sad=0;angry=0;fearful=0;disgusted=0;surprised=0;constructor(t){if(t.length!==7)throw new Error(`FaceExpressions.constructor - expected probabilities.length to be 7, have: ${t.length}`);z0.forEach((n,r)=>{this[n]=t[r]})}asSortedArray(){return z0.map(t=>({expression:t,probability:this[t]})).sort((t,n)=>n.probability-t.probability)}};var Kp=class extends zl{constructor(t=new Ll){super("FaceExpressionNet",t)}forwardInput(t){return O(()=>Yr(this.runNet(t)))}async forward(t){return this.forwardInput(await xt(t))}async predictExpressions(t){let n=await xt(t),r=await this.forwardInput(n),s=await Promise.all(dt(r).map(async o=>{let i=o.dataSync();return o.dispose(),i}));r.dispose();let a=s.map(o=>new js(o));return n.isBatchInput?a:a[0]}getDefaultModelName(){return"face_expression_model"}getClassifierChannelsIn(){return 256}getClassifierChannelsOut(){return 7}};function B0(e){return e.expressions instanceof js}function vg(e,t){return{...e,...{expressions:t}}}function kme(e,t,n=.1,r){(Array.isArray(t)?t:[t]).forEach(a=>{let o=a instanceof js?a:B0(a)?a.expressions:void 0;if(!o)throw new Error("drawFaceExpressions - expected faceExpressions to be FaceExpressions | WithFaceExpressions<{}> or array thereof");let u=o.asSortedArray().filter(p=>p.probability>n),c=Is(a)?a.detection.box.bottomLeft:r||new Pe(0,0);new Gs(u.map(p=>`${p.expression} (${au(p.probability)})`),c).draw(e)})}function mu(e){return Is(e)&&e.landmarks instanceof ir&&e.unshiftedLandmarks instanceof ir&&e.alignedRect instanceof vt}function Sme(e){let t=u=>u*180/Math.PI,n=(u,c)=>Math.sqrt((u._x-c._x)**2+(u._y-c._y)**2),r={roll:void 0,pitch:void 0,yaw:void 0},s=(u,c,l)=>{let p=Math.floor(u._x-c._x),d=Math.floor(c._x-l._x);return p-d},a=(u,c)=>{let l=Math.hypot(c._x-u._x,c._y-u._y),p=c._y-u._y,d=Math.asin(p/l),h=t(d),f=Math.floor(90-h),g=c._x-u._x<0?-1:1;return f*g},o=(u,c,l)=>{let p=n(u,l),d={_x:(u._x+l._x)/2,_y:(u._y+l._y)/2},h=n(c,d),f=Math.atan(h/p),g=Math.floor(t(f)),m=d._y-c._y<0?-1:1;return g*m};if(!e||!e._positions||e._positions.length!==68)return r;let i=e._positions;return r.roll=a(i[27],i[66]),r.pitch=o(i[14],i[30],i[2]),r.yaw=s(i[14],i[33],i[2]),r}function Bl(e,t){let{box:n}=e.detection,r=t.shiftBy(n.x,n.y),s=r.align(),{imageDims:a}=e.detection,o=new vt(e.detection.score,s.rescale(a.reverse()),a),i=Sme(t);return{...e,...{landmarks:r,unshiftedLandmarks:t,alignedRect:o,angle:i}}}var xg=class{drawLines;drawPoints;lineWidth;pointSize;lineColor;pointColor;constructor(t={}){let{drawLines:n=!0,drawPoints:r=!0,lineWidth:s,lineColor:a,pointSize:o,pointColor:i}=t;this.drawLines=n,this.drawPoints=r,this.lineWidth=s||1,this.pointSize=o||2,this.lineColor=a||"rgba(0, 255, 255, 1)",this.pointColor=i||"rgba(255, 0, 255, 1)"}},wg=class{faceLandmarks;options;constructor(t,n={}){this.faceLandmarks=t,this.options=new xg(n)}draw(t){let n=Hn(t),{drawLines:r,drawPoints:s,lineWidth:a,lineColor:o,pointSize:i,pointColor:u}=this.options;if(r&&this.faceLandmarks instanceof cu&&(n.strokeStyle=o,n.lineWidth=a,Ws(n,this.faceLandmarks.getJawOutline()),Ws(n,this.faceLandmarks.getLeftEyeBrow()),Ws(n,this.faceLandmarks.getRightEyeBrow()),Ws(n,this.faceLandmarks.getNose()),Ws(n,this.faceLandmarks.getLeftEye(),!0),Ws(n,this.faceLandmarks.getRightEye(),!0),Ws(n,this.faceLandmarks.getMouth(),!0)),s){n.strokeStyle=u,n.fillStyle=u;let c=l=>{n.beginPath(),n.arc(l.x,l.y,i,0,2*Math.PI),n.fill()};this.faceLandmarks.positions.forEach(c)}}};function Cme(e,t){(Array.isArray(t)?t:[t]).forEach(r=>{let s=r instanceof ir?r:mu(r)?r.landmarks:void 0;if(!s)throw new Error("drawFaceLandmarks - expected faceExpressions to be FaceLandmarks | WithFaceLandmarks<WithFaceDetection<{}>> or array thereof");new wg(s).draw(e)})}var B$="1.7.12";function _me(e,t){let n=Pl(e,t),r=Ol(e,t);function s(o,i,u){let c=r(o,i,`${u}/separable_conv0`),l=r(i,i,`${u}/separable_conv1`),p=n(o,i,1,`${u}/expansion_conv`);return{separable_conv0:c,separable_conv1:l,expansion_conv:p}}function a(o,i){let u=r(o,o,`${i}/separable_conv0`),c=r(o,o,`${i}/separable_conv1`),l=r(o,o,`${i}/separable_conv2`);return{separable_conv0:u,separable_conv1:c,separable_conv2:l}}return{extractConvParams:n,extractSeparableConvParams:r,extractReductionBlockParams:s,extractMainBlockParams:a}}function W$(e,t){let n=[],{extractWeights:r,getRemainingWeights:s}=Rn(e),{extractConvParams:a,extractSeparableConvParams:o,extractReductionBlockParams:i,extractMainBlockParams:u}=_me(r,n),c=a(3,32,3,"entry_flow/conv_in"),l=i(32,64,"entry_flow/reduction_block_0"),p=i(64,128,"entry_flow/reduction_block_1"),d={conv_in:c,reduction_block_0:l,reduction_block_1:p},h={};xs(t,0,1).forEach(b=>{h[`main_block_${b}`]=u(128,`middle_flow/main_block_${b}`)});let f=i(128,256,"exit_flow/reduction_block"),g=o(256,512,"exit_flow/separable_conv"),m={reduction_block:f,separable_conv:g};if(s().length!==0)throw new Error(`weights remaing after extract: ${s().length}`);return{paramMappings:n,params:{entry_flow:d,middle_flow:h,exit_flow:m}}}function Eme(e,t){let n=ur(e,t),r=gg(n),s=Ml(n);function a(i){let u=s(`${i}/separable_conv0`),c=s(`${i}/separable_conv1`),l=r(`${i}/expansion_conv`);return{separable_conv0:u,separable_conv1:c,expansion_conv:l}}function o(i){let u=s(`${i}/separable_conv0`),c=s(`${i}/separable_conv1`),l=s(`${i}/separable_conv2`);return{separable_conv0:u,separable_conv1:c,separable_conv2:l}}return{extractConvParams:r,extractSeparableConvParams:s,extractReductionBlockParams:a,extractMainBlockParams:o}}function V$(e,t){let n=[],{extractConvParams:r,extractSeparableConvParams:s,extractReductionBlockParams:a,extractMainBlockParams:o}=Eme(e,n),i=r("entry_flow/conv_in"),u=a("entry_flow/reduction_block_0"),c=a("entry_flow/reduction_block_1"),l={conv_in:i,reduction_block_0:u,reduction_block_1:c},p={};xs(t,0,1).forEach(g=>{p[`main_block_${g}`]=o(`middle_flow/main_block_${g}`)});let d=a("exit_flow/reduction_block"),h=s("exit_flow/separable_conv"),f={reduction_block:d,separable_conv:h};return Fn(e,n),{params:{entry_flow:l,middle_flow:p,exit_flow:f},paramMappings:n}}function U$(e,t,n){return X(Pt(e,t.filters,n,"same"),t.bias)}function V0(e,t,n=!0){let r=n?Ke(e):e;return r=jn(r,t.separable_conv0,[1,1]),r=jn(Ke(r),t.separable_conv1,[1,1]),r=Ot(r,[3,3],[2,2],"same"),r=X(r,U$(e,t.expansion_conv,[2,2])),r}function Ame(e,t){let n=jn(Ke(e),t.separable_conv0,[1,1]);return n=jn(Ke(n),t.separable_conv1,[1,1]),n=jn(Ke(n),t.separable_conv2,[1,1]),n=X(n,e),n}var Ig=class extends ln{_numMainBlocks;constructor(t){super("TinyXception"),this._numMainBlocks=t}forwardInput(t){let{params:n}=this;if(!n)throw new Error("TinyXception - load model before inference");return O(()=>{let r=ae(t.toBatchTensor(112,!0),"float32"),a=Qr(r,[122.782,117.001,104.298]).div(255),o=Ke(U$(a,n.entry_flow.conv_in,[2,2]));return o=V0(o,n.entry_flow.reduction_block_0,!1),o=V0(o,n.entry_flow.reduction_block_1),xs(this._numMainBlocks,0,1).forEach(i=>{o=Ame(o,n.middle_flow[`main_block_${i}`])}),o=V0(o,n.exit_flow.reduction_block),o=Ke(jn(o,n.exit_flow.separable_conv,[1,1])),o})}async forward(t){return this.forwardInput(await xt(t))}getDefaultModelName(){return"tiny_xception_model"}extractParamsFromWeightMap(t){return V$(t,this._numMainBlocks)}extractParams(t){return W$(t,this._numMainBlocks)}};function G$(e){let t=[],{extractWeights:n,getRemainingWeights:r}=Rn(e),s=fg(n,t),a=s(512,1,"fc/age"),o=s(512,2,"fc/gender");if(r().length!==0)throw new Error(`weights remaing after extract: ${r().length}`);return{paramMappings:t,params:{fc:{age:a,gender:o}}}}function H$(e){let t=[],n=ur(e,t);function r(a){let o=n(`${a}/weights`,2),i=n(`${a}/bias`,1);return{weights:o,bias:i}}let s={fc:{age:r("fc/age"),gender:r("fc/gender")}};return Fn(e,t),{params:s,paramMappings:t}}var kg=(n=>(n.FEMALE="female",n.MALE="male",n))(kg||{});var Xp=class extends ln{_faceFeatureExtractor;constructor(t=new Ig(2)){super("AgeGenderNet"),this._faceFeatureExtractor=t}get faceFeatureExtractor(){return this._faceFeatureExtractor}runNet(t){let{params:n}=this;if(!n)throw new Error(`${this._name} - load model before inference`);return O(()=>{let r=t instanceof ks?this.faceFeatureExtractor.forwardInput(t):t,s=br(r,[7,7],[2,2],"valid").as2D(r.shape[0],-1),a=qp(s,n.fc.age).as1D(),o=qp(s,n.fc.gender);return{age:a,gender:o}})}forwardInput(t){return O(()=>{let{age:n,gender:r}=this.runNet(t);return{age:n,gender:Yr(r)}})}async forward(t){return this.forwardInput(await xt(t))}async predictAgeAndGender(t){let n=await xt(t),r=await this.forwardInput(n),s=dt(r.age),a=dt(r.gender),o=s.map((u,c)=>({ageTensor:u,genderTensor:a[c]})),i=await Promise.all(o.map(async({ageTensor:u,genderTensor:c})=>{let l=u.dataSync()[0],p=c.dataSync()[0],d=p>.5,h=d?"male":"female",f=d?p:1-p;return u.dispose(),c.dispose(),{age:l,gender:h,genderProbability:f}}));return r.age.dispose(),r.gender.dispose(),n.isBatchInput?i:i[0]}getDefaultModelName(){return"age_gender_model"}dispose(t=!0){this.faceFeatureExtractor.dispose(t),super.dispose(t)}loadClassifierParams(t){let{params:n,paramMappings:r}=this.extractClassifierParams(t);this._params=n,this._paramMappings=r}extractClassifierParams(t){return G$(t)}extractParamsFromWeightMap(t){let{featureExtractorMap:n,classifierMap:r}=yg(t);return this.faceFeatureExtractor.loadFromWeightMap(n),H$(r)}extractParams(t){let r=t.slice(0,t.length-1539),s=t.slice(t.length-1539);return this.faceFeatureExtractor.extractWeights(r),this.extractClassifierParams(s)}};var Wl=class extends zl{postProcess(t,n,r){let s=r.map(({width:o,height:i})=>{let u=n/Math.max(i,o);return{width:o*u,height:i*u}}),a=s.length;return O(()=>{let o=(p,d)=>Rt([xn([68],p,"float32"),xn([68],d,"float32")],1).as2D(1,136).as1D(),i=(p,d)=>{let{width:h,height:f}=s[p];return d(h,f)?Math.abs(h-f)/2:0},u=p=>i(p,(d,h)=>d<h),c=p=>i(p,(d,h)=>h<d);return t.mul(xn([a,136],n,"float32")).sub(Rt(Array.from(Array(a),(p,d)=>o(u(d),c(d))))).div(Rt(Array.from(Array(a),(p,d)=>o(s[d].width,s[d].height))))})}forwardInput(t){return O(()=>{let n=this.runNet(t);return this.postProcess(n,t.inputSize,t.inputDimensions.map(([r,s])=>({height:r,width:s})))})}async forward(t){return this.forwardInput(await xt(t))}async detectLandmarks(t){let n=await xt(t),r=O(()=>dt(this.forwardInput(n))),s=await Promise.all(r.map(async(a,o)=>{let i=Array.from(a.dataSync()),u=i.filter((l,p)=>ig(p)),c=i.filter((l,p)=>!ig(p));return new cu(Array(68).fill(0).map((l,p)=>new Pe(u[p],c[p])),{height:n.getInputHeight(o),width:n.getInputWidth(o)})}));return r.forEach(a=>a.dispose()),n.isBatchInput?s:s[0]}getClassifierChannelsOut(){return 136}};var gu=class extends Wl{constructor(t=new Ll){super("FaceLandmark68Net",t)}getDefaultModelName(){return"face_landmark_68_model"}getClassifierChannelsIn(){return 256}};function j$(e){let t=[],{extractDenseBlock3Params:n}=bg(e,t),r={dense0:n("dense0",!0),dense1:n("dense1"),dense2:n("dense2")};return Fn(e,t),{params:r,paramMappings:t}}function q$(e){let t=[],{extractWeights:n,getRemainingWeights:r}=Rn(e),{extractDenseBlock3Params:s}=mg(n,t),a=s(3,32,"dense0",!0),o=s(32,64,"dense1"),i=s(64,128,"dense2");if(r().length!==0)throw new Error(`weights remaing after extract: ${r().length}`);return{paramMappings:t,params:{dense0:a,dense1:o,dense2:i}}}var Sg=class extends ln{constructor(){super("TinyFaceFeatureExtractor")}forwardInput(t){let{params:n}=this;if(!n)throw new Error("TinyFaceFeatureExtractor - load model before inference");return O(()=>{let r=ae(t.toBatchTensor(112,!0),"float32"),a=Qr(r,[122.782,117.001,104.298]).div(255),o=hg(a,n.dense0,!0);return o=hg(o,n.dense1),o=hg(o,n.dense2),o=br(o,[14,14],[2,2],"valid"),o})}async forward(t){return this.forwardInput(await xt(t))}getDefaultModelName(){return"face_feature_extractor_tiny_model"}extractParamsFromWeightMap(t){return j$(t)}extractParams(t){return q$(t)}};var Yp=class extends Wl{constructor(t=new Sg){super("FaceLandmark68TinyNet",t)}getDefaultModelName(){return"face_landmark_68_tiny_model"}getClassifierChannelsIn(){return 128}};var U0=class extends gu{};function K$(e,t){return X(B(e,t.weights),t.biases)}function G0(e,t,n,r,s="same"){let{filters:a,bias:o}=t.conv,i=Pt(e,a,n,s);return i=X(i,o),i=K$(i,t.scale),r?Ke(i):i}function X$(e,t){return G0(e,t,[1,1],!0)}function H0(e,t){return G0(e,t,[1,1],!1)}function Cg(e,t){return G0(e,t,[2,2],!0,"valid")}function Dme(e,t){function n(i,u,c){let l=e(i),p=l.length/(u*c*c);if(b0(p))throw new Error(`depth has to be an integer: ${p}, weights.length: ${l.length}, numFilters: ${u}, filterSize: ${c}`);return O(()=>Re(Or(l,[u,p,c,c]),[2,3,1,0]))}function r(i,u,c,l){let p=n(i,u,c),d=He(e(u));return t.push({paramPath:`${l}/filters`},{paramPath:`${l}/bias`}),{filters:p,bias:d}}function s(i,u){let c=He(e(i)),l=He(e(i));return t.push({paramPath:`${u}/weights`},{paramPath:`${u}/biases`}),{weights:c,biases:l}}function a(i,u,c,l){let p=r(i,u,c,`${l}/conv`),d=s(u,`${l}/scale`);return{conv:p,scale:d}}function o(i,u,c,l,p=!1){let d=a((p?.5:1)*i,u,c,`${l}/conv1`),h=a(i,u,c,`${l}/conv2`);return{conv1:d,conv2:h}}return{extractConvLayerParams:a,extractResidualLayerParams:o}}function Y$(e){let{extractWeights:t,getRemainingWeights:n}=Rn(e),r=[],{extractConvLayerParams:s,extractResidualLayerParams:a}=Dme(t,r),o=s(4704,32,7,"conv32_down"),i=a(9216,32,3,"conv32_1"),u=a(9216,32,3,"conv32_2"),c=a(9216,32,3,"conv32_3"),l=a(36864,64,3,"conv64_down",!0),p=a(36864,64,3,"conv64_1"),d=a(36864,64,3,"conv64_2"),h=a(36864,64,3,"conv64_3"),f=a(147456,128,3,"conv128_down",!0),g=a(147456,128,3,"conv128_1"),m=a(147456,128,3,"conv128_2"),b=a(589824,256,3,"conv256_down",!0),v=a(589824,256,3,"conv256_1"),y=a(589824,256,3,"conv256_2"),x=a(589824,256,3,"conv256_down_out"),k=O(()=>Re(Fr(t(256*128),[128,256]),[1,0]));if(r.push({paramPath:"fc"}),n().length!==0)throw new Error(`weights remaing after extract: ${n().length}`);return{params:{conv32_down:o,conv32_1:i,conv32_2:u,conv32_3:c,conv64_down:l,conv64_1:p,conv64_2:d,conv64_3:h,conv128_down:f,conv128_1:g,conv128_2:m,conv256_down:b,conv256_1:v,conv256_2:y,conv256_down_out:x,fc:k},paramMappings:r}}function $me(e,t){let n=ur(e,t);function r(o){let i=n(`${o}/scale/weights`,1),u=n(`${o}/scale/biases`,1);return{weights:i,biases:u}}function s(o){let i=n(`${o}/conv/filters`,4),u=n(`${o}/conv/bias`,1),c=r(o);return{conv:{filters:i,bias:u},scale:c}}function a(o){return{conv1:s(`${o}/conv1`),conv2:s(`${o}/conv2`)}}return{extractConvLayerParams:s,extractResidualLayerParams:a}}function Z$(e){let t=[],{extractConvLayerParams:n,extractResidualLayerParams:r}=$me(e,t),s=n("conv32_down"),a=r("conv32_1"),o=r("conv32_2"),i=r("conv32_3"),u=r("conv64_down"),c=r("conv64_1"),l=r("conv64_2"),p=r("conv64_3"),d=r("conv128_down"),h=r("conv128_1"),f=r("conv128_2"),g=r("conv256_down"),m=r("conv256_1"),b=r("conv256_2"),v=r("conv256_down_out"),{fc:y}=e;if(t.push({originalPath:"fc",paramPath:"fc"}),!g0(y))throw new Error(`expected weightMap[fc] to be a Tensor2D, instead have ${y}`);let x={conv32_down:s,conv32_1:a,conv32_2:o,conv32_3:i,conv64_down:u,conv64_1:c,conv64_2:l,conv64_3:p,conv128_down:d,conv128_1:h,conv128_2:f,conv256_down:g,conv256_1:m,conv256_2:b,conv256_down_out:v,fc:y};return Fn(e,t),{params:x,paramMappings:t}}function es(e,t){let n=X$(e,t.conv1);return n=H0(n,t.conv2),n=X(n,e),n=Ke(n),n}function Zp(e,t){let n=Cg(e,t.conv1);n=H0(n,t.conv2);let r=br(e,2,2,"valid"),s=Ct(r.shape),a=r.shape[3]!==n.shape[3];if(r.shape[1]!==n.shape[1]||r.shape[2]!==n.shape[2]){let i=[...n.shape];i[1]=1;let u=Ct(i);n=tt([n,u],1);let c=[...n.shape];c[2]=1;let l=Ct(c);n=tt([n,l],2)}return r=a?tt([r,s],3):r,n=X(r,n),n=Ke(n),n}var bu=class extends ln{constructor(){super("FaceRecognitionNet")}forwardInput(t){let{params:n}=this;if(!n)throw new Error("FaceRecognitionNet - load model before inference");return O(()=>{let r=ae(t.toBatchTensor(150,!0),"float32"),a=Qr(r,[122.782,117.001,104.298]).div(255),o=Cg(a,n.conv32_down);o=Ot(o,3,2,"valid"),o=es(o,n.conv32_1),o=es(o,n.conv32_2),o=es(o,n.conv32_3),o=Zp(o,n.conv64_down),o=es(o,n.conv64_1),o=es(o,n.conv64_2),o=es(o,n.conv64_3),o=Zp(o,n.conv128_down),o=es(o,n.conv128_1),o=es(o,n.conv128_2),o=Zp(o,n.conv256_down),o=es(o,n.conv256_1),o=es(o,n.conv256_2),o=Zp(o,n.conv256_down_out);let i=o.mean([1,2]);return Fe(i,n.fc)})}async forward(t){return this.forwardInput(await xt(t))}async computeFaceDescriptor(t){if(t?.shape?.some(a=>a<=0))return new Float32Array(128);let n=await xt(t),r=O(()=>dt(this.forwardInput(n))),s=await Promise.all(r.map(a=>a.data()));return r.forEach(a=>a.dispose()),n.isBatchInput?s:s[0]}getDefaultModelName(){return"face_recognition_model"}extractParamsFromWeightMap(t){return Z$(t)}extractParams(t){return Y$(t)}};function Fme(e){let t=new bu;return t.extractWeights(e),t}function Tg(e,t){return{...e,...{descriptor:t}}}function Rme(e){return typeof e.age=="number"}function Ng(e,t){return{...e,...{age:t}}}function Pme(e){return(e.gender==="male"||e.gender==="female")&&El(e.genderProbability)}function _g(e,t,n){return{...e,...{gender:t,genderProbability:n}}}function Ome(e,t){function n(u,c){let l=Or(e(9*u),[3,3,u,1]),p=He(e(u)),d=He(e(u)),h=He(e(u)),f=He(e(u));return t.push({paramPath:`${c}/filters`},{paramPath:`${c}/batch_norm_scale`},{paramPath:`${c}/batch_norm_offset`},{paramPath:`${c}/batch_norm_mean`},{paramPath:`${c}/batch_norm_variance`}),{filters:l,batch_norm_scale:p,batch_norm_offset:d,batch_norm_mean:h,batch_norm_variance:f}}function r(u,c,l,p,d){let h=Or(e(u*c*l*l),[l,l,u,c]),f=He(e(c));return t.push({paramPath:`${p}/filters`},{paramPath:`${p}/${d?"batch_norm_offset":"bias"}`}),{filters:h,bias:f}}function s(u,c,l,p){let{filters:d,bias:h}=r(u,c,l,p,!0);return{filters:d,batch_norm_offset:h}}function a(u,c,l){let p=n(u,`${l}/depthwise_conv`),d=s(u,c,1,`${l}/pointwise_conv`);return{depthwise_conv:p,pointwise_conv:d}}function o(){let u=s(3,32,3,"mobilenetv1/conv_0"),c=a(32,64,"mobilenetv1/conv_1"),l=a(64,128,"mobilenetv1/conv_2"),p=a(128,128,"mobilenetv1/conv_3"),d=a(128,256,"mobilenetv1/conv_4"),h=a(256,256,"mobilenetv1/conv_5"),f=a(256,512,"mobilenetv1/conv_6"),g=a(512,512,"mobilenetv1/conv_7"),m=a(512,512,"mobilenetv1/conv_8"),b=a(512,512,"mobilenetv1/conv_9"),v=a(512,512,"mobilenetv1/conv_10"),y=a(512,512,"mobilenetv1/conv_11"),x=a(512,1024,"mobilenetv1/conv_12"),k=a(1024,1024,"mobilenetv1/conv_13");return{conv_0:u,conv_1:c,conv_2:l,conv_3:p,conv_4:d,conv_5:h,conv_6:f,conv_7:g,conv_8:m,conv_9:b,conv_10:v,conv_11:y,conv_12:x,conv_13:k}}function i(){let u=s(1024,256,1,"prediction_layer/conv_0"),c=s(256,512,3,"prediction_layer/conv_1"),l=s(512,128,1,"prediction_layer/conv_2"),p=s(128,256,3,"prediction_layer/conv_3"),d=s(256,128,1,"prediction_layer/conv_4"),h=s(128,256,3,"prediction_layer/conv_5"),f=s(256,64,1,"prediction_layer/conv_6"),g=s(64,128,3,"prediction_layer/conv_7"),m=r(512,12,1,"prediction_layer/box_predictor_0/box_encoding_predictor"),b=r(512,9,1,"prediction_layer/box_predictor_0/class_predictor"),v=r(1024,24,1,"prediction_layer/box_predictor_1/box_encoding_predictor"),y=r(1024,18,1,"prediction_layer/box_predictor_1/class_predictor"),x=r(512,24,1,"prediction_layer/box_predictor_2/box_encoding_predictor"),k=r(512,18,1,"prediction_layer/box_predictor_2/class_predictor"),S=r(256,24,1,"prediction_layer/box_predictor_3/box_encoding_predictor"),N=r(256,18,1,"prediction_layer/box_predictor_3/class_predictor"),E=r(256,24,1,"prediction_layer/box_predictor_4/box_encoding_predictor"),$=r(256,18,1,"prediction_layer/box_predictor_4/class_predictor"),R=r(128,24,1,"prediction_layer/box_predictor_5/box_encoding_predictor"),D=r(128,18,1,"prediction_layer/box_predictor_5/class_predictor");return{conv_0:u,conv_1:c,conv_2:l,conv_3:p,conv_4:d,conv_5:h,conv_6:f,conv_7:g,box_predictor_0:{box_encoding_predictor:m,class_predictor:b},box_predictor_1:{box_encoding_predictor:v,class_predictor:y},box_predictor_2:{box_encoding_predictor:x,class_predictor:k},box_predictor_3:{box_encoding_predictor:S,class_predictor:N},box_predictor_4:{box_encoding_predictor:E,class_predictor:$},box_predictor_5:{box_encoding_predictor:R,class_predictor:D}}}return{extractMobilenetV1Params:o,extractPredictionLayerParams:i}}function J$(e){let t=[],{extractWeights:n,getRemainingWeights:r}=Rn(e),{extractMobilenetV1Params:s,extractPredictionLayerParams:a}=Ome(n,t),o=s(),i=a(),c={extra_dim:Sp(n(5118*4),[1,5118,4])};if(t.push({paramPath:"output_layer/extra_dim"}),r().length!==0)throw new Error(`weights remaing after extract: ${r().length}`);return{params:{mobilenetv1:o,prediction_layer:i,output_layer:c},paramMappings:t}}function Mme(e,t){let n=ur(e,t);function r(c,l,p){let d=n(`${c}/Conv2d_${l}_pointwise/weights`,4,`${p}/filters`),h=n(`${c}/Conv2d_${l}_pointwise/convolution_bn_offset`,1,`${p}/batch_norm_offset`);return{filters:d,batch_norm_offset:h}}function s(c){let l=`mobilenetv1/conv_${c}`,p=`MobilenetV1/Conv2d_${c}_depthwise`,d=`${l}/depthwise_conv`,h=`${l}/pointwise_conv`,f=n(`${p}/depthwise_weights`,4,`${d}/filters`),g=n(`${p}/BatchNorm/gamma`,1,`${d}/batch_norm_scale`),m=n(`${p}/BatchNorm/beta`,1,`${d}/batch_norm_offset`),b=n(`${p}/BatchNorm/moving_mean`,1,`${d}/batch_norm_mean`),v=n(`${p}/BatchNorm/moving_variance`,1,`${d}/batch_norm_variance`);return{depthwise_conv:{filters:f,batch_norm_scale:g,batch_norm_offset:m,batch_norm_mean:b,batch_norm_variance:v},pointwise_conv:r("MobilenetV1",c,h)}}function a(){return{conv_0:r("MobilenetV1",0,"mobilenetv1/conv_0"),conv_1:s(1),conv_2:s(2),conv_3:s(3),conv_4:s(4),conv_5:s(5),conv_6:s(6),conv_7:s(7),conv_8:s(8),conv_9:s(9),conv_10:s(10),conv_11:s(11),conv_12:s(12),conv_13:s(13)}}function o(c,l){let p=n(`${c}/weights`,4,`${l}/filters`),d=n(`${c}/biases`,1,`${l}/bias`);return{filters:p,bias:d}}function i(c){let l=o(`Prediction/BoxPredictor_${c}/BoxEncodingPredictor`,`prediction_layer/box_predictor_${c}/box_encoding_predictor`),p=o(`Prediction/BoxPredictor_${c}/ClassPredictor`,`prediction_layer/box_predictor_${c}/class_predictor`);return{box_encoding_predictor:l,class_predictor:p}}function u(){return{conv_0:r("Prediction",0,"prediction_layer/conv_0"),conv_1:r("Prediction",1,"prediction_layer/conv_1"),conv_2:r("Prediction",2,"prediction_layer/conv_2"),conv_3:r("Prediction",3,"prediction_layer/conv_3"),conv_4:r("Prediction",4,"prediction_layer/conv_4"),conv_5:r("Prediction",5,"prediction_layer/conv_5"),conv_6:r("Prediction",6,"prediction_layer/conv_6"),conv_7:r("Prediction",7,"prediction_layer/conv_7"),box_predictor_0:i(0),box_predictor_1:i(1),box_predictor_2:i(2),box_predictor_3:i(3),box_predictor_4:i(4),box_predictor_5:i(5)}}return{extractMobilenetV1Params:a,extractPredictionLayerParams:u}}function Q$(e){let t=[],{extractMobilenetV1Params:n,extractPredictionLayerParams:r}=Mme(e,t),s=e["Output/extra_dim"];if(t.push({originalPath:"Output/extra_dim",paramPath:"output_layer/extra_dim"}),!Vs(s))throw new Error(`expected weightMap['Output/extra_dim'] to be a Tensor3D, instead have ${s}`);let a={mobilenetv1:n(),prediction_layer:r(),output_layer:{extra_dim:s}};return Fn(e,t),{params:a,paramMappings:t}}function zr(e,t,n){return O(()=>{let r=Pt(e,t.filters,n,"same");return r=X(r,t.batch_norm_offset),an(r,0,6)})}var Lme=.0010000000474974513;function zme(e,t,n){return O(()=>{let r=Aa(e,t.filters,n,"same");return r=Ea(r,t.batch_norm_mean,t.batch_norm_variance,t.batch_norm_offset,t.batch_norm_scale,Lme),an(r,0,6)})}function Bme(e){return[2,4,6,12].some(t=>t===e)?[2,2]:[1,1]}function eF(e,t){return O(()=>{let n,r=zr(e,t.conv_0,[2,2]);if([t.conv_1,t.conv_2,t.conv_3,t.conv_4,t.conv_5,t.conv_6,t.conv_7,t.conv_8,t.conv_9,t.conv_10,t.conv_11,t.conv_12,t.conv_13].forEach((a,o)=>{let i=o+1,u=Bme(i);r=zme(r,a.depthwise_conv,u),r=zr(r,a.pointwise_conv,[1,1]),i===11&&(n=r)}),n===null)throw new Error("mobileNetV1 - output of conv layer 11 is null");return{out:r,conv11:n}})}function Wme(e,t,n){let r=e.arraySync(),s=Math.min(r[t][0],r[t][2]),a=Math.min(r[t][1],r[t][3]),o=Math.max(r[t][0],r[t][2]),i=Math.max(r[t][1],r[t][3]),u=Math.min(r[n][0],r[n][2]),c=Math.min(r[n][1],r[n][3]),l=Math.max(r[n][0],r[n][2]),p=Math.max(r[n][1],r[n][3]),d=(o-s)*(i-a),h=(l-u)*(p-c);if(d<=0||h<=0)return 0;let f=Math.max(s,u),g=Math.max(a,c),m=Math.min(o,l),b=Math.min(i,p),v=Math.max(m-f,0)*Math.max(b-g,0);return v/(d+h-v)}function tF(e,t,n,r,s){let a=e.shape[0],o=Math.min(n,a),i=t.map((l,p)=>({score:l,boxIndex:p})).filter(l=>l.score>s).sort((l,p)=>p.score-l.score),u=l=>l<=r?1:0,c=[];return i.forEach(l=>{if(c.length>=o)return;let p=l.score;for(let d=c.length-1;d>=0;--d){let h=Wme(e,l.boxIndex,c[d]);if(h!==0&&(l.score*=u(h),l.score<=s))break}p===l.score&&c.push(l.boxIndex)}),c}function Vme(e){let t=dt(Re(e,[1,0])),n=[de(t[2],t[0]),de(t[3],t[1])],r=[X(t[0],fe(n[0],2)),X(t[1],fe(n[1],2))];return{sizes:n,centers:r}}function Ume(e,t){let{sizes:n,centers:r}=Vme(e),s=dt(Re(t,[1,0])),a=fe(B(vn(fe(s[2],5)),n[0]),2),o=X(B(fe(s[0],10),n[0]),r[0]),i=fe(B(vn(fe(s[3],5)),n[1]),2),u=X(B(fe(s[1],10),n[1]),r[1]);return Re(Rt([de(o,a),de(u,i),X(o,a),X(u,i)]),[1,0])}function nF(e,t,n){return O(()=>{let r=e.shape[0],s=Ume(W(Ln(n.extra_dim,[r,1,1]),[-1,4]),W(e,[-1,4]));s=W(s,[r,s.shape[0]/r,4]);let a=hr(Ue(t,[0,0,1],[-1,-1,-1])),o=Ue(a,[0,0,0],[-1,-1,1]);o=W(o,[r,o.shape[1]]);let i=dt(s),u=dt(o);return{boxes:i,scores:u}})}function yu(e,t){return O(()=>{let n=e.shape[0],r=W(fu(e,t.box_encoding_predictor),[n,-1,1,4]),s=W(fu(e,t.class_predictor),[n,-1,3]);return{boxPredictionEncoding:r,classPrediction:s}})}function rF(e,t,n){return O(()=>{let r=zr(e,n.conv_0,[1,1]),s=zr(r,n.conv_1,[2,2]),a=zr(s,n.conv_2,[1,1]),o=zr(a,n.conv_3,[2,2]),i=zr(o,n.conv_4,[1,1]),u=zr(i,n.conv_5,[2,2]),c=zr(u,n.conv_6,[1,1]),l=zr(c,n.conv_7,[2,2]),p=yu(t,n.box_predictor_0),d=yu(e,n.box_predictor_1),h=yu(s,n.box_predictor_2),f=yu(o,n.box_predictor_3),g=yu(u,n.box_predictor_4),m=yu(l,n.box_predictor_5),b=tt([p.boxPredictionEncoding,d.boxPredictionEncoding,h.boxPredictionEncoding,f.boxPredictionEncoding,g.boxPredictionEncoding,m.boxPredictionEncoding],1),v=tt([p.classPrediction,d.classPrediction,h.classPrediction,f.classPrediction,g.classPrediction,m.classPrediction],1);return{boxPredictions:b,classPredictions:v}})}var wr=class{_name="SsdMobilenetv1Options";_minConfidence;_maxResults;constructor({minConfidence:t,maxResults:n}={}){if(this._minConfidence=t||.5,this._maxResults=n||100,typeof this._minConfidence!="number"||this._minConfidence<=0||this._minConfidence>=1)throw new Error(`${this._name} - expected minConfidence to be a number between 0 and 1`);if(typeof this._maxResults!="number")throw new Error(`${this._name} - expected maxResults to be a number`)}get minConfidence(){return this._minConfidence}get maxResults(){return this._maxResults}};var za=class extends ln{constructor(){super("SsdMobilenetv1")}forwardInput(t){let{params:n}=this;if(!n)throw new Error("SsdMobilenetv1 - load model before inference");return O(()=>{let r=ae(t.toBatchTensor(512,!1),"float32"),s=de(fe(r,127.5),1),a=eF(s,n.mobilenetv1),{boxPredictions:o,classPredictions:i}=rF(a.out,a.conv11,n.prediction_layer);return nF(o,i,n.output_layer)})}async forward(t){return this.forwardInput(await xt(t))}async locateFaces(t,n={}){let{maxResults:r,minConfidence:s}=new wr(n),a=await xt(t),{boxes:o,scores:i}=this.forwardInput(a),u=o[0],c=i[0];for(let y=1;y<o.length;y++)o[y].dispose(),i[y].dispose();let l=Array.from(c.dataSync()),d=tF(u,l,r,.5,s),h=a.getReshapedInputDimensions(0),f=a.inputSize,g=f/h.width,m=f/h.height,b=u.arraySync(),v=d.map(y=>{let[x,k]=[Math.max(0,b[y][0]),Math.min(1,b[y][2])].map(E=>E*m),[S,N]=[Math.max(0,b[y][1]),Math.min(1,b[y][3])].map(E=>E*g);return new vt(l[y],new uu(S,x,N-S,k-x),{height:a.getInputHeight(0),width:a.getInputWidth(0)})});return u.dispose(),c.dispose(),v}getDefaultModelName(){return"ssd_mobilenetv1_model"}extractParamsFromWeightMap(t){return Q$(t)}extractParams(t){return J$(t)}};function sF(e){let t=new za;return t.extractWeights(e),t}function Gme(e){return sF(e)}var j0=class extends za{};var aF=.4,oF=[new Pe(.738768,.874946),new Pe(2.42204,2.65704),new Pe(4.30971,7.04493),new Pe(10.246,4.59428),new Pe(12.6868,11.8741)],iF=[new Pe(1.603231,2.094468),new Pe(6.041143,7.080126),new Pe(2.882459,3.518061),new Pe(4.266906,5.178857),new Pe(9.041765,10.66308)],uF=[117.001,114.697,97.404],cF="tiny_yolov2_model",lF="tiny_yolov2_separable_conv_model";var Eg=e=>typeof e=="number";function q0(e){if(!e)throw new Error(`invalid config: ${e}`);if(typeof e.withSeparableConvs!="boolean")throw new Error(`config.withSeparableConvs has to be a boolean, have: ${e.withSeparableConvs}`);if(!Eg(e.iouThreshold)||e.iouThreshold<0||e.iouThreshold>1)throw new Error(`config.iouThreshold has to be a number between [0, 1], have: ${e.iouThreshold}`);if(!Array.isArray(e.classes)||!e.classes.length||!e.classes.every(t=>typeof t=="string"))throw new Error(`config.classes has to be an array class names: string[], have: ${JSON.stringify(e.classes)}`);if(!Array.isArray(e.anchors)||!e.anchors.length||!e.anchors.map(t=>t||{}).every(t=>Eg(t.x)&&Eg(t.y)))throw new Error(`config.anchors has to be an array of { x: number, y: number }, have: ${JSON.stringify(e.anchors)}`);if(e.meanRgb&&(!Array.isArray(e.meanRgb)||e.meanRgb.length!==3||!e.meanRgb.every(Eg)))throw new Error(`config.meanRgb has to be an array of shape [number, number, number], have: ${JSON.stringify(e.meanRgb)}`)}function Vl(e){return O(()=>{let t=B(e,xe(.10000000149011612));return X(Ke(de(e,t)),t)})}function qs(e,t){return O(()=>{let n=yr(e,[[0,0],[1,1],[1,1],[0,0]]);return n=Pt(n,t.conv.filters,[1,1],"valid"),n=de(n,t.bn.sub),n=B(n,t.bn.truediv),n=X(n,t.conv.bias),Vl(n)})}function Ks(e,t){return O(()=>{let n=yr(e,[[0,0],[1,1],[1,1],[0,0]]);return n=Fa(n,t.depthwise_filter,t.pointwise_filter,[1,1],"valid"),n=X(n,t.bias),Vl(n)})}function Hme(e,t){let n=Pl(e,t);function r(o,i){let u=He(e(o)),c=He(e(o));return t.push({paramPath:`${i}/sub`},{paramPath:`${i}/truediv`}),{sub:u,truediv:c}}function s(o,i,u){let c=n(o,i,3,`${u}/conv`),l=r(i,`${u}/bn`);return{conv:c,bn:l}}let a=Ol(e,t);return{extractConvParams:n,extractConvWithBatchNormParams:s,extractSeparableConvParams:a}}function dF(e,t,n,r){let{extractWeights:s,getRemainingWeights:a}=Rn(e),o=[],{extractConvParams:i,extractConvWithBatchNormParams:u,extractSeparableConvParams:c}=Hme(s,o),l;if(t.withSeparableConvs){let[p,d,h,f,g,m,b,v,y]=r,x=t.isFirstLayerConv2d?i(p,d,3,"conv0"):c(p,d,"conv0"),k=c(d,h,"conv1"),S=c(h,f,"conv2"),N=c(f,g,"conv3"),E=c(g,m,"conv4"),$=c(m,b,"conv5"),R=v?c(b,v,"conv6"):void 0,D=y?c(v,y,"conv7"):void 0,F=i(y||v||b,5*n,1,"conv8");l={conv0:x,conv1:k,conv2:S,conv3:N,conv4:E,conv5:$,conv6:R,conv7:D,conv8:F}}else{let[p,d,h,f,g,m,b,v,y]=r,x=u(p,d,"conv0"),k=u(d,h,"conv1"),S=u(h,f,"conv2"),N=u(f,g,"conv3"),E=u(g,m,"conv4"),$=u(m,b,"conv5"),R=u(b,v,"conv6"),D=u(v,y,"conv7"),F=i(y,5*n,1,"conv8");l={conv0:x,conv1:k,conv2:S,conv3:N,conv4:E,conv5:$,conv6:R,conv7:D,conv8:F}}if(a().length!==0)throw new Error(`weights remaing after extract: ${a().length}`);return{params:l,paramMappings:o}}function jme(e,t){let n=ur(e,t);function r(i){let u=n(`${i}/sub`,1),c=n(`${i}/truediv`,1);return{sub:u,truediv:c}}function s(i){let u=n(`${i}/filters`,4),c=n(`${i}/bias`,1);return{filters:u,bias:c}}function a(i){let u=s(`${i}/conv`),c=r(`${i}/bn`);return{conv:u,bn:c}}let o=Ml(n);return{extractConvParams:s,extractConvWithBatchNormParams:a,extractSeparableConvParams:o}}function pF(e,t){let n=[],{extractConvParams:r,extractConvWithBatchNormParams:s,extractSeparableConvParams:a}=jme(e,n),o;if(t.withSeparableConvs){let i=t.filterSizes&&t.filterSizes.length||9;o={conv0:t.isFirstLayerConv2d?r("conv0"):a("conv0"),conv1:a("conv1"),conv2:a("conv2"),conv3:a("conv3"),conv4:a("conv4"),conv5:a("conv5"),conv6:i>7?a("conv6"):void 0,conv7:i>8?a("conv7"):void 0,conv8:r("conv8")}}else o={conv0:s("conv0"),conv1:s("conv1"),conv2:s("conv2"),conv3:s("conv3"),conv4:s("conv4"),conv5:s("conv5"),conv6:s("conv6"),conv7:s("conv7"),conv8:r("conv8")};return Fn(e,n),{params:o,paramMappings:n}}var ts=class{_name="TinyYolov2Options";_inputSize;_scoreThreshold;constructor({inputSize:t,scoreThreshold:n}={}){if(this._inputSize=t||416,this._scoreThreshold=n||.5,typeof this._inputSize!="number"||this._inputSize%32!==0)throw new Error(`${this._name} - expected inputSize to be a number divisible by 32`);if(typeof this._scoreThreshold!="number"||this._scoreThreshold<=0||this._scoreThreshold>=1)throw new Error(`${this._name} - expected scoreThreshold to be a number between 0 and 1`)}get inputSize(){return this._inputSize}get scoreThreshold(){return this._scoreThreshold}};var K0=class extends ln{_config;constructor(t){super("TinyYolov2"),q0(t),this._config=t}get config(){return this._config}get withClassScores(){return this.config.withClassScores||this.config.classes.length>1}get boxEncodingSize(){return 5+(this.withClassScores?this.config.classes.length:0)}runTinyYolov2(t,n){let r=qs(t,n.conv0);return r=Ot(r,[2,2],[2,2],"same"),r=qs(r,n.conv1),r=Ot(r,[2,2],[2,2],"same"),r=qs(r,n.conv2),r=Ot(r,[2,2],[2,2],"same"),r=qs(r,n.conv3),r=Ot(r,[2,2],[2,2],"same"),r=qs(r,n.conv4),r=Ot(r,[2,2],[2,2],"same"),r=qs(r,n.conv5),r=Ot(r,[2,2],[1,1],"same"),r=qs(r,n.conv6),r=qs(r,n.conv7),fu(r,n.conv8,"valid",!1)}runMobilenet(t,n){let r=this.config.isFirstLayerConv2d?Vl(fu(t,n.conv0,"valid",!1)):Ks(t,n.conv0);return r=Ot(r,[2,2],[2,2],"same"),r=Ks(r,n.conv1),r=Ot(r,[2,2],[2,2],"same"),r=Ks(r,n.conv2),r=Ot(r,[2,2],[2,2],"same"),r=Ks(r,n.conv3),r=Ot(r,[2,2],[2,2],"same"),r=Ks(r,n.conv4),r=Ot(r,[2,2],[2,2],"same"),r=Ks(r,n.conv5),r=Ot(r,[2,2],[1,1],"same"),r=n.conv6?Ks(r,n.conv6):r,r=n.conv7?Ks(r,n.conv7):r,fu(r,n.conv8,"valid",!1)}forwardInput(t,n){let{params:r}=this;if(!r)throw new Error("TinyYolov2 - load model before inference");return O(()=>{let s=ae(t.toBatchTensor(n,!1),"float32");return s=this.config.meanRgb?Qr(s,this.config.meanRgb):s,s=s.div(255),this.config.withSeparableConvs?this.runMobilenet(s,r):this.runTinyYolov2(s,r)})}async forward(t,n){return this.forwardInput(await xt(t),n)}async detect(t,n={}){let{inputSize:r,scoreThreshold:s}=new ts(n),a=await xt(t),o=await this.forwardInput(a,r),i=O(()=>dt(o)[0].expandDims()),u={width:a.getInputWidth(0),height:a.getInputHeight(0)},c=await this.extractBoxes(i,a.getReshapedInputDimensions(0),s);o.dispose(),i.dispose();let l=c.map(m=>m.box),p=c.map(m=>m.score),d=c.map(m=>m.classScore),h=c.map(m=>this.config.classes[m.label]);return I0(l.map(m=>m.rescale(r)),p,this.config.iouThreshold,!0).map(m=>new Us(p[m],d[m],h[m],l[m],u))}getDefaultModelName(){return""}extractParamsFromWeightMap(t){return pF(t,this.config)}extractParams(t){let n=this.config.filterSizes||K0.DEFAULT_FILTER_SIZES,r=n?n.length:void 0;if(r!==7&&r!==8&&r!==9)throw new Error(`TinyYolov2 - expected 7 | 8 | 9 convolutional filters, but found ${r} filterSizes in config`);return dF(t,this.config,this.boxEncodingSize,n)}async extractBoxes(t,n,r){let{width:s,height:a}=n,o=Math.max(s,a),i=o/s,u=o/a,c=t.shape[1],l=this.config.anchors.length,[p,d,h]=O(()=>{let b=t.reshape([c,c,l,this.boxEncodingSize]),v=b.slice([0,0,0,0],[c,c,l,4]),y=b.slice([0,0,0,4],[c,c,l,1]),x=this.withClassScores?Yr(b.slice([0,0,0,5],[c,c,l,this.config.classes.length]),3):xe(0);return[v,y,x]}),f=[],g=await d.array(),m=await p.array();for(let b=0;b<c;b++)for(let v=0;v<c;v++)for(let y=0;y<l;y++){let x=Wp(g[b][v][y][0]);if(!r||x>r){let k=(v+Wp(m[b][v][y][0]))/c*i,S=(b+Wp(m[b][v][y][1]))/c*u,N=Math.exp(m[b][v][y][2])*this.config.anchors[y].x/c*i,E=Math.exp(m[b][v][y][3])*this.config.anchors[y].y/c*u,$=k-N/2,R=S-E/2,D={row:b,col:v,anchor:y},{classScore:F,label:C}=this.withClassScores?await this.extractPredictedClass(h,D):{classScore:1,label:0};f.push({box:new iu($,R,$+N,R+E),score:x,classScore:x*F,label:C,...D})}}return p.dispose(),d.dispose(),h.dispose(),f}async extractPredictedClass(t,n){let{row:r,col:s,anchor:a}=n,o=await t.array();return Array(this.config.classes.length).fill(0).map((i,u)=>o[r][s][a][u]).map((i,u)=>({classScore:i,label:u})).reduce((i,u)=>i.classScore>u.classScore?i:u)}},vu=K0;uS(vu,"DEFAULT_FILTER_SIZES",[3,16,32,64,128,256,512,1024,1024]);var xu=class extends vu{constructor(t=!0){let n={withSeparableConvs:t,iouThreshold:aF,classes:["face"],...t?{anchors:iF,meanRgb:uF}:{anchors:oF,withClassScores:!0}};super(n)}get withSeparableConvs(){return this.config.withSeparableConvs}get anchors(){return this.config.anchors}async locateFaces(t,n){return(await this.detect(t,n)).map(s=>new vt(s.score,s.relativeBox,{width:s.imageWidth,height:s.imageHeight}))}getDefaultModelName(){return this.withSeparableConvs?lF:cF}extractParamsFromWeightMap(t){return super.extractParamsFromWeightMap(t)}};function qme(e,t=!0){let n=new xu(t);return n.extractWeights(e),n}var Jp=class extends ts{_name="TinyFaceDetectorOptions"};var Ir=class{async then(t){return t(await this.run())}async run(){throw new Error("ComposableTask - run is not implemented")}};async function wu(e,t,n,r,s=({alignedRect:a})=>a){let a=e.map(u=>mu(u)?s(u):u.detection),o=r||(t instanceof Te?await Rl(t,a):await Fl(t,a)),i=await n(o);return o.forEach(u=>u instanceof Te&&u.dispose()),i}async function Ul(e,t,n,r,s){return wu([e],t,async a=>n(a[0]),r,s)}var hF=.4,fF=[new Pe(1.603231,2.094468),new Pe(6.041143,7.080126),new Pe(2.882459,3.518061),new Pe(4.266906,5.178857),new Pe(9.041765,10.66308)],mF=[117.001,114.697,97.404];var Iu=class extends vu{constructor(){let t={withSeparableConvs:!0,iouThreshold:hF,classes:["face"],anchors:fF,meanRgb:mF,isFirstLayerConv2d:!0,filterSizes:[3,16,32,64,128,256,512]};super(t)}get anchors(){return this.config.anchors}async locateFaces(t,n){return(await this.detect(t,n)).map(s=>new vt(s.score,s.relativeBox,{width:s.imageWidth,height:s.imageHeight}))}getDefaultModelName(){return"tiny_face_detector_model"}extractParamsFromWeightMap(t){return super.extractParamsFromWeightMap(t)}};var rt={ssdMobilenetv1:new za,tinyFaceDetector:new Iu,tinyYolov2:new xu,faceLandmark68Net:new gu,faceLandmark68TinyNet:new Yp,faceRecognitionNet:new bu,faceExpressionNet:new Kp,ageGenderNet:new Xp},gF=(e,t)=>rt.ssdMobilenetv1.locateFaces(e,t),Kme=(e,t)=>rt.tinyFaceDetector.locateFaces(e,t),Xme=(e,t)=>rt.tinyYolov2.locateFaces(e,t),bF=e=>rt.faceLandmark68Net.detectLandmarks(e),Yme=e=>rt.faceLandmark68TinyNet.detectLandmarks(e),Zme=e=>rt.faceRecognitionNet.computeFaceDescriptor(e),Jme=e=>rt.faceExpressionNet.predictExpressions(e),Qme=e=>rt.ageGenderNet.predictAgeAndGender(e),yF=e=>rt.ssdMobilenetv1.load(e),ege=e=>rt.tinyFaceDetector.load(e),tge=e=>rt.tinyYolov2.load(e),nge=e=>rt.faceLandmark68Net.load(e),rge=e=>rt.faceLandmark68TinyNet.load(e),sge=e=>rt.faceRecognitionNet.load(e),age=e=>rt.faceExpressionNet.load(e),oge=e=>rt.ageGenderNet.load(e),ige=yF,uge=gF,cge=bF;var Ag=class extends Ir{constructor(n,r,s){super();this.parentTask=n;this.input=r;this.extractedFaces=s}},ku=class extends Ag{async run(){let t=await this.parentTask,n=await wu(t,this.input,async r=>Promise.all(r.map(s=>rt.faceExpressionNet.predictExpressions(s))),this.extractedFaces);return t.map((r,s)=>vg(r,n[s]))}withAgeAndGender(){return new Cu(this,this.input)}},Su=class extends Ag{async run(){let t=await this.parentTask;if(!t)return;let n=await Ul(t,this.input,r=>rt.faceExpressionNet.predictExpressions(r),this.extractedFaces);return vg(t,n)}withAgeAndGender(){return new Tu(this,this.input)}},Ba=class extends ku{withAgeAndGender(){return new Va(this,this.input)}withFaceDescriptors(){return new Xs(this,this.input)}},Wa=class extends Su{withAgeAndGender(){return new Ua(this,this.input)}withFaceDescriptor(){return new Ys(this,this.input)}};var Dg=class extends Ir{constructor(n,r,s){super();this.parentTask=n;this.input=r;this.extractedFaces=s}},Cu=class extends Dg{async run(){let t=await this.parentTask,n=await wu(t,this.input,async r=>Promise.all(r.map(s=>rt.ageGenderNet.predictAgeAndGender(s))),this.extractedFaces);return t.map((r,s)=>{let{age:a,gender:o,genderProbability:i}=n[s];return Ng(_g(r,o,i),a)})}withFaceExpressions(){return new ku(this,this.input)}},Tu=class extends Dg{async run(){let t=await this.parentTask;if(!t)return;let{age:n,gender:r,genderProbability:s}=await Ul(t,this.input,a=>rt.ageGenderNet.predictAgeAndGender(a),this.extractedFaces);return Ng(_g(t,r,s),n)}withFaceExpressions(){return new Su(this,this.input)}},Va=class extends Cu{withFaceExpressions(){return new Ba(this,this.input)}withFaceDescriptors(){return new Xs(this,this.input)}},Ua=class extends Tu{withFaceExpressions(){return new Wa(this,this.input)}withFaceDescriptor(){return new Ys(this,this.input)}};var Qp=class extends Ir{constructor(n,r){super();this.parentTask=n;this.input=r}},Xs=class extends Qp{async run(){let t=await this.parentTask;return(await wu(t,this.input,r=>Promise.all(r.map(s=>rt.faceRecognitionNet.computeFaceDescriptor(s))),null,r=>r.landmarks.align(null,{useDlibAlignment:!0}))).map((r,s)=>Tg(t[s],r))}withFaceExpressions(){return new Ba(this,this.input)}withAgeAndGender(){return new Va(this,this.input)}},Ys=class extends Qp{async run(){let t=await this.parentTask;if(!t)return;let n=await Ul(t,this.input,r=>rt.faceRecognitionNet.computeFaceDescriptor(r),null,r=>r.landmarks.align(null,{useDlibAlignment:!0}));return Tg(t,n)}withFaceExpressions(){return new Wa(this,this.input)}withAgeAndGender(){return new Ua(this,this.input)}};var eh=class extends Ir{constructor(n,r,s){super();this.parentTask=n;this.input=r;this.useTinyLandmarkNet=s}get landmarkNet(){return this.useTinyLandmarkNet?rt.faceLandmark68TinyNet:rt.faceLandmark68Net}},th=class extends eh{async run(){let t=await this.parentTask,n=t.map(o=>o.detection),r=this.input instanceof Te?await Rl(this.input,n):await Fl(this.input,n),s=await Promise.all(r.map(o=>this.landmarkNet.detectLandmarks(o)));return r.forEach(o=>o instanceof Te&&o.dispose()),t.filter((o,i)=>s[i]).map((o,i)=>Bl(o,s[i]))}withFaceExpressions(){return new Ba(this,this.input)}withAgeAndGender(){return new Va(this,this.input)}withFaceDescriptors(){return new Xs(this,this.input)}},nh=class extends eh{async run(){let t=await this.parentTask;if(!t)return;let{detection:n}=t,r=this.input instanceof Te?await Rl(this.input,[n]):await Fl(this.input,[n]),s=await this.landmarkNet.detectLandmarks(r[0]);return r.forEach(a=>a instanceof Te&&a.dispose()),Bl(t,s)}withFaceExpressions(){return new Wa(this,this.input)}withAgeAndGender(){return new Ua(this,this.input)}withFaceDescriptor(){return new Ys(this,this.input)}};var rh=class extends Ir{constructor(n,r=new wr){super();this.input=n;this.options=r}},Gl=class extends rh{async run(){let{input:t,options:n}=this,r;if(n instanceof Jp)r=rt.tinyFaceDetector.locateFaces(t,n);else if(n instanceof wr)r=rt.ssdMobilenetv1.locateFaces(t,n);else if(n instanceof ts)r=rt.tinyYolov2.locateFaces(t,n);else throw new Error("detectFaces - expected options to be instance of TinyFaceDetectorOptions | SsdMobilenetv1Options | TinyYolov2Options");return r}runAndExtendWithFaceDetections(){return new Promise((t,n)=>{this.run().then(r=>t(r.map(s=>lu({},s)))).catch(r=>n(r))})}withFaceLandmarks(t=!1){return new th(this.runAndExtendWithFaceDetections(),this.input,t)}withFaceExpressions(){return new ku(this.runAndExtendWithFaceDetections(),this.input)}withAgeAndGender(){return new Cu(this.runAndExtendWithFaceDetections(),this.input)}},sh=class extends rh{async run(){let t=await new Gl(this.input,this.options),n=t[0];return t.forEach(r=>{r.score>n.score&&(n=r)}),n}runAndExtendWithFaceDetection(){return new Promise(async t=>{let n=await this.run();t(n?lu({},n):void 0)})}withFaceLandmarks(t=!1){return new nh(this.runAndExtendWithFaceDetection(),this.input,t)}withFaceExpressions(){return new Su(this.runAndExtendWithFaceDetection(),this.input)}withAgeAndGender(){return new Tu(this.runAndExtendWithFaceDetection(),this.input)}};function lge(e,t=new wr){return new sh(e,t)}function $g(e,t=new wr){return new Gl(e,t)}async function vF(e,t){return $g(e,new wr(t?{minConfidence:t}:{})).withFaceLandmarks().withFaceDescriptors()}async function dge(e,t={}){return $g(e,new ts(t)).withFaceLandmarks().withFaceDescriptors()}var pge=vF;function X0(e,t){if(e.length!==t.length)throw new Error("euclideanDistance: arr1.length !== arr2.length");let n=Array.from(e),r=Array.from(t);return Math.sqrt(n.map((s,a)=>s-r[a]).reduce((s,a)=>s+a*a,0))}var ah=class{_labeledDescriptors;_distanceThreshold;constructor(t,n=.6){this._distanceThreshold=n;let r=Array.isArray(t)?t:[t];if(!r.length)throw new Error("FaceRecognizer.constructor - expected atleast one input");let s=1,a=()=>`person ${s++}`;this._labeledDescriptors=r.map(o=>{if(o instanceof ws)return o;if(o instanceof Float32Array)return new ws(a(),[o]);if(o.descriptor&&o.descriptor instanceof Float32Array)return new ws(a(),[o.descriptor]);throw new Error("FaceRecognizer.constructor - expected inputs to be of type LabeledFaceDescriptors | WithFaceDescriptor<any> | Float32Array | Array<LabeledFaceDescriptors | WithFaceDescriptor<any> | Float32Array>")})}get labeledDescriptors(){return this._labeledDescriptors}get distanceThreshold(){return this._distanceThreshold}computeMeanDistance(t,n){return n.map(r=>X0(r,t)).reduce((r,s)=>r+s,0)/(n.length||1)}matchDescriptor(t){return this.labeledDescriptors.map(({descriptors:n,label:r})=>new Al(r,this.computeMeanDistance(t,n))).reduce((n,r)=>n.distance<r.distance?n:r)}findBestMatch(t){let n=this.matchDescriptor(t);return n.distance<this._distanceThreshold?n:new Al("unknown",n.distance)}toJSON(){return{distanceThreshold:this._distanceThreshold,labeledDescriptors:this._labeledDescriptors.map(t=>t.toJSON())}}static fromJSON(t){let n=t.labeledDescriptors.map(r=>ws.fromJSON(r));return new ah(n,t.distanceThreshold)}};function hge(e){let t=new Iu;return t.extractWeights(e),t}function xF(e,t){let{width:n,height:r}=new In(t.width,t.height);if(n<=0||r<=0)throw new Error(`resizeResults - invalid dimensions: ${JSON.stringify({width:n,height:r})}`);if(Array.isArray(e))return e.map(s=>xF(s,{width:n,height:r}));if(mu(e)){let s=e.detection.forSize(n,r),a=e.unshiftedLandmarks.forSize(s.box.width,s.box.height);return Bl(lu(e,s),a)}return Is(e)?lu(e,e.detection.forSize(n,r)):e instanceof ir||e instanceof vt?e.forSize(n,r):e}var fge=B$;return aR(mge);})();
